<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Adventure</title>
  <style>
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      background: #000;
      color: #f8f8f2;
      font-family: "Press Start 2P", "Courier New", monospace;
      letter-spacing: 0.04em;
    }
    #sidebar-placeholder,
    #sidebar {
      width: 240px;
      flex-shrink: 0;
      background: rgba(6, 9, 20, 0.85);
      padding: 24px 20px;
      box-shadow: 0 0 25px rgba(12, 20, 56, 0.7);
      backdrop-filter: blur(6px);
      border-right: 1px solid rgba(255, 255, 255, 0.08);
    }

    #sidebar img {
      display: block;
      width: 160px;
      margin: 0 auto 24px;
    }

    #sidebar h3 {
      margin: 0 0 14px;
      font-size: 0.85rem;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: rgba(216, 226, 255, 0.75);
    }

    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0 0 28px;
    }

    #sidebar li {
      margin: 15px 0;
    }

    #sidebar a {
      color: #dce3ff;
      text-decoration: none;
      letter-spacing: 0.5px;
      font-weight: 600;
      transition: color 0.3s, text-shadow 0.3s;
    }

    #sidebar a:hover {
      color: #fffb96;
      text-shadow: 0 0 8px rgba(255, 251, 150, 0.9);
    }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 24px;
      box-sizing: border-box;
      text-align: center;
    }
    h1 {
      margin: 0 0 16px;
      font-size: 28px;
      color: #ffde17;
      text-shadow: 2px 2px #000;
    }
    canvas {
      width: 512px;
      height: 448px;
      image-rendering: pixelated;
      border: 4px solid #ffde17;
      box-shadow: 0 0 16px rgba(255, 222, 23, 0.5);
      background: #2b2b2b;
    }
    #info {
      margin-top: 12px;
      padding: 8px 12px;
      background: rgba(20, 20, 20, 0.85);
      border: 2px solid #ffde17;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
      max-width: 520px;
    }
    #message {
      margin-top: 16px;
      font-size: 14px;
      color: #ffde17;
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Adventure</h1>
    <canvas id="gameCanvas" width="512" height="448"></canvas>
    <div id="info"></div>
    <div id="message">Press Space to Begin</div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    const tileSize = 32;
    const map = [
      "################",
      "#H.....#.......#",
      "#.###..#..###..#",
      "#...#..#..#....#",
      "###.#.##..#.####",
      "#...#....D#....#",
      "#.#####.###.##.#",
      "#.....#.....#..#",
      "#.###.#.###.#G.#",
      "#...#.#...#.#..#",
      "###.#.###.#.##.#",
      "#K..#.....#..C.#",
      "#...#####.#....#",
      "################"
    ];

    const state = {
      game: 'start',
      score: 0,
      lastTime: 0
    };

    const walls = [];
    const hero = { x: 0, y: 0, size: 22, speed: 110, hasKey: false };
    const dragon = { x: 0, y: 0, size: 26, speed: 65 };
    const key = { x: 0, y: 0, size: 18, collected: false };
    const chalice = { x: 0, y: 0, size: 20, collected: false };
    const gate = { x: 0, y: 0, open: false };

    function parseMap() {
      walls.length = 0;
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          const tile = map[y][x];
          const worldX = x * tileSize;
          const worldY = y * tileSize;
          if (tile === '#') {
            walls.push({ x: worldX, y: worldY });
          } else if (tile === 'H') {
            hero.startX = worldX + (tileSize - hero.size) / 2;
            hero.startY = worldY + (tileSize - hero.size) / 2;
          } else if (tile === 'D') {
            dragon.startX = worldX + (tileSize - dragon.size) / 2;
            dragon.startY = worldY + (tileSize - dragon.size) / 2;
          } else if (tile === 'K') {
            key.startX = worldX + (tileSize - key.size) / 2;
            key.startY = worldY + (tileSize - key.size) / 2;
          } else if (tile === 'C') {
            chalice.startX = worldX + (tileSize - chalice.size) / 2;
            chalice.startY = worldY + (tileSize - chalice.size) / 2;
          } else if (tile === 'G') {
            gate.x = worldX;
            gate.y = worldY;
          }
        }
      }
    }

    function resetGame() {
      hero.x = hero.startX;
      hero.y = hero.startY;
      hero.hasKey = false;
      dragon.x = dragon.startX;
      dragon.y = dragon.startY;
      key.x = key.startX;
      key.y = key.startY;
      key.collected = false;
      chalice.x = chalice.startX;
      chalice.y = chalice.startY;
      chalice.collected = false;
      gate.open = false;
      state.score = 0;
      state.game = 'play';
      document.getElementById('message').innerText = '';
    }

    parseMap();
    resetGame();
    state.game = 'start';

    const pressed = new Set();
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) {
        pressed.add(e.code);
        e.preventDefault();
      }
      if (e.code === 'Space') {
        if (state.game === 'start' || state.game === 'gameover' || state.game === 'win') {
          resetGame();
        }
      }
    });
    document.addEventListener('keyup', (e) => {
      pressed.delete(e.code);
    });

    function isBlocked(nx, ny, size) {
      const left = Math.floor(nx / tileSize);
      const right = Math.floor((nx + size - 1) / tileSize);
      const top = Math.floor(ny / tileSize);
      const bottom = Math.floor((ny + size - 1) / tileSize);
      for (let ty = top; ty <= bottom; ty++) {
        for (let tx = left; tx <= right; tx++) {
          const row = map[ty];
          if (!row) return true;
          const tile = row[tx];
          if (!tile || tile === '#') return true;
          if (tile === 'G' && !gate.open) return true;
        }
      }
      return false;
    }

    function moveHero(dt) {
      let mx = 0;
      let my = 0;
      if (pressed.has('ArrowLeft')) mx -= 1;
      if (pressed.has('ArrowRight')) mx += 1;
      if (pressed.has('ArrowUp')) my -= 1;
      if (pressed.has('ArrowDown')) my += 1;
      if (mx !== 0 || my !== 0) {
        const len = Math.hypot(mx, my);
        mx = (mx / len) * hero.speed * dt;
        my = (my / len) * hero.speed * dt;
        const newX = hero.x + mx;
        if (!isBlocked(newX, hero.y, hero.size)) {
          hero.x = newX;
        }
        const newY = hero.y + my;
        if (!isBlocked(hero.x, newY, hero.size)) {
          hero.y = newY;
        }
      }
    }

    function moveDragon(dt) {
      const dx = hero.x - dragon.x;
      const dy = hero.y - dragon.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 1) {
        const speed = dragon.speed * dt;
        const stepX = (dx / dist) * speed;
        const stepY = (dy / dist) * speed;
        const nx = dragon.x + stepX;
        const ny = dragon.y + stepY;
        if (!isBlocked(nx, dragon.y, dragon.size)) {
          dragon.x = nx;
        }
        if (!isBlocked(dragon.x, ny, dragon.size)) {
          dragon.y = ny;
        }
      }
    }

    function overlaps(a, b) {
      const ax = a.x + a.size / 2;
      const ay = a.y + a.size / 2;
      const bx = b.x + b.size / 2;
      const by = b.y + b.size / 2;
      const dist = Math.hypot(ax - bx, ay - by);
      return dist < (a.size + b.size) / 2;
    }

    function update(dt) {
      if (state.game !== 'play') return;
      state.score += dt * 60;
      moveHero(dt);
      moveDragon(dt);

      if (!key.collected && overlaps(hero, key)) {
        key.collected = true;
        hero.hasKey = true;
      }

      if (!gate.open && hero.hasKey) {
        const gateRect = { x: gate.x, y: gate.y, size: tileSize };
        if (overlaps({ x: hero.x, y: hero.y, size: hero.size }, gateRect)) {
          gate.open = true;
        }
      }

      if (!chalice.collected && overlaps(hero, chalice)) {
        chalice.collected = true;
        state.game = 'win';
        document.getElementById('message').innerText = 'You found the Chalice! Press Space to Replay';
        return;
      }

      if (overlaps(hero, dragon)) {
        state.game = 'gameover';
        document.getElementById('message').innerText = 'The dragon caught you! Press Space to Retry';
        return;
      }
    }

    function drawTiles() {
      for (let y = 0; y < map.length; y++) {
        for (let x = 0; x < map[y].length; x++) {
          const tile = map[y][x];
          const px = x * tileSize;
          const py = y * tileSize;
          if (tile === '#') {
            ctx.fillStyle = '#21541c';
            ctx.fillRect(px, py, tileSize, tileSize);
            ctx.strokeStyle = '#122b10';
            ctx.strokeRect(px + 0.5, py + 0.5, tileSize - 1, tileSize - 1);
          } else if (tile === 'G') {
            ctx.fillStyle = gate.open ? '#1f1f1f' : '#b37d4e';
            ctx.fillRect(px, py, tileSize, tileSize);
            if (!gate.open) {
              ctx.strokeStyle = '#e5c07b';
              ctx.strokeRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
            }
          } else {
            ctx.fillStyle = '#2b2b2b';
            ctx.fillRect(px, py, tileSize, tileSize);
          }
        }
      }
    }

    function drawHero() {
      ctx.fillStyle = '#ffde17';
      ctx.fillRect(hero.x, hero.y, hero.size, hero.size);
      ctx.strokeStyle = '#000';
      ctx.strokeRect(hero.x + 0.5, hero.y + 0.5, hero.size - 1, hero.size - 1);
    }

    function drawDragon() {
      ctx.fillStyle = '#d94f30';
      ctx.fillRect(dragon.x, dragon.y, dragon.size, dragon.size);
      ctx.strokeStyle = '#000';
      ctx.strokeRect(dragon.x + 0.5, dragon.y + 0.5, dragon.size - 1, dragon.size - 1);
    }

    function drawKey() {
      if (key.collected) return;
      ctx.fillStyle = '#fff200';
      ctx.fillRect(key.x, key.y, key.size, key.size);
      ctx.fillStyle = '#000';
      ctx.fillRect(key.x + key.size / 2 - 2, key.y + key.size / 4, 4, key.size / 2);
    }

    function drawChalice() {
      if (chalice.collected) return;
      ctx.fillStyle = '#f0ad1a';
      ctx.fillRect(chalice.x, chalice.y, chalice.size, chalice.size);
      ctx.fillStyle = '#000';
      ctx.fillRect(chalice.x + 3, chalice.y + chalice.size - 6, chalice.size - 6, 4);
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTiles();
      drawChalice();
      drawKey();
      drawDragon();
      drawHero();
    }

    function loop(timestamp) {
      const dt = (timestamp - state.lastTime) / 1000 || 0;
      state.lastTime = timestamp;
      if (state.game === 'play') {
        update(dt);
      }
      render();
      document.getElementById('info').innerText = `Key: ${hero.hasKey ? 'Collected' : 'Missing'}  |  Gate: ${gate.open ? 'Open' : 'Closed'}  |  Score: ${Math.floor(state.score)}`;
      if (state.game === 'start') {
        document.getElementById('message').innerText = 'Press Space to Begin';
      }
      requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
