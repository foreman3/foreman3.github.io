<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <title>Arkanoid Redux</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: 'Rubik', system-ui, sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      background: radial-gradient(circle at top, #200531 0%, #05030f 55%, #010106 100%);
      color: #f5f6ff;
      overflow: hidden;
    }

    #sidebar-placeholder {
      width: 250px;
      flex-shrink: 0;
    }

    #game-wrapper {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 32px 24px 48px;
      gap: 18px;
    }

    h1 {
      font-family: 'Press Start 2P', cursive;
      font-size: clamp(1.8rem, 3vw, 2.6rem);
      letter-spacing: 4px;
      text-transform: uppercase;
      margin: 12px 0 0;
      color: #fef1ff;
      text-shadow: 0 0 24px rgba(123, 83, 255, 0.75);
    }

    #hud {
      display: flex;
      gap: 24px;
      font-size: 1rem;
      letter-spacing: 1px;
      text-transform: uppercase;
      font-weight: 600;
    }

    #hud span {
      padding: 8px 18px;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(132, 111, 255, 0.65), rgba(255, 113, 199, 0.65));
      box-shadow: 0 18px 35px rgba(87, 47, 189, 0.35);
    }

    canvas {
      background: radial-gradient(circle at top, rgba(72, 41, 144, 0.45), rgba(5, 4, 24, 0.92));
      border-radius: 22px;
      border: 2px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 32px 60px rgba(10, 0, 45, 0.65), inset 0 0 38px rgba(20, 18, 38, 0.65);
      touch-action: none;
      width: min(100%, 900px);
      aspect-ratio: 900 / 620;
    }

    #message {
      min-height: 28px;
      font-size: 1.05rem;
      letter-spacing: 1px;
      color: #9be7ff;
      text-shadow: 0 0 18px rgba(155, 231, 255, 0.9);
    }

    #powerups {
      display: flex;
      gap: 12px;
      font-size: 0.9rem;
      letter-spacing: 0.75px;
      text-transform: uppercase;
    }

    .badge {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(8, 177, 255, 0.18);
      border: 1px solid rgba(123, 244, 255, 0.45);
      color: #bbf6ff;
      box-shadow: 0 0 18px rgba(27, 201, 255, 0.25);
    }

    @media (max-width: 1100px) {
      body {
        flex-direction: column;
        align-items: center;
      }

      #sidebar-placeholder {
        width: 100%;
      }
    }

    body.touch-device {
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      height: 100svh;
      height: 100dvh;
      height: var(--viewport-height, 100vh);
      min-height: 100vh;
      min-height: 100svh;
      min-height: 100dvh;
      min-height: var(--viewport-height, 100vh);
    }

    body.touch-device #sidebar-placeholder {
      display: none;
    }

    body.touch-device #game-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      height: 100svh;
      height: 100dvh;
      height: var(--viewport-height, 100vh);
      padding: 0;
      align-items: stretch;
      justify-content: center;
      gap: 0;
    }

    body.touch-device h1 {
      display: none;
    }

    body.touch-device #hud {
      position: absolute;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 18px;
      font-family: 'Press Start 2P', cursive;
      font-size: 0.75rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      background: rgba(0, 0, 0, 0.55);
      padding: 12px 18px;
      border-radius: 999px;
      box-shadow: 0 0 24px rgba(0, 0, 0, 0.5);
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.35);
    }

    body.touch-device #hud span {
      background: none;
      box-shadow: none;
      padding: 0;
    }

    body.touch-device #level {
      display: none;
    }

    body.touch-device canvas {
      width: 100vw;
      height: 100vh;
      height: 100svh;
      height: 100dvh;
      height: var(--viewport-height, 100vh);
      max-height: none;
      border-radius: 0;
      border: none;
      box-shadow: none;
    }

    body.touch-device #message,
    body.touch-device #powerups {
      display: none;
    }

    #rotate-overlay {
      position: fixed;
      inset: 0;
      background: rgba(5, 3, 15, 0.92);
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 32px;
      font-size: 1.2rem;
      letter-spacing: 1.2px;
      z-index: 999;
    }

    #rotate-overlay strong {
      display: block;
      margin-bottom: 12px;
      font-size: 1.4rem;
      text-transform: uppercase;
    }

    body.touch-device.touch-portrait #rotate-overlay {
      display: flex;
    }
  </style>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Rubik:wght@400;500;600&display=swap" rel="stylesheet" />
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="rotate-overlay">
    <div>
      <strong>Rotate Device</strong>
      Please turn your phone horizontally for the best Arkanoid experience.
    </div>
  </div>
  <div id="game-wrapper">
    <h1>Arkanoid Redux</h1>
    <div id="hud">
      <span id="score">Score: 0</span>
      <span id="lives">Lives: 3</span>
      <span id="level">Level: 1 / 10</span>
    </div>
    <canvas id="gameCanvas" width="900" height="620"></canvas>
    <div id="message">Move with ‚Üê ‚Üí or A/D. Press Space to fire when equipped.</div>
    <div id="powerups"></div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const messageElement = document.getElementById('message');
    const powerupWrap = document.getElementById('powerups');
    const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;
    const defaultMessage = isTouchDevice
      ? 'Drag to move. Tap to fire when equipped.'
      : 'Move with \u2190 \u2192 or A/D. Press Space to fire when equipped.';
    if (messageElement) {
      messageElement.textContent = defaultMessage;
    }

    function setViewportHeight() {
      document.documentElement.style.setProperty('--viewport-height', `${window.innerHeight}px`);
    }

    if (isTouchDevice) {
      document.body.classList.add('touch-device');
      setViewportHeight();
      window.addEventListener('resize', () => {
        window.requestAnimationFrame(setViewportHeight);
      });
      window.addEventListener('orientationchange', () => {
        window.requestAnimationFrame(() => {
          setViewportHeight();
          setTimeout(setViewportHeight, 250);
        });
      });
    }

    function updateOrientationClass() {
      if (!isTouchDevice) return;
      const isPortrait = window.matchMedia('(orientation: portrait)').matches;
      document.body.classList.toggle('touch-portrait', isPortrait);
    }

    updateOrientationClass();
    window.addEventListener('resize', updateOrientationClass);
    window.addEventListener('orientationchange', updateOrientationClass);

    const paddle = {
      width: 140,
      baseWidth: 140,
      maxWidth: 220,
      height: 18,
      x: canvas.width / 2 - 70,
      y: canvas.height - 50,
      speed: 8,
      expandTimer: 0,
      gunsTimer: 0
    };

    const balls = [];
    const bullets = [];
    const powerups = [];
    const keys = {};

    let waitingForRestart = false;

    const SCORE_PER_BRICK = 75;
    let score = 0;
    let lives = 3;
    let levelIndex = 0;
    let messageTimer = 0;
    let slowTimer = 0;
    let slowFactor = 1;
    let lastShot = 0;
    let touchStartX = 0;
    let touchMovedDistance = 0;
    let touchStartTime = 0;

    const levelMaps = [
      [
        '#############',
        '#############',
        '#############',
        '#############'
      ],
      [
        '#.#.#.#.#.#.#',
        '#############',
        '#.#.#.#.#.#.#',
        '#############'
      ],
      [
        '#############',
        '#.........#.#',
        '#############',
        '#.#.........#',
        '#############'
      ],
      [
        '#############',
        '###.....#####',
        '###.###.#####',
        '###.....#####',
        '#############'
      ],
      [
        '#############',
        '##.#######.##',
        '#..#####..###',
        '#.##...##.###',
        '#############'
      ],
      [
        '#############',
        '###.#####.###',
        '##..#####..##',
        '#..#######..#',
        '#############',
        '#.#.#.#.#.#.#'
      ],
      [
        '#############',
        '#.#.#.#.#.#.#',
        '###.#####.###',
        '#.#.#####.#.#',
        '###.#####.###',
        '#.#.#.#.#.#.#'
      ],
      [
        '#############',
        '#..#...#...#.',
        '###.###.###.#',
        '#...#...#..#.',
        '###.###.###.#',
        '#...#...#..#.',
        '#############'
      ],
      [
        '#############',
        '###.......###',
        '#.#.#####.#.#',
        '#...#####...#',
        '#.#.#####.#.#',
        '###.......###',
        '#############'
      ],
      [
        '#############',
        '#.#.#.#.#.#.#',
        '##.#######.##',
        '#..#.#.#.#..#',
        '###.#####.###',
        '#..#.#.#.#..#',
        '##.#######.##',
        '#.#.#.#.#.#.#'
      ]
    ];

    let bricks = [];
    let brickWidth = 0;
    let brickHeight = 24;
    let brickPadding = 12;
    let brickOffsetTop = 80;
    let brickOffsetLeft = 45;

    function resetBall() {
      balls.length = 0;
      const baseAngle = -Math.PI / 2 + (Math.random() * 0.4 - 0.2);
      balls.push(createBall(canvas.width / 2, paddle.y - 16, baseAngle));
    }

    function createBall(x, y, angle = -Math.PI / 2 + 0.2) {
      const speed = 6.1;
      const vx = speed * Math.cos(angle);
      const vy = speed * Math.sin(angle);
      return { x, y, radius: 8, speed, vx, vy };
    }

    function buildLevel(spawnBall = true) {
      const map = levelMaps[levelIndex];
      const rows = map.length;
      const cols = map[0].length;
      brickWidth = Math.floor((canvas.width - brickOffsetLeft * 2 - (cols - 1) * brickPadding) / cols);
      bricks = [];
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          if (map[row][col] === '#') {
            bricks.push({
              x: brickOffsetLeft + col * (brickWidth + brickPadding),
              y: brickOffsetTop + row * (brickHeight + brickPadding),
              width: brickWidth,
              height: brickHeight,
              alive: true,
              color: getBrickColor(row, col)
            });
          }
        }
      }
      updateHud();
      if (spawnBall) {
        resetBall();
      } else {
        balls.length = 0;
      }
    }

    function describeLevel() {
      const descriptions = [
        'Classic warm-up',
        'Alternating lanes',
        'Edge challenges',
        'Offset stacks',
        'Pocket corridors',
        'Staggered walls',
        'Lattice gauntlet',
        'Serpentine maze',
        'Fortress gates',
        'Final weave'
      ];
      return descriptions[levelIndex] || 'New layout';
    }

    function getBrickColor(row, col) {
      const baseColors = [
        '#ffa5f7', '#9b7bff', '#67f7ff', '#ffe066', '#ff8d7b', '#7df9b2'
      ];
      return baseColors[(row + col) % baseColors.length];
    }

    function updateHud() {
      document.getElementById('score').textContent = `Score: ${score}`;
      document.getElementById('lives').textContent = `Lives: ${lives}`;
      document.getElementById('level').textContent = `Level: ${levelIndex + 1} / ${levelMaps.length}`;
    }

    function showMessage(text, duration = 2600) {
      if (!messageElement) return;
      messageElement.textContent = text;
      messageTimer = duration;
    }

    function spawnPowerup(x, y) {
      const types = ['expand', 'slow', 'guns', 'multi'];
      const type = types[Math.floor(Math.random() * types.length)];
      powerups.push({
        x: x - 14,
        y: y,
        size: 28,
        vy: 2.6,
        type
      });
    }

    function applyPowerup(type) {
      if (type === 'expand') {
        paddle.width = Math.min(paddle.width * 1.2, paddle.maxWidth);
        paddle.expandTimer = 11000;
        addBadge('Wide paddle');
      } else if (type === 'slow') {
        slowFactor = 0.7;
        slowTimer = 9000;
        addBadge('Slow time');
      } else if (type === 'guns') {
        paddle.gunsTimer = 8500;
        addBadge('Plasma guns');
      } else if (type === 'multi') {
        splitBall();
        addBadge('Multi-ball');
      }
    }

    function addBadge(text) {
      if (!powerupWrap) return;
      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.textContent = text;
      powerupWrap.appendChild(badge);
      setTimeout(() => badge.remove(), 4000);
    }

    function splitBall() {
      if (balls.length >= 7) {
        return;
      }
      const newBalls = [];
      balls.forEach(ball => {
        const baseAngle = Math.atan2(ball.vy, ball.vx);
        const offsets = [-0.35, 0, 0.35];
        offsets.forEach(offset => {
          const angle = baseAngle + offset;
          const speed = ball.speed;
          newBalls.push({
            x: ball.x,
            y: ball.y,
            radius: ball.radius,
            speed,
            vx: speed * Math.cos(angle),
            vy: speed * Math.sin(angle)
          });
        });
      });
      balls.length = 0;
      newBalls.forEach(ball => balls.push(ball));
    }

    function update(delta) {
      const dt = delta / 16.67;

      if (messageTimer > 0 && Number.isFinite(messageTimer)) {
        messageTimer -= delta;
        if (messageTimer <= 0) {
          messageTimer = 0;
          if (messageElement) {
            messageElement.textContent = defaultMessage;
          }
        }
      }

      if (paddle.expandTimer > 0) {
        paddle.expandTimer -= delta;
        if (paddle.expandTimer <= 0) {
          paddle.width = paddle.baseWidth;
        }
      }

      if (paddle.gunsTimer > 0) {
        paddle.gunsTimer -= delta;
        if (paddle.gunsTimer <= 0) {
          paddle.gunsTimer = 0;
        }
      }

      if (slowTimer > 0) {
        slowTimer -= delta;
        if (slowTimer <= 0) {
          slowFactor = 1;
        }
      }

      handleInput(dt);
      if (waitingForRestart) {
        return;
      }
      updateBalls(dt);
      updateBullets(dt);
      updatePowerups(dt);
      checkLevelComplete();
    }

    function attemptShoot(now = performance.now()) {
      if (paddle.gunsTimer > 0 && now - lastShot > 220) {
        bullets.push({ x: paddle.x + paddle.width / 2 - 4, y: paddle.y - 10, vy: -11 });
        bullets.push({ x: paddle.x + paddle.width / 2 + 4, y: paddle.y - 10, vy: -11 });
        lastShot = now;
      }
    }

    function updatePaddleFromTouch(touch) {
      const rect = canvas.getBoundingClientRect();
      const relativeX = ((touch.clientX - rect.left) / rect.width) * canvas.width;
      const clamped = Math.max(0, Math.min(canvas.width - paddle.width, relativeX - paddle.width / 2));
      paddle.x = clamped;
    }

    function handleTouchStart(event) {
      if (!isTouchDevice) return;
      const touch = event.touches[0];
      if (!touch) return;
      event.preventDefault();
      touchStartX = touch.clientX;
      touchMovedDistance = 0;
      touchStartTime = performance.now();
      updatePaddleFromTouch(touch);
    }

    function handleTouchMove(event) {
      if (!isTouchDevice) return;
      const touch = event.touches[0];
      if (!touch) return;
      event.preventDefault();
      touchMovedDistance = Math.max(touchMovedDistance, Math.abs(touch.clientX - touchStartX));
      updatePaddleFromTouch(touch);
    }

    function handleTouchEnd(event) {
      if (!isTouchDevice) return;
      const touch = event.changedTouches[0];
      if (!touch) return;
      event.preventDefault();
      const duration = performance.now() - touchStartTime;
      if (touchMovedDistance < 18 && duration < 300) {
        attemptShoot();
      }
    }

    function handleInput(dt) {
      const move = paddle.speed * dt * 1.2;
      if (keys['ArrowLeft'] || keys['KeyA']) {
        paddle.x = Math.max(0, paddle.x - move);
      }
      if (keys['ArrowRight'] || keys['KeyD']) {
        paddle.x = Math.min(canvas.width - paddle.width, paddle.x + move);
      }
      if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
        attemptShoot();
      }
    }

    function updateBalls(dt) {
      const factor = slowFactor * dt;
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        ball.x += ball.vx * factor;
        ball.y += ball.vy * factor;

        if (ball.x + ball.radius > canvas.width) {
          ball.x = canvas.width - ball.radius;
          ball.vx *= -1;
        } else if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.vx *= -1;
        }

        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          ball.vy *= -1;
        }

        if (ball.y + ball.radius > canvas.height) {
          balls.splice(i, 1);
          continue;
        }

        handlePaddleCollision(ball);
        handleBrickCollisions(ball);
      }

      if (balls.length === 0) {
        lives -= 1;
        updateHud();
        if (lives <= 0) {
          const finalScore = score;
          levelIndex = 0;
          resetLevel(true, false, false);
          waitingForRestart = true;
          showMessage(`Game Over! Final score: ${finalScore}. Press R to restart.`, Infinity);
          return;
        }
        showMessage('Lost a ball!');
        resetBall();
      }
    }

    function handlePaddleCollision(ball) {
      if (
        ball.y + ball.radius >= paddle.y &&
        ball.y + ball.radius <= paddle.y + paddle.height &&
        ball.x >= paddle.x &&
        ball.x <= paddle.x + paddle.width &&
        ball.vy > 0
      ) {
        const relative = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
        const angle = relative * (Math.PI / 3) - Math.PI / 2;
        const speed = ball.speed;
        ball.vx = speed * Math.cos(angle);
        ball.vy = speed * Math.sin(angle);
        ball.y = paddle.y - ball.radius - 1;
      }
    }

    function handleBrickCollisions(ball) {
      for (const brick of bricks) {
        if (!brick.alive) continue;
        if (
          ball.x + ball.radius > brick.x &&
          ball.x - ball.radius < brick.x + brick.width &&
          ball.y + ball.radius > brick.y &&
          ball.y - ball.radius < brick.y + brick.height
        ) {
          brick.alive = false;
          score += SCORE_PER_BRICK;
          updateHud();
          const overlapLeft = ball.x + ball.radius - brick.x;
          const overlapRight = brick.x + brick.width - (ball.x - ball.radius);
          const overlapTop = ball.y + ball.radius - brick.y;
          const overlapBottom = brick.y + brick.height - (ball.y - ball.radius);
          const minOverlapX = Math.min(overlapLeft, overlapRight);
          const minOverlapY = Math.min(overlapTop, overlapBottom);

          if (minOverlapX < minOverlapY) {
            ball.vx *= -1;
          } else {
            ball.vy *= -1;
          }
          ball.speed = Math.hypot(ball.vx, ball.vy);

          if (Math.random() < 0.1) {
            spawnPowerup(brick.x + brick.width / 2, brick.y + brick.height / 2);
          }
          break;
        }
      }
    }

    function updateBullets(dt) {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.y += bullet.vy * dt;
        if (bullet.y < 0) {
          bullets.splice(i, 1);
          continue;
        }
        for (const brick of bricks) {
          if (!brick.alive) continue;
          if (
            bullet.x >= brick.x &&
            bullet.x <= brick.x + brick.width &&
            bullet.y >= brick.y &&
            bullet.y <= brick.y + brick.height
          ) {
            brick.alive = false;
            bullets.splice(i, 1);
            score += SCORE_PER_BRICK;
            updateHud();
            if (Math.random() < 0.1) {
              spawnPowerup(brick.x + brick.width / 2, brick.y + brick.height / 2);
            }
            break;
          }
        }
      }
    }

    function updatePowerups(dt) {
      for (let i = powerups.length - 1; i >= 0; i--) {
        const power = powerups[i];
        power.y += power.vy * dt;
        if (
          power.y + power.size >= paddle.y &&
          power.x + power.size >= paddle.x &&
          power.x <= paddle.x + paddle.width &&
          power.y <= paddle.y + paddle.height
        ) {
          applyPowerup(power.type);
          powerups.splice(i, 1);
          continue;
        }
        if (power.y > canvas.height + 40) {
          powerups.splice(i, 1);
        }
      }
    }

    function checkLevelComplete() {
      if (bricks.every(brick => !brick.alive)) {
        levelIndex += 1;
        if (levelIndex >= levelMaps.length) {
          const finalScore = score;
          levelIndex = 0;
          resetLevel(true, false, false);
          waitingForRestart = true;
          showMessage(`You cleared all sectors! Final score: ${finalScore}. Press R to play again.`, Infinity);
        } else {
          resetLevel(false);
        }
      }
    }

    function resetLevel(resetScore = false, announce = true, spawnBall = true) {
      waitingForRestart = false;
      powerups.length = 0;
      bullets.length = 0;
      if (resetScore) {
        score = 0;
        lives = 3;
      }
      paddle.width = paddle.baseWidth;
      paddle.expandTimer = 0;
      paddle.gunsTimer = 0;
      slowTimer = 0;
      slowFactor = 1;
      updateHud();
      buildLevel(spawnBall);
      if (announce) {
        let baseMessage = `Level ${levelIndex + 1}: ${describeLevel()}`;
        if (levelIndex === 0 && resetScore) {
          baseMessage += ` ‚Äî ${defaultMessage}`;
        }
        const duration = levelIndex === 0 && resetScore ? 5200 : 2600;
        showMessage(baseMessage, duration);
      }
    }

    function drawRoundedRect(context, x, y, width, height, radius) {
      const r = Math.min(radius, width / 2, height / 2);
      context.beginPath();
      context.moveTo(x + r, y);
      context.lineTo(x + width - r, y);
      context.quadraticCurveTo(x + width, y, x + width, y + r);
      context.lineTo(x + width, y + height - r);
      context.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      context.lineTo(x + r, y + height);
      context.quadraticCurveTo(x, y + height, x, y + height - r);
      context.lineTo(x, y + r);
      context.quadraticCurveTo(x, y, x + r, y);
      context.closePath();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (const brick of bricks) {
        if (!brick.alive) continue;
        ctx.fillStyle = brick.color;
        drawRoundedRect(ctx, brick.x, brick.y, brick.width, brick.height, 6);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.stroke();
      }

      ctx.fillStyle = '#fff1ff';
      drawRoundedRect(ctx, paddle.x, paddle.y, paddle.width, paddle.height, 12);
      ctx.fill();
      ctx.fillStyle = '#8b7bff';
      ctx.fillRect(paddle.x, paddle.y + paddle.height - 4, paddle.width, 4);

      ctx.fillStyle = '#ffeedd';
      for (const ball of balls) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.fillStyle = '#8bfcff';
      powerups.forEach(power => {
        drawRoundedRect(ctx, power.x, power.y, power.size, power.size, 6);
        ctx.fill();
        ctx.fillStyle = '#132c3a';
        ctx.font = '14px Rubik';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const icon = power.type === 'expand' ? '‚Üî' : power.type === 'slow' ? '‚è≥' : power.type === 'guns' ? 'üî´' : '‚ú¶';
        ctx.fillText(icon, power.x + power.size / 2, power.y + power.size / 2 + 1);
        ctx.fillStyle = '#8bfcff';
      });

      ctx.fillStyle = '#ffe07d';
      bullets.forEach(bullet => {
        ctx.fillRect(bullet.x - 2, bullet.y - 10, 4, 10);
      });
    }

    let lastTime = performance.now();
    function loop(timestamp) {
      const delta = timestamp - lastTime;
      lastTime = timestamp;
      update(delta);
      draw();
      requestAnimationFrame(loop);
    }

    if (isTouchDevice) {
      const listenerOptions = { passive: false };
      canvas.addEventListener('touchstart', handleTouchStart, listenerOptions);
      canvas.addEventListener('touchmove', handleTouchMove, listenerOptions);
      canvas.addEventListener('touchend', handleTouchEnd, listenerOptions);
      canvas.addEventListener('touchcancel', handleTouchEnd, listenerOptions);
    }

    document.addEventListener('keydown', (event) => {
      keys[event.code] = true;
      if (event.code === 'KeyR') {
        levelIndex = 0;
        resetLevel(true);
      }
    });

    document.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });

    if (!isTouchDevice) {
      fetch('sidebar.html')
        .then(response => response.text())
        .then(html => {
          const placeholder = document.getElementById('sidebar-placeholder');
          if (placeholder) {
            placeholder.outerHTML = html;
          }
        });
    } else {
      const placeholder = document.getElementById('sidebar-placeholder');
      if (placeholder) {
        placeholder.remove();
      }
    }

    resetLevel(true);
    requestAnimationFrame(loop);
  </script>
</body>
</html>
