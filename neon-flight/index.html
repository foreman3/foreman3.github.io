<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />
  <title>Neon Flight</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: #000;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      overflow: hidden;
    }
    body.mobile {
      flex-direction: column;
      align-items: center;
    }
    body.touch-device {
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      height: 100svh;
      height: 100dvh;
      height: var(--viewport-height, 100vh);
      min-height: 100vh;
      min-height: 100svh;
      min-height: 100dvh;
      min-height: var(--viewport-height, 100vh);
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    body.mobile #sidebar-placeholder,
    body.touch-device #sidebar-placeholder,
    body.mobile #sidebar,
    body.touch-device #sidebar {
      display: none;
    }
    #sidebar ul { list-style:none; padding:0; margin:0; }
    #sidebar li { margin:15px 0; }
    #sidebar a { color:#fff; text-decoration:none; transition:color 0.3s; }
    #sidebar a:hover { color:#0f0; }
    #game-container {
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:20px;
    }
    body.mobile #game-container,
    body.touch-device #game-container {
      width: 100vw;
      height: var(--viewport-height, 100vh);
      padding: 16px 18px 24px;
      box-sizing: border-box;
      justify-content: flex-start;
      gap: 12px;
    }
    body.touch-device.touch-portrait #game-container {
      pointer-events: none;
    }
    body.touch-device #game-container h1 {
      text-align: center;
    }
    canvas {
      background:#000;
      border:2px solid #0f0;
      border-radius:8px;
      width:100%;
      height:auto;
      max-height:80vh;
    }
    #info {
      margin-top:10px;
      font-size:20px;
      color:#0f0;
    }
    #message {
      margin-top:10px;
      font-size:24px;
      color:#0f0;
      text-shadow:1px 1px 3px rgba(0,255,0,0.5);
    }
    body.mobile #message,
    body.touch-device #message {
      text-align: center;
      font-size: 20px;
    }
    #restartButton {
      margin-top: 8px;
      padding: 10px 24px;
      border-radius: 999px;
      border: 2px solid rgba(0, 255, 102, 0.65);
      background: rgba(0, 0, 0, 0.65);
      color: #8effd2;
      font-size: 16px;
      letter-spacing: 1px;
      text-transform: uppercase;
      display: none;
      cursor: pointer;
      transition: background 0.2s, transform 0.2s;
    }
    #restartButton:active {
      transform: scale(0.97);
    }
    #restartButton.visible {
      display: inline-flex;
    }
    #restartButton:disabled {
      opacity: 0.6;
      cursor: default;
    }
    #orientation-warning {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.92);
      color: #8cfffb;
      display: none;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 1.2rem;
      letter-spacing: 1.2px;
      padding: 40px 24px;
      z-index: 20;
    }
    #orientation-warning.visible {
      display: flex;
    }
    body.touch-device #orientation-warning {
      font-size: 1rem;
      padding: 32px 20px;
    }
  </style>
  <link rel="stylesheet" href="../sidebar.css" />
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Neon Flight</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">Distance: 0 | Score: 0</div>
    <div id="message">Use arrow keys to dodge buildings and bridges</div>
    <button id="restartButton" type="button">Restart</button>
  </div>
  <div id="orientation-warning">Rotate your device to landscape to play.</div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const infoElement = document.getElementById('info');
    const messageElement = document.getElementById('message');
    const restartButton = document.getElementById('restartButton');
    const orientationWarning = document.getElementById('orientation-warning');
    const titleElement = document.querySelector('#game-container h1');

    const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
    const isTouchDevice = hasCoarsePointer;
    const isMobile = isTouchDevice || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    if (isMobile) {
      document.body.classList.add('mobile');
    }
    if (isTouchDevice) {
      document.body.classList.add('touch-device');
    }

    function setViewportHeight() {
      document.documentElement.style.setProperty('--viewport-height', `${window.innerHeight}px`);
    }

    function getViewportHeight() {
      const rawValue = getComputedStyle(document.documentElement).getPropertyValue('--viewport-height');
      const numeric = parseFloat(rawValue);
      return Number.isFinite(numeric) && numeric > 0 ? numeric : window.innerHeight;
    }

    let attemptedFullscreen = false;
    let fullscreenListenersBound = false;

    function isFullscreenActive() {
      return Boolean(
        document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.msFullscreenElement
      );
    }

    function requestFullscreen() {
      if (attemptedFullscreen) return;
      attemptedFullscreen = true;
      if (isFullscreenActive()) return;

      const target = document.documentElement;
      const request =
        target.requestFullscreen ||
        target.webkitRequestFullscreen ||
        target.msRequestFullscreen;

      if (!request) {
        attemptedFullscreen = false;
        return;
      }

      try {
        const result = request.call(target);
        if (result && typeof result.then === 'function') {
          result.catch(() => {
            attemptedFullscreen = false;
          });
        }
      } catch (err) {
        attemptedFullscreen = false;
      }
    }

    function bindFullscreenRequest() {
      if (!isTouchDevice) return;
      if (fullscreenListenersBound) return;

      const target = document.documentElement;
      const hasRequestMethod = Boolean(
        target.requestFullscreen ||
          target.webkitRequestFullscreen ||
          target.msRequestFullscreen
      );
      if (!hasRequestMethod) return;

      const tryRequest = () => {
        if (isFullscreenActive()) {
          return;
        }
        requestFullscreen();
      };

      canvas.addEventListener('touchend', tryRequest);
      canvas.addEventListener('mouseup', tryRequest);
      fullscreenListenersBound = true;
    }

    function handleFullscreenChange() {
      attemptedFullscreen = false;
      if (isFullscreenActive()) {
        lastTimestamp = 0;
        resetGame();
      } else if (isTouchDevice) {
        bindFullscreenRequest();
      }
    }

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);

    function getOrientationAngle() {
      if (screen.orientation && typeof screen.orientation.angle === 'number') {
        return screen.orientation.angle;
      }
      if (typeof window.orientation === 'number') {
        return window.orientation;
      }
      return window.innerWidth >= window.innerHeight ? 90 : 0;
    }

    function normalizeAngle(angle) {
      if (!Number.isFinite(angle)) return 0;
      let normalized = angle % 360;
      if (normalized < 0) normalized += 360;
      return normalized;
    }

    const tiltState = { active: false, lateral: 0, vertical: 0, lastUpdate: 0 };
    let tiltPermissionRequested = false;

    function mapTiltAxes(beta, gamma) {
      const angle = normalizeAngle(getOrientationAngle());
      const clampTilt = value => clamp(value, -1, 1);

      if (angle > 45 && angle <= 135) {
        return {
          lateral: clampTilt(beta / 45),
          vertical: clampTilt(-gamma / 45)
        };
      }
      if (angle > 225 && angle <= 315) {
        return {
          lateral: clampTilt(-beta / 45),
          vertical: clampTilt(gamma / 45)
        };
      }
      if (angle > 135 && angle <= 225) {
        return {
          lateral: clampTilt(-gamma / 45),
          vertical: clampTilt(beta / 45)
        };
      }
      return {
        lateral: clampTilt(gamma / 45),
        vertical: clampTilt(-beta / 45)
      };
    }

    function handleDeviceOrientation(event) {
      const { beta, gamma } = event;
      if (typeof beta !== 'number' || typeof gamma !== 'number') return;
      const mapped = mapTiltAxes(beta, gamma);
      const smoothing = 0.2;
      tiltState.lateral = lerp(tiltState.lateral, mapped.lateral, smoothing);
      tiltState.vertical = lerp(tiltState.vertical, mapped.vertical, smoothing);
      tiltState.lastUpdate = performance.now();
      tiltState.active = true;
    }

    function enableTiltControls() {
      if (!isMobile) return;
      if (tiltPermissionRequested) return;
      tiltPermissionRequested = true;

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(state => {
            if (state === 'granted') {
              window.addEventListener('deviceorientation', handleDeviceOrientation, true);
            }
          })
          .catch(() => {
            tiltState.active = false;
          });
      } else if ('DeviceOrientationEvent' in window) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
      }
    }

    function updateOrientationWarning() {
      if (!isMobile || !orientationWarning) return;
      const viewportHeight = getViewportHeight();
      const isLandscape = window.innerWidth >= viewportHeight;
      orientationWarning.classList.toggle('visible', !isLandscape);
      if (isTouchDevice) {
        document.body.classList.toggle('touch-portrait', !isLandscape);
      }
    }

    if (isTouchDevice) {
      setViewportHeight();
    }

    if (isMobile) {
      updateOrientationWarning();
    }

    if (isTouchDevice) {
      bindFullscreenRequest();
    }

    if (isMobile) {
      canvas.addEventListener(
        'touchstart',
        () => {
          enableTiltControls();
        },
        { passive: true }
      );
      canvas.addEventListener('click', enableTiltControls);
    }

    if (restartButton) {
      restartButton.addEventListener('click', () => {
        if (!running) {
          lastTimestamp = 0;
          resetGame();
        }
      });
    }

    function clamp(value, min, max){
      return Math.max(min, Math.min(max, value));
    }

    function hexToRgb(hex){
      const clean = hex.replace('#','');
      const value = clean.length === 3
        ? clean.split('').map(c => c + c).join('')
        : clean.padEnd(6, '0');
      const r = parseInt(value.slice(0,2),16);
      const g = parseInt(value.slice(2,4),16);
      const b = parseInt(value.slice(4,6),16);
      return {r,g,b};
    }

    function adjustColor(hex, amount){
      const {r,g,b} = hexToRgb(hex);
      return `rgb(${clamp(r+amount,0,255)},${clamp(g+amount,0,255)},${clamp(b+amount,0,255)})`;
    }

    function withAlpha(hex, alpha){
      const {r,g,b} = hexToRgb(hex);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function lerp(a,b,t){
      return a + (b-a)*t;
    }

    function lerpPoint(p1,p2,t){
      return {
        x: lerp(p1.x, p2.x, t),
        y: lerp(p1.y, p2.y, t)
      };
    }

    function damp(current, target, lambda, dt){
      const t = 1 - Math.exp(-lambda * dt);
      return lerp(current, target, clamp(t, 0, 1));
    }

    function resizeGame(){
      const sidebar = document.getElementById('sidebar');
      const includeSidebar = sidebar && !isMobile && !isTouchDevice;
      const sidebarWidth = includeSidebar ? sidebar.offsetWidth : 0;
      const aspect = 4 / 3;
      const horizontalPadding = isMobile ? 24 : 40;
      const verticalPadding = isMobile ? 36 : 40;
      const viewportHeight = isTouchDevice ? getViewportHeight() : window.innerHeight;
      const headerHeight = titleElement ? titleElement.offsetHeight : 0;
      const infoHeight = infoElement ? infoElement.offsetHeight : 0;
      const messageHeight = messageElement ? messageElement.offsetHeight : 0;

      let availableWidth = window.innerWidth - sidebarWidth - horizontalPadding;
      let availableHeight = viewportHeight - headerHeight - infoHeight - messageHeight - verticalPadding;

      if (isMobile) {
        availableWidth = window.innerWidth - horizontalPadding;
      }

      availableWidth = Math.max(200, availableWidth);
      availableHeight = Math.max(200, availableHeight);

      let width = availableWidth;
      let height = width / aspect;

      if (height > availableHeight) {
        height = availableHeight;
        width = height * aspect;
      }

      width = Math.max(220, width);
      height = Math.max(220 / aspect, height);

      canvas.width = width;
      canvas.height = height;
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;
    }

    function handleLayoutChange(){
      resizeGame();
      if (isMobile) {
        updateOrientationWarning();
      }
    }

    if (isTouchDevice) {
      const scheduleLayoutUpdate = () => {
        window.requestAnimationFrame(() => {
          setViewportHeight();
          handleLayoutChange();
          setTimeout(() => {
            setViewportHeight();
            handleLayoutChange();
          }, 250);
        });
      };

      window.addEventListener('resize', scheduleLayoutUpdate);
      window.addEventListener('orientationchange', () => {
        attemptedFullscreen = false;
        scheduleLayoutUpdate();
      });
    } else {
      window.addEventListener('resize', handleLayoutChange);
      window.addEventListener('orientationchange', () => {
        attemptedFullscreen = false;
        handleLayoutChange();
      });
    }

    const FOV = 300;
    const NEAR_FOCUS_DISTANCE = 220;
    const MIN_PERSPECTIVE_CLAMP = 8;
    const PLANE_Z = -FOV * 0.8; // place the plane further down the z-axis
    const BUILDING_VIEW_DISTANCE = 2200;
    const BUILDING_DESPAWN_DISTANCE = 350;
    const BUILDING_SPAWN_START = 400;
    const BUILDING_SPACING_MIN = 160;
    const BUILDING_SPACING_VARIANCE = 260;
    const PLANE_HALF_WIDTH = 22;
    const PLANE_HALF_HEIGHT = 12;
    const PLANE_HALF_DEPTH = 55;
    const COLLISION_FRONT_THRESHOLD = -10; // require buildings to overlap the plane before collisions register
    const RING_SPAWN_DISTANCE = 1600;
    const RING_DESPAWN_BUFFER = 200;
    const palettes = [
      { base:'#06f2ff', accent:'#25a8ff', glow:'#7dffff', windows:'#b9f9ff' },
      { base:'#ff3be7', accent:'#ff6ab3', glow:'#ff9df2', windows:'#ffd6fa' },
      { base:'#6bff8a', accent:'#30ffa7', glow:'#9affc3', windows:'#d2ffe6' },
      { base:'#ffd166', accent:'#ffa733', glow:'#ffe9ab', windows:'#fff2cf' }
    ];

    let plane, buildings, rings, distance, score, nextRing, running;
    let playerZ, nextBuildingZ;
    const keyState = new Set();
    const controlState = { lateral: 0, vertical: 0, throttle: 0 };
    let stars = [];
    let nebulae = [];
    let auroraBands = [];

    function resetGame(){
      plane = {
        x: 0,
        y: 70,
        z: PLANE_Z,
        forwardSpeed: 420,
        minSpeed: 320,
        maxSpeed: 640,
        cruiseSpeed: 420,
        throttleResponse: 420,
        maxStrafeSpeed: 280,
        maxClimbSpeed: 220,
        steerResponsiveness: 7.5,
        maxRoll: 32,
        maxPitch: 18,
        vx: 0,
        vy: 0,
        roll: 0,
        pitch: 0
      };
      buildings = [];
      rings = [];
      distance = 0;
      score = 0;
      nextRing = 1000;
      running = true;
      playerZ = 0;
      nextBuildingZ = BUILDING_SPAWN_START;
      controlState.lateral = 0;
      controlState.vertical = 0;
      controlState.throttle = 0;
      keyState.delete('Space');
      keyState.delete('ShiftLeft');
      keyState.delete('ShiftRight');
      keyState.delete('KeyE');
      keyState.delete('KeyQ');
      if (messageElement) {
        messageElement.textContent = isMobile
          ? 'Tilt your device to steer through the neon skyline'
          : 'WASD/Arrow keys steer · Space boosts · Shift slows';
      }
      stars = Array.from({length:160}, () => ({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        size: 1 + Math.random()*2,
        speed: 0.4 + Math.random()*0.6,
        phase: Math.random()*Math.PI*2,
        color: ['#8affff','#9d9dff','#ff92ff','#ffe3a2'][Math.floor(Math.random()*4)]
      }));
      nebulae = Array.from({length:3}, (_,i) => ({
        xRatio: 0.2 + 0.3*i + Math.random()*0.15,
        yRatio: 0.1 + Math.random()*0.2,
        radiusRatio: 0.18 + Math.random()*0.12,
        inner: ['#1d8bff','#8c2fff','#1fff9e'][Math.floor(Math.random()*3)]
      }));
      auroraBands = Array.from({length:2}, () => ({
        amplitudeRatio: 0.05 + Math.random()*0.07,
        offsetRatio: 0.2 + Math.random()*0.1,
        speed: 0.002 + Math.random()*0.003,
        phase: Math.random()*Math.PI*2,
        color: ['#20ffd5','#9b4dff','#58ff83'][Math.floor(Math.random()*3)]
      }));
      ensureBuildings();
      if (infoElement) {
        infoElement.textContent = 'Distance: 0 | Score: 0';
      }
      if (restartButton) {
        restartButton.classList.remove('visible');
        restartButton.disabled = true;
        if (document.activeElement === restartButton) {
          restartButton.blur();
        }
      }
    }

    function spawnBuilding(worldZ){
      const cityWidth = 600;
      const palette = palettes[Math.floor(Math.random()*palettes.length)];
      if(Math.random() < 0.03){
        const width = cityWidth + 120;
        const depth = 60 + Math.random()*50;
        const deckHeight = 150 + Math.random()*35;
        const deckThickness = 12 + Math.random()*6;
        const clearanceHeight = 65 + Math.random()*25;
        const design = Math.floor(Math.random()*3);
        const bridge = {
          type: 'bridge',
          x: 0,
          width,
          depth,
          z: 0,
          worldZ,
          palette,
          deckHeight,
          deckThickness,
          clearanceHeight,
          design,
          supports: [],
          features: {}
        };

        const halfWidth = width / 2;
        const supportDepth = Math.min(depth * 0.75, 70);

        if(design === 0){
          const archHeight = deckHeight + 80 + Math.random()*30;
          bridge.features.archHeight = archHeight;
          bridge.features.archThickness = 16 + Math.random()*8;
          bridge.features.cableCount = 6 + Math.floor(Math.random()*4);
          bridge.supports.push(
            { xOffset: -halfWidth + 70, width: 70, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -15 },
            { xOffset: halfWidth - 70, width: 70, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -15 }
          );
          bridge.height = archHeight;
        } else if(design === 1){
          const towerHeight = deckHeight + 90 + Math.random()*40;
          const towerOffset = width * 0.22;
          const towerWidth = 60;
          bridge.features.towerHeight = towerHeight;
          bridge.features.cableSag = 40 + Math.random()*20;
          bridge.features.towerOffset = towerOffset;
          bridge.supports.push(
            { xOffset: -halfWidth + 55, width: 60, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -20 },
            { xOffset: halfWidth - 55, width: 60, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -20 },
            { xOffset: -towerOffset, width: towerWidth, depth: supportDepth * 0.9, bottom: 0, height: towerHeight, colorShift: -5 },
            { xOffset: towerOffset, width: towerWidth, depth: supportDepth * 0.9, bottom: 0, height: towerHeight, colorShift: -5 }
          );
          bridge.height = towerHeight;
        } else {
          const frameHeight = deckHeight + 60 + Math.random()*25;
          const frameCount = 4 + Math.floor(Math.random()*2);
          bridge.features.frameCount = frameCount;
          bridge.features.frameHeight = frameHeight;
          bridge.supports.push(
            { xOffset: -halfWidth + 50, width: 55, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -12 },
            { xOffset: halfWidth - 50, width: 55, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -12 },
            { xOffset: 0, width: 70, depth: supportDepth * 0.85, bottom: 0, height: deckHeight, colorShift: -18 }
          );
          bridge.height = frameHeight;
        }

        return bridge;
      } else {
        const x = (Math.random()-0.5) * cityWidth;
        const width = 40 + Math.random()*60;
        const depth = 40 + Math.random()*60;
        const coreHeight = 90 + Math.random()*160;
        let totalHeight = coreHeight;
        const windows = 3 + Math.floor(Math.random()*4);
        const windowCols = 2 + Math.floor(Math.random()*3);
        const accentPositions = [];
        if(Math.random() < 0.65){
          const accentCount = 1 + Math.floor(Math.random()*2);
          for(let i=0;i<accentCount;i++){
            accentPositions.push(0.2 + Math.random()*0.55);
          }
        }
        const segments = [];
        if(Math.random() < 0.45){
          const levels = 1 + Math.floor(Math.random()*3);
          let currentTop = coreHeight;
          for(let i=0;i<levels;i++){
            const segHeight = 20 + Math.random()*45;
            const segWidth = width * (0.6 - i*0.1);
            const segDepth = depth * (0.7 - i*0.1);
            const bottom = currentTop - 5;
            const top = bottom + segHeight;
            const segAccents = Math.random() < 0.5 ? [0.35 + Math.random()*0.4] : [];
            segments.push({width: segWidth, depth: segDepth, bottom, top, color: palette.accent, windows: Math.max(1, Math.floor(windows*0.6) - i), accents: segAccents});
            currentTop = top;
          }
          totalHeight = segments.length ? segments[segments.length-1].top : totalHeight;
        }
        let topper = null;
        if(Math.random() < 0.35){
          const topperHeight = 20 + Math.random()*35;
          topper = {height: topperHeight, color: palette.glow};
          totalHeight += topperHeight;
        }
        return {
          type:'building', x, width, depth, bottom:0, coreHeight,
          height: totalHeight, z: 0, worldZ, palette, windows, windowCols,
          segments, topper, accentPositions
        };
      }
    }

    function ensureBuildings(){
      while(nextBuildingZ < playerZ + BUILDING_VIEW_DISTANCE){
        const building = spawnBuilding(nextBuildingZ);
        const relativeZ = building.worldZ - playerZ;
        building.relativeZ = relativeZ;
        building.frontZ = relativeZ - building.depth/2;
        building.backZ = relativeZ + building.depth/2;
        building.z = PLANE_Z + relativeZ;
        buildings.push(building);
        nextBuildingZ += BUILDING_SPACING_MIN + Math.random()*BUILDING_SPACING_VARIANCE;
      }
    }

    function spawnRing(){
      const radius = 20;
      const worldZ = playerZ + RING_SPAWN_DISTANCE;
      const y = 60 + Math.random()*80;
      let x;
      let attempts;
      for(attempts = 0; attempts < 10; attempts++){
        x = (Math.random()-0.5) * 600;
        let overlap = false;
        for(const b of buildings){
          const halfDepth = b.depth/2;
          const zMin = b.worldZ - halfDepth - radius * 1.5;
          const zMax = b.worldZ + halfDepth + radius * 1.5;
          if(worldZ < zMin || worldZ > zMax){
            continue;
          }
          if(b.type === 'bridge'){
            const rel = x - b.x;
            if(Math.abs(rel) < b.width/2 + radius){
              const clearance = bridgeClearanceAt(b, rel);
              if(y > clearance - radius){
                overlap = true;
                break;
              }
            }
            for(const support of b.supports){
              const supportHalfDepth = (support.depth || b.depth)/2;
              const supportZMin = b.worldZ - supportHalfDepth - radius;
              const supportZMax = b.worldZ + supportHalfDepth + radius;
              if(worldZ < supportZMin || worldZ > supportZMax){
                continue;
              }
              const supportX = b.x + support.xOffset;
              const supportHalf = support.width/2 + radius;
              const supportHeight = support.collisionHeight || support.height;
              if(Math.abs(x - supportX) < supportHalf && y < supportHeight + radius){
                overlap = true;
                break;
              }
            }
            if(overlap) break;
          } else {
            const halfWidth = b.width/2 + radius;
            if(Math.abs(x - b.x) < halfWidth && y < b.height + radius){
              overlap = true;
              break;
            }
          }
        }
        if(!overlap) break;
      }
      if(attempts < 10){
        rings.push({x, y, worldZ, z: 0, radius, collected: false});
        return true;
      }
      return false;
    }

  function bridgeClearanceAt(bridge, rel){
    const halfWidth = bridge.width / 2;
    if(halfWidth <= 0) return 0;
    const ratio = Math.min(1, Math.abs(rel) / halfWidth);
    const deckBottom = bridge.deckHeight - bridge.deckThickness;
    let clearance = bridge.clearanceHeight * (1 - ratio * ratio);
    if(bridge.design === 1){
      clearance += Math.sin(ratio * Math.PI) * 6;
    } else if(bridge.design === 2){
      clearance -= Math.sin(ratio * Math.PI) * 6;
    } else {
      clearance += Math.cos(ratio * Math.PI) * 4;
    }
    return clamp(clearance, 0, deckBottom);
  }

  function getPlaneBounds(){
    return {
      xMin: plane.x - PLANE_HALF_WIDTH,
      xMax: plane.x + PLANE_HALF_WIDTH,
      yMin: plane.y - PLANE_HALF_HEIGHT,
      yMax: plane.y + PLANE_HALF_HEIGHT,
      zMin: playerZ - PLANE_HALF_DEPTH,
      zMax: playerZ + PLANE_HALF_DEPTH
    };
  }

  function boxesOverlap(a, b){
    return a.xMin < b.xMax && a.xMax > b.xMin &&
           a.yMin < b.yMax && a.yMax > b.yMin &&
           a.zMin < b.zMax && a.zMax > b.zMin;
  }

  function buildingCollisionBoxes(building){
    const boxes = [];
    const centerZ = building.worldZ;
    const halfDepth = building.depth / 2;
    boxes.push({
      xMin: building.x - building.width/2,
      xMax: building.x + building.width/2,
      yMin: building.bottom || 0,
      yMax: building.coreHeight,
      zMin: centerZ - halfDepth,
      zMax: centerZ + halfDepth
    });
    if(Array.isArray(building.segments)){
      for(const seg of building.segments){
        const segHalfDepth = seg.depth/2;
        boxes.push({
          xMin: building.x - seg.width/2,
          xMax: building.x + seg.width/2,
          yMin: seg.bottom,
          yMax: seg.top,
          zMin: centerZ - segHalfDepth,
          zMax: centerZ + segHalfDepth
        });
      }
    }
    if(building.topper){
      boxes.push({
        xMin: building.x - building.width/2,
        xMax: building.x + building.width/2,
        yMin: building.height - building.topper.height,
        yMax: building.height,
        zMin: centerZ - halfDepth,
        zMax: centerZ + halfDepth
      });
    }
    return boxes;
  }

  function checkBuildingCollision(building, planeBox){
    for(const box of buildingCollisionBoxes(building)){
      if(boxesOverlap(planeBox, box)){
        return true;
      }
    }
    return false;
  }

  function checkBridgeCollision(bridge, planeBox){
    const halfDepth = bridge.depth / 2;
    const zMin = bridge.worldZ - halfDepth;
    const zMax = bridge.worldZ + halfDepth;
    if(planeBox.zMax < zMin || planeBox.zMin > zMax){
      return false;
    }

    for(const support of bridge.supports){
      const supportHalfDepth = (support.depth || bridge.depth) / 2;
      const supportCenterZ = bridge.worldZ;
      const supportBox = {
        xMin: bridge.x + support.xOffset - support.width/2,
        xMax: bridge.x + support.xOffset + support.width/2,
        yMin: support.bottom ?? 0,
        yMax: support.collisionHeight || support.height,
        zMin: supportCenterZ - supportHalfDepth,
        zMax: supportCenterZ + supportHalfDepth
      };
      if(boxesOverlap(planeBox, supportBox)){
        return true;
      }
    }

    const planeCenterX = (planeBox.xMin + planeBox.xMax) / 2;
    const relativeX = planeCenterX - bridge.x;
    if(Math.abs(relativeX) <= bridge.width / 2){
      const clearance = bridgeClearanceAt(bridge, relativeX);
      if(planeBox.yMax > clearance){
        return true;
      }
    }

    return false;
  }

  function updateBuildings(){
    const planeBox = getPlaneBounds();
    let crashed = false;
    for(let i = buildings.length - 1; i >= 0; i--){
      const building = buildings[i];
      const relativeZ = building.worldZ - playerZ;
      building.relativeZ = relativeZ;
      building.frontZ = relativeZ - building.depth/2;
      building.backZ = relativeZ + building.depth/2;
      building.z = PLANE_Z + relativeZ;

      if(building.backZ < -BUILDING_DESPAWN_DISTANCE){
        buildings.splice(i, 1);
        continue;
      }

      if(!crashed && building.frontZ <= COLLISION_FRONT_THRESHOLD && building.backZ >= -PLANE_HALF_DEPTH){
        if(building.type === 'bridge'){
          if(checkBridgeCollision(building, planeBox)){
            crashed = true;
          }
        } else if(checkBuildingCollision(building, planeBox)){
          crashed = true;
        }
      }
    }
    return crashed;
  }

  function updateRings(){
    for(let i = rings.length - 1; i >= 0; i--){
      const ring = rings[i];
      const relativeZ = ring.worldZ - playerZ;
      ring.relativeZ = relativeZ;
      ring.z = PLANE_Z + relativeZ;

      if(relativeZ + ring.radius < -RING_DESPAWN_BUFFER){
        rings.splice(i, 1);
        continue;
      }

      if(!ring.collected &&
         Math.abs(ring.worldZ - playerZ) < ring.radius &&
         Math.abs(ring.x - plane.x) < ring.radius &&
         Math.abs(ring.y - plane.y) < ring.radius){
        ring.collected = true;
        score += 100;
      }
    }
  }

  function isKeyDown(...codes){
    return codes.some(code => keyState.has(code));
  }

  function readInputAxes(){
    const now = performance.now();
    const tiltFresh = isMobile && tiltState.active && now - tiltState.lastUpdate < 1000;
    let lateral = 0;
    let vertical = 0;
    let throttle = 0;
    if(tiltFresh){
      lateral = tiltState.lateral;
      vertical = tiltState.vertical;
    } else {
      if(isKeyDown('ArrowLeft', 'KeyA')) lateral -= 1;
      if(isKeyDown('ArrowRight', 'KeyD')) lateral += 1;
      if(isKeyDown('ArrowUp', 'KeyW')) vertical += 1;
      if(isKeyDown('ArrowDown', 'KeyS')) vertical -= 1;
      if(isKeyDown('ShiftLeft', 'ShiftRight', 'KeyQ')) throttle -= 1;
      if(isKeyDown('Space', 'KeyE')) throttle += 1;
    }
    return { lateral, vertical, throttle };
  }

  function updateControls(dt, active){
    const { lateral, vertical, throttle } = readInputAxes();
    const response = active ? 8 : 5;
    controlState.lateral = damp(controlState.lateral, active ? lateral : 0, response, dt);
    controlState.vertical = damp(controlState.vertical, active ? vertical : 0, response, dt);
    controlState.throttle = damp(controlState.throttle, active ? throttle : 0, 4.5, dt);

    const targetVx = controlState.lateral * plane.maxStrafeSpeed;
    const targetVy = controlState.vertical * plane.maxClimbSpeed;
    plane.vx = damp(plane.vx, targetVx, plane.steerResponsiveness, dt);
    plane.vy = damp(plane.vy, targetVy, plane.steerResponsiveness, dt);

    const rollTarget = -controlState.lateral * plane.maxRoll;
    plane.roll = damp(plane.roll, rollTarget, 5.5, dt);
    const speedDelta = clamp((plane.forwardSpeed - plane.cruiseSpeed) / plane.cruiseSpeed, -1, 1);
    const pitchTarget = controlState.vertical * plane.maxPitch - speedDelta * plane.maxPitch * 0.25;
    plane.pitch = damp(plane.pitch, pitchTarget, 4.2, dt);

    if(active){
      plane.forwardSpeed = clamp(
        plane.forwardSpeed + controlState.throttle * plane.throttleResponse * dt,
        plane.minSpeed,
        plane.maxSpeed
      );
      plane.x += plane.vx * dt;
      plane.y -= plane.vy * dt;
    } else {
      plane.forwardSpeed = damp(plane.forwardSpeed, 0, 2.2, dt);
      plane.vx = damp(plane.vx, 0, plane.steerResponsiveness, dt);
      plane.vy = damp(plane.vy, 0, plane.steerResponsiveness, dt);
    }

    plane.x = clamp(plane.x, -300, 300);
    plane.y = clamp(plane.y, 20, 170);
  }

    function update(dt){
      updateControls(dt, running);

      const starDrift = plane.forwardSpeed * dt * 0.28;
      for(const s of stars){
        s.y += starDrift * s.speed;
        s.phase += dt * 2.4;
        if(s.y > canvas.height){
          s.y = -s.size;
          s.x = Math.random()*canvas.width;
          s.speed = 0.4 + Math.random()*0.6;
        }
      }
      for(const band of auroraBands){
        band.phase += band.speed * plane.forwardSpeed * dt * 1.15;
      }

      if(!running){
        if (infoElement) {
          infoElement.textContent = `Distance: ${Math.floor(distance)} | Score: ${score}`;
        }
        if (isMobile && restartButton) {
          restartButton.disabled = false;
          restartButton.classList.add('visible');
        }
        return;
      }

      playerZ += plane.forwardSpeed * dt;
      distance = playerZ;

      const crashed = updateBuildings();
      ensureBuildings();

      if(crashed){
        running = false;
        if (messageElement) {
          messageElement.textContent = isMobile
            ? 'Crash! Tap Restart to fly again'
            : 'Crash! Press Space to restart';
        }
        if (infoElement) {
          infoElement.textContent = `Distance: ${Math.floor(distance)} | Score: ${score}`;
        }
        if (isMobile && restartButton) {
          restartButton.disabled = false;
          restartButton.classList.add('visible');
        }
        return;
      }

      updateRings();

      if(distance >= nextRing){
        if(spawnRing()) nextRing += 1000;
      }

      if (infoElement) {
        infoElement.textContent = `Distance: ${Math.floor(distance)} | Score: ${score}`;
      }
    }

    function project(x, y, z, options = {}){
      const { boostNear = true } = options;
      const relativeZ = z - plane.z;
      let depthForScale;
      if(boostNear){
        depthForScale = relativeZ - NEAR_FOCUS_DISTANCE;
        const minDepth = -FOV + MIN_PERSPECTIVE_CLAMP;
        if(depthForScale < minDepth){
          depthForScale = minDepth;
        }
      } else {
        depthForScale = Math.max(MIN_PERSPECTIVE_CLAMP, relativeZ);
      }
      const scale = FOV / (FOV + depthForScale);
      return {
        x: canvas.width/2 + (x - plane.x) * scale,
        y: canvas.height*0.7 - (y - plane.y) * scale,
        scale
      };
    }

    function drawBackground(){
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#040012');
      grad.addColorStop(0.3, '#0b0630');
      grad.addColorStop(0.65, '#001e2c');
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawNebulae(){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for(const n of nebulae){
        const x = n.xRatio * canvas.width;
        const y = n.yRatio * canvas.height;
        const radius = n.radiusRatio * canvas.width;
        const gradient = ctx.createRadialGradient(x, y, radius*0.2, x, y, radius);
        gradient.addColorStop(0, withAlpha(n.inner, 0.45));
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawAurora(){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.lineJoin = 'round';
      for(const band of auroraBands){
        const baseY = band.offsetRatio * canvas.height;
        const amplitude = band.amplitudeRatio * canvas.height;
        const gradient = ctx.createLinearGradient(0, baseY - 40, 0, baseY + 120);
        gradient.addColorStop(0, withAlpha(band.color, 0.35));
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, baseY + amplitude);
        const segments = 32;
        for(let i=0;i<=segments;i++){
          const t = i/segments;
          const x = t * canvas.width;
          const wave = Math.sin(band.phase + t * Math.PI * 4) * amplitude;
          ctx.lineTo(x, baseY + wave);
        }
        ctx.lineTo(canvas.width, baseY + amplitude*2);
        ctx.lineTo(0, baseY + amplitude*2);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    function drawStars(){
      ctx.save();
      for(const s of stars){
        const twinkle = 0.5 + 0.5 * Math.sin(s.phase);
        ctx.globalAlpha = 0.3 + twinkle*0.7;
        ctx.fillStyle = s.color;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }
      ctx.restore();
    }

    function drawDistantCity(){
      const horizonY = canvas.height * 0.72;
      ctx.save();
      ctx.fillStyle = 'rgba(12,32,58,0.55)';
      ctx.beginPath();
      ctx.moveTo(0, horizonY);
      const segments = 18;
      for(let i=0;i<=segments;i++){
        const t = i/segments;
        const x = t * canvas.width;
        const wave = Math.sin(distance*0.0004 + t*Math.PI*3) * 35;
        ctx.lineTo(x, horizonY - 70 - wave);
      }
      ctx.lineTo(canvas.width, horizonY);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'rgba(20,54,86,0.45)';
      ctx.beginPath();
      ctx.moveTo(0, horizonY + 4);
      for(let i=0;i<=segments;i++){
        const t = i/segments;
        const x = t * canvas.width;
        const wave = Math.sin(distance*0.00055 + 1.1 + t*Math.PI*4) * 28;
        ctx.lineTo(x, horizonY - 40 - wave);
      }
      ctx.lineTo(canvas.width, horizonY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawHorizonGlow(){
      const horizonY = canvas.height * 0.72;
      const glow = ctx.createLinearGradient(0, horizonY - 120, 0, horizonY + 120);
      glow.addColorStop(0, 'rgba(0,0,0,0)');
      glow.addColorStop(0.5, 'rgba(40,255,210,0.18)');
      glow.addColorStop(1, 'rgba(0,0,0,0.6)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, horizonY - 120, canvas.width, 240);
    }

    function drawGroundSurface(){
      const horizonY = canvas.height * 0.72;
      const ground = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
      ground.addColorStop(0, 'rgba(10, 40, 35, 0.7)');
      ground.addColorStop(0.45, 'rgba(6, 28, 32, 0.85)');
      ground.addColorStop(1, 'rgba(0, 12, 18, 0.95)');
      ctx.fillStyle = ground;
      ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);

      const bloom = ctx.createRadialGradient(
        canvas.width / 2,
        horizonY + canvas.height * 0.25,
        canvas.height * 0.05,
        canvas.width / 2,
        horizonY + canvas.height * 0.25,
        canvas.height * 0.45
      );
      bloom.addColorStop(0, 'rgba(30, 255, 210, 0.18)');
      bloom.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = bloom;
      ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);
    }

    function drawGroundGrid(){
      ctx.save();
      ctx.strokeStyle = 'rgba(100,255,190,0.25)';
      ctx.lineWidth = 1;
      for(let i=1;i<16;i++){
        const z = plane.z + i*120;
        const left = project(-450, 0, z, { boostNear: false });
        const right = project(450, 0, z, { boostNear: false });
        ctx.beginPath();
        ctx.moveTo(left.x, left.y);
        ctx.lineTo(right.x, right.y);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(100,255,190,0.18)';
      for(let i=-6;i<=6;i++){
        const x = i * 90;
        const near = project(x, 0, plane.z + 40, { boostNear: false });
        const far = project(x, 0, plane.z + 900, { boostNear: false });
        ctx.beginPath();
        ctx.moveTo(near.x, near.y);
        ctx.lineTo(far.x, far.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawPrism({x, width, depth, bottom, top, z, palette, windows=0, windowCols=0, baseColor, accentColor, accents=[]}){
      const w = width/2;
      const d = depth/2;
      let frontBottomLeft = project(x - w, bottom, z - d);
      let frontBottomRight = project(x + w, bottom, z - d);
      let backBottomLeft = project(x - w, bottom, z + d);
      let backBottomRight = project(x + w, bottom, z + d);
      let frontTopLeft = project(x - w, top, z - d);
      let frontTopRight = project(x + w, top, z - d);
      let backTopLeft = project(x - w, top, z + d);
      let backTopRight = project(x + w, top, z + d);

      const allPoints = [
        frontBottomLeft, frontBottomRight, backBottomLeft, backBottomRight,
        frontTopLeft, frontTopRight, backTopLeft, backTopRight
      ];
      if(allPoints.some(p => !Number.isFinite(p.x) || !Number.isFinite(p.y))){
        return;
      }

      if(frontBottomLeft.x > frontBottomRight.x){
        [frontBottomLeft, frontBottomRight] = [frontBottomRight, frontBottomLeft];
        [frontTopLeft, frontTopRight] = [frontTopRight, frontTopLeft];
      }
      if(backBottomLeft.x > backBottomRight.x){
        [backBottomLeft, backBottomRight] = [backBottomRight, backBottomLeft];
        [backTopLeft, backTopRight] = [backTopRight, backTopLeft];
      }

      const base = baseColor || palette.base;
      const accent = accentColor || palette.accent;
      const glow = palette.glow;
      const windowColor = palette.windows;

      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      const frontGradient = ctx.createLinearGradient(frontBottomLeft.x, frontBottomLeft.y, frontBottomRight.x, frontBottomRight.y);
      frontGradient.addColorStop(0, adjustColor(base, 35));
      frontGradient.addColorStop(1, adjustColor(base, -15));
      ctx.beginPath();
      ctx.moveTo(frontBottomLeft.x, frontBottomLeft.y);
      ctx.lineTo(frontBottomRight.x, frontBottomRight.y);
      ctx.lineTo(frontTopRight.x, frontTopRight.y);
      ctx.lineTo(frontTopLeft.x, frontTopLeft.y);
      ctx.closePath();
      ctx.fillStyle = frontGradient;
      ctx.fill();

      const sideGradient = ctx.createLinearGradient(frontBottomRight.x, frontBottomRight.y, backBottomRight.x, backBottomRight.y);
      sideGradient.addColorStop(0, adjustColor(base, -5));
      sideGradient.addColorStop(1, adjustColor(base, -45));
      ctx.beginPath();
      ctx.moveTo(frontBottomRight.x, frontBottomRight.y);
      ctx.lineTo(backBottomRight.x, backBottomRight.y);
      ctx.lineTo(backTopRight.x, backTopRight.y);
      ctx.lineTo(frontTopRight.x, frontTopRight.y);
      ctx.closePath();
      ctx.fillStyle = sideGradient;
      ctx.fill();

      const topGradient = ctx.createLinearGradient(frontTopLeft.x, frontTopLeft.y, backTopLeft.x, backTopLeft.y);
      topGradient.addColorStop(0, adjustColor(base, 60));
      topGradient.addColorStop(1, adjustColor(base, 10));
      ctx.beginPath();
      ctx.moveTo(frontTopLeft.x, frontTopLeft.y);
      ctx.lineTo(frontTopRight.x, frontTopRight.y);
      ctx.lineTo(backTopRight.x, backTopRight.y);
      ctx.lineTo(backTopLeft.x, backTopLeft.y);
      ctx.closePath();
      ctx.fillStyle = topGradient;
      ctx.fill();

      ctx.shadowColor = withAlpha(glow, 0.4);
      ctx.shadowBlur = 12;
      ctx.strokeStyle = withAlpha(glow, 0.9);
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      const edges = [
        [frontBottomLeft, frontBottomRight],
        [frontBottomLeft, backBottomLeft],
        [frontBottomRight, backBottomRight],
        [backBottomLeft, backBottomRight],
        [frontTopLeft, frontTopRight],
        [frontTopLeft, backTopLeft],
        [frontTopRight, backTopRight],
        [backTopLeft, backTopRight],
        [frontBottomLeft, frontTopLeft],
        [frontBottomRight, frontTopRight],
        [backBottomLeft, backTopLeft],
        [backBottomRight, backTopRight]
      ];
      for(const [a,b] of edges){
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      if(accents && accents.length){
        ctx.strokeStyle = withAlpha(accent, 0.75);
        ctx.lineWidth = 1.2;
        for(const pos of accents){
          const t = clamp(pos, 0.05, 0.95);
          const left = lerpPoint(frontBottomLeft, frontTopLeft, t);
          const right = lerpPoint(frontBottomRight, frontTopRight, t);
          ctx.beginPath();
          ctx.moveTo(left.x, left.y);
          ctx.lineTo(right.x, right.y);
          ctx.stroke();
        }
      }

      if(windows > 0){
        ctx.strokeStyle = withAlpha(windowColor, 0.6);
        ctx.lineWidth = 1;
        for(let i=1;i<=windows;i++){
          const t = i/(windows+1);
          const left = lerpPoint(frontBottomLeft, frontTopLeft, t);
          const right = lerpPoint(frontBottomRight, frontTopRight, t);
          ctx.beginPath();
          ctx.moveTo(left.x, left.y);
          ctx.lineTo(right.x, right.y);
          ctx.stroke();
        }
      }

      if(windowCols > 0){
        ctx.strokeStyle = withAlpha(windowColor, 0.35);
        ctx.lineWidth = 0.8;
        for(let i=1;i<=windowCols;i++){
          const t = i/(windowCols+1);
          const bottomPoint = lerpPoint(frontBottomLeft, frontBottomRight, t);
          const topPoint = lerpPoint(frontTopLeft, frontTopRight, t);
          ctx.beginPath();
          ctx.moveTo(bottomPoint.x, bottomPoint.y);
          ctx.lineTo(topPoint.x, topPoint.y);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawTopper(b){
      if(!b.topper) return;
      const basePoint = project(b.x, b.height - b.topper.height, b.z);
      const tipPoint = project(b.x, b.height, b.z);
      const glow = b.topper.color || b.palette.glow;
      ctx.save();
      ctx.strokeStyle = withAlpha(glow, 0.9);
      ctx.lineWidth = 2;
      ctx.shadowColor = withAlpha(glow, 0.7);
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.moveTo(basePoint.x, basePoint.y);
      ctx.lineTo(tipPoint.x, tipPoint.y);
      ctx.stroke();
      ctx.shadowBlur = 16;
      ctx.fillStyle = withAlpha(glow, 0.95);
      ctx.beginPath();
      ctx.arc(tipPoint.x, tipPoint.y, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawBuilding(b){
      if(b.type === 'bridge') return drawBridge(b);
      const bottom = b.bottom || 0;
      drawPrism({
        x: b.x,
        width: b.width,
        depth: b.depth,
        bottom,
        top: b.coreHeight,
        z: b.z,
        palette: b.palette,
        windows: b.windows,
        windowCols: b.windowCols,
        baseColor: b.palette.base,
        accentColor: b.palette.accent,
        accents: b.accentPositions
      });
      if(b.segments){
        for(const seg of b.segments){
          drawPrism({
            x: b.x,
            width: seg.width,
            depth: seg.depth,
            bottom: seg.bottom,
            top: seg.top,
            z: b.z,
            palette: b.palette,
            windows: seg.windows || 0,
            windowCols: Math.max(0, b.windowCols - 1),
            baseColor: seg.color,
            accentColor: seg.color,
            accents: seg.accents || []
          });
        }
      }
      drawTopper(b);
    }

    function drawBridgeSupport(bridge, support){
      const baseColor = adjustColor(bridge.palette.base, support.colorShift || 0);
      drawPrism({
        x: bridge.x + support.xOffset,
        width: support.width,
        depth: support.depth || Math.min(bridge.depth*0.9, 80),
        bottom: support.bottom ?? 0,
        top: support.height,
        z: bridge.z,
        palette: bridge.palette,
        windows: 0,
        windowCols: 0,
        baseColor,
        accentColor: adjustColor(bridge.palette.accent, 8)
      });
    }

    function drawBridgeDeck(bridge){
      const deckBottom = bridge.deckHeight - bridge.deckThickness;
      drawPrism({
        x: bridge.x,
        width: bridge.width,
        depth: bridge.depth,
        bottom: deckBottom,
        top: bridge.deckHeight,
        z: bridge.z,
        palette: bridge.palette,
        windows: 0,
        windowCols: 0,
        baseColor: adjustColor(bridge.palette.base, -35),
        accentColor: adjustColor(bridge.palette.accent, -5)
      });
    }

    function drawBridgeRails(bridge){
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const y = bridge.deckHeight + 6;
      const leftFront = project(bridge.x - w, y, bridge.z - d);
      const rightFront = project(bridge.x + w, y, bridge.z - d);
      const leftBack = project(bridge.x - w, y, bridge.z + d);
      const rightBack = project(bridge.x + w, y, bridge.z + d);
      ctx.save();
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.8);
      ctx.lineWidth = 2.2;
      ctx.shadowColor = withAlpha(bridge.palette.glow, 0.6);
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(leftFront.x, leftFront.y);
      ctx.lineTo(rightFront.x, rightFront.y);
      ctx.moveTo(leftBack.x, leftBack.y);
      ctx.lineTo(rightBack.x, rightBack.y);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawBridgeUnderside(bridge){
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const underside = bridge.deckHeight - bridge.deckThickness - 6;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.35);
      ctx.lineWidth = 1.6;
      for(const offset of [-0.35, 0, 0.35]){
        const x = bridge.x + w * offset;
        const front = project(x, underside, bridge.z - d);
        const back = project(x, underside, bridge.z + d);
        ctx.beginPath();
        ctx.moveTo(front.x, front.y);
        ctx.lineTo(back.x, back.y);
        ctx.stroke();
      }
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    }

    function drawArchBridgeDetails(bridge){
      const {archHeight, archThickness, cableCount} = bridge.features;
      if(!archHeight) return;
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const span = Math.max(10, archHeight - bridge.deckHeight);
      const segments = 28;
      ctx.save();
      ctx.shadowColor = withAlpha(bridge.palette.glow, 0.55);
      ctx.shadowBlur = 18;
      ctx.strokeStyle = withAlpha(bridge.palette.accent, 0.85);
      ctx.lineWidth = Math.max(3, archThickness/3);
      for(const depth of [-d, d]){
        ctx.beginPath();
        for(let i=0;i<=segments;i++){
          const t = -w + (2*w*i)/segments;
          const ratio = t / w;
          const y = bridge.deckHeight + span * (1 - ratio*ratio);
          const p = project(bridge.x + t, y, bridge.z + depth);
          if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      ctx.shadowBlur = 9;
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.75);
      ctx.lineWidth = 1.4;
      const cables = cableCount || 6;
      for(let i=1;i<=cables;i++){
        const t = i/(cables+1);
        const x = -w + bridge.width * t;
        const ratio = x / w;
        const y = bridge.deckHeight + span * (1 - ratio*ratio);
        for(const depth of [-d, d]){
          const top = project(bridge.x + x, y, bridge.z + depth);
          const bottom = project(bridge.x + x, bridge.deckHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(top.x, top.y);
          ctx.lineTo(bottom.x, bottom.y);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawSuspensionBridgeDetails(bridge){
      const {towerHeight, cableSag, towerOffset} = bridge.features;
      if(!towerHeight) return;
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const segments = 36;
      ctx.save();
      ctx.shadowColor = withAlpha(bridge.palette.glow, 0.5);
      ctx.shadowBlur = 16;
      ctx.strokeStyle = withAlpha(bridge.palette.accent, 0.85);
      ctx.lineWidth = 2.2;

      function cableHeight(t){
        const eased = Math.sin(Math.PI * t);
        return towerHeight - eased * (cableSag || 45);
      }

      for(const depth of [-d, d]){
        ctx.beginPath();
        for(let i=0;i<=segments;i++){
          const t = i/segments;
          const x = -w + 2*w*t;
          const y = cableHeight(t);
          const p = project(bridge.x + x, y, bridge.z + depth);
          if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      ctx.shadowBlur = 8;
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.7);
      ctx.lineWidth = 1.3;
      const hangerCount = 12;
      for(let i=1;i<hangerCount;i++){
        const t = i/hangerCount;
        const x = -w + 2*w*t;
        const y = cableHeight(t);
        for(const depth of [-d, d]){
          const top = project(bridge.x + x, y, bridge.z + depth);
          const bottom = project(bridge.x + x, bridge.deckHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(top.x, top.y);
          ctx.lineTo(bottom.x, bottom.y);
          ctx.stroke();
        }
      }

      if(towerOffset){
        ctx.shadowBlur = 14;
        ctx.lineWidth = 2.4;
        for(const depth of [-d, d]){
          const leftTop = project(bridge.x - towerOffset, towerHeight, bridge.z + depth);
          const rightTop = project(bridge.x + towerOffset, towerHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(leftTop.x, leftTop.y);
          ctx.lineTo(rightTop.x, rightTop.y);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawTrussBridgeDetails(bridge){
      const {frameCount, frameHeight} = bridge.features;
      if(!frameCount || !frameHeight) return;
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const step = bridge.width / (frameCount + 1);
      ctx.save();
      ctx.shadowColor = withAlpha(bridge.palette.accent, 0.55);
      ctx.shadowBlur = 12;
      ctx.strokeStyle = withAlpha(bridge.palette.accent, 0.85);
      ctx.lineWidth = 2;
      for(const depth of [-d, d]){
        for(let i=0;i<=frameCount+1;i++){
          const x = -w + step*i;
          const base = project(bridge.x + x, bridge.deckHeight, bridge.z + depth);
          const top = project(bridge.x + x, frameHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(base.x, base.y);
          ctx.lineTo(top.x, top.y);
          ctx.stroke();
        }
        ctx.lineWidth = 1.6;
        for(let i=0;i<frameCount+1;i++){
          const x1 = -w + step*i;
          const x2 = x1 + step;
          const base1 = project(bridge.x + x1, bridge.deckHeight, bridge.z + depth);
          const base2 = project(bridge.x + x2, bridge.deckHeight, bridge.z + depth);
          const apex = project(bridge.x + (x1 + x2)/2, frameHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(base1.x, base1.y);
          ctx.lineTo(apex.x, apex.y);
          ctx.lineTo(base2.x, base2.y);
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 6;
      ctx.lineWidth = 1.4;
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.75);
      for(const depth of [-d, d]){
        const topLeft = project(bridge.x - w, frameHeight, bridge.z + depth);
        const topRight = project(bridge.x + w, frameHeight, bridge.z + depth);
        ctx.beginPath();
        ctx.moveTo(topLeft.x, topLeft.y);
        ctx.lineTo(topRight.x, topRight.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawBridge(b){
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      const supports = [...b.supports].sort((a,b) => (a.height - b.height));
      for(const support of supports){
        drawBridgeSupport(b, support);
      }

      drawBridgeDeck(b);
      drawBridgeRails(b);
      drawBridgeUnderside(b);

      if(b.design === 0){
        drawArchBridgeDetails(b);
      } else if(b.design === 1){
        drawSuspensionBridgeDetails(b);
      } else {
        drawTrussBridgeDetails(b);
      }

      ctx.restore();
    }

  function drawRing(r){
    const center = project(r.x, r.y, r.z);
    const rad = r.radius * center.scale;
    ctx.save();
    const glow = ctx.createRadialGradient(center.x, center.y, rad*0.2, center.x, center.y, rad);
    glow.addColorStop(0, 'rgba(255,255,200,0.7)');
    glow.addColorStop(1, 'rgba(255,140,0,0)');
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(center.x, center.y, rad, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,130,0.95)';
    ctx.shadowColor = 'rgba(255,220,160,0.85)';
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(center.x, center.y, rad*0.8, 0, Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  function drawCrosshair(){
    const len = 14;
    const x = canvas.width/2;
    const y = canvas.height*0.7;
    ctx.save();
    ctx.translate(x, y + plane.pitch * 1.5);
    ctx.rotate(-(plane.roll || 0) * Math.PI / 180 * 0.35);
    ctx.strokeStyle = 'rgba(120,255,210,0.9)';
    ctx.lineWidth = 1.3;
    ctx.shadowColor = 'rgba(120,255,210,0.6)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.moveTo(-len, 0);
    ctx.lineTo(len, 0);
    ctx.moveTo(0, -len);
    ctx.lineTo(0, len);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

    function draw(){
      drawBackground();
      drawNebulae();
      drawAurora();
      drawStars();
      drawDistantCity();
      drawHorizonGlow();
      drawGroundSurface();
      drawGroundGrid();

      const visibleBuildings = buildings
        .filter(b => b.z + b.depth/2 >= plane.z)
        .sort((a,b) => b.z - a.z);
      for(const building of visibleBuildings){
        drawBuilding(building);
      }

      const visibleRings = rings
        .filter(r => r.z + r.radius >= plane.z && !r.collected)
        .sort((a,b) => b.z - a.z);
      for(const ring of visibleRings){
        drawRing(ring);
      }

      drawCrosshair();
    }

    let lastTimestamp = 0;
    function frame(timestamp){
      if(!lastTimestamp) lastTimestamp = timestamp;
      const dt = Math.min(0.05, (timestamp - lastTimestamp)/1000);
      lastTimestamp = timestamp;
      update(dt);
      draw();
      requestAnimationFrame(frame);
    }

    const CONTROL_KEYS = new Set([
      'ArrowLeft','ArrowRight','ArrowUp','ArrowDown',
      'KeyW','KeyA','KeyS','KeyD',
      'ShiftLeft','ShiftRight','KeyQ','KeyE','Space'
    ]);

    window.addEventListener('keydown', e => {
      keyState.add(e.code);
      if(CONTROL_KEYS.has(e.code)){
        e.preventDefault();
      }
      if(e.code === 'Space' && !running){
        resetGame();
        lastTimestamp = 0;
      }
    });
    window.addEventListener('keyup', e => {
      keyState.delete(e.code);
      if(CONTROL_KEYS.has(e.code)){
        e.preventDefault();
      }
    });

    window.addEventListener('blur', () => {
      keyState.clear();
      controlState.lateral = 0;
      controlState.vertical = 0;
      controlState.throttle = 0;
    });

    window.addEventListener('load', () => {
      if (isTouchDevice) {
        setViewportHeight();
      }
      handleLayoutChange();
      resetGame();
      lastTimestamp = 0;
      requestAnimationFrame(frame);
    });
  </script>
  <script>
    fetch('../sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>

