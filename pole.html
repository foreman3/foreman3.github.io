<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pole Position - Hyperdrive Edition</title>
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: radial-gradient(circle at 20% 20%, #1a2a6c 0%, #162447 35%, #0d1323 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #f8f9ff;
      overflow: hidden;
    }
    #sidebar {
      width: 240px;
      background: rgba(6, 10, 24, 0.9);
      backdrop-filter: blur(6px);
      padding: 24px 20px 32px;
      box-shadow: 6px 0 22px rgba(0,0,0,0.45);
    }
    #sidebar h2 {
      margin: 0 0 16px;
      font-size: 1.2rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #7dd3ff;
    }
    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #sidebar li {
      margin: 14px 0;
    }
    #sidebar a {
      color: #e8f1ff;
      text-decoration: none;
      font-size: 0.95rem;
      letter-spacing: 0.03em;
      transition: color 0.3s ease, transform 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    #sidebar a::before {
      content: '‚ûú';
      font-size: 0.8rem;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }
    #sidebar a:hover {
      color: #7dd3ff;
      transform: translateX(4px);
    }
    #sidebar a:hover::before {
      opacity: 1;
    }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 24px 28px 36px;
      position: relative;
      overflow: hidden;
    }
    h1 {
      margin: 0;
      font-size: 3.2rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      text-align: center;
      text-shadow: 0 0 16px rgba(125, 211, 255, 0.5), 0 12px 24px rgba(0,0,0,0.35);
    }
    h1 span {
      font-size: 1rem;
      display: block;
      margin-top: 6px;
      letter-spacing: 0.35em;
      color: #8cffa6;
    }
    canvas {
      background: #010101;
      border: 3px solid rgba(255,255,255,0.15);
      margin-top: 18px;
      border-radius: 18px;
      box-shadow: 0 24px 48px rgba(0,0,0,0.45), inset 0 0 25px rgba(125,211,255,0.15);
      width: min(92vw, 1024px);
      max-width: 1024px;
      aspect-ratio: 4 / 3;
    }
    #hud {
      margin-top: 16px;
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 16px;
      width: min(92vw, 1024px);
      max-width: 1024px;
    }
    .hud-card {
      background: linear-gradient(135deg, rgba(8,18,38,0.9), rgba(19,46,91,0.7));
      border: 1px solid rgba(125,211,255,0.2);
      border-radius: 14px;
      padding: 12px 16px;
      box-shadow: 0 16px 32px rgba(0,0,0,0.35);
      position: relative;
      overflow: hidden;
    }
    .hud-card::after {
      content: '';
      position: absolute;
      inset: -20% 35% auto auto;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(125,211,255,0.25) 0%, transparent 70%);
      opacity: 0.6;
      pointer-events: none;
    }
    .hud-label {
      font-size: 0.72rem;
      letter-spacing: 0.32em;
      text-transform: uppercase;
      opacity: 0.7;
    }
    .hud-value {
      font-size: 1.7rem;
      font-weight: 700;
      margin-top: 4px;
      letter-spacing: 0.05em;
      color: #fdfcff;
      text-shadow: 0 0 10px rgba(140, 255, 166, 0.35);
    }
    #message {
      margin-top: 18px;
      font-size: 1.4rem;
      letter-spacing: 0.08em;
      text-align: center;
      min-height: 1.4rem;
      text-shadow: 0 4px 12px rgba(0,0,0,0.55);
    }
    #controls {
      margin-top: 22px;
      text-align: center;
      font-size: 0.95rem;
      opacity: 0.8;
      letter-spacing: 0.04em;
    }
    #controls strong {
      color: #7dd3ff;
    }
    @media (max-width: 1100px) {
      body {
        flex-direction: column;
      }
      #sidebar {
        width: 100%;
        display: none;
      }
      #game-container {
        padding: 20px 16px 28px;
      }
      #hud {
        grid-template-columns: repeat(2, minmax(0,1fr));
      }
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Pole Position<span>Hyperdrive Edition</span></h1>
    <canvas id="gameCanvas" width="960" height="720"></canvas>
    <div id="hud">
      <div class="hud-card">
        <div class="hud-label">Score</div>
        <div class="hud-value" id="hud-score">0</div>
      </div>
      <div class="hud-card">
        <div class="hud-label">Speed</div>
        <div class="hud-value" id="hud-speed">0 km/h</div>
      </div>
      <div class="hud-card">
        <div class="hud-label">Lap</div>
        <div class="hud-value" id="hud-lap">1 / 3</div>
      </div>
      <div class="hud-card">
        <div class="hud-label">Time</div>
        <div class="hud-value" id="hud-time">75.0s</div>
      </div>
    </div>
    <div id="message">Press <strong>Enter</strong> to start your engines.</div>
    <div id="controls">
      <p><strong>Arrow Keys</strong> steer &amp; accelerate, <strong>X</strong> brakes, <strong>Z</strong> drift, <strong>Space</strong> nitro. Avoid rivals, chain near-misses for bonus points!</p>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const playerImg = new Image();
    playerImg.src = 'images/player_car.svg';
    const enemyImg = new Image();
    enemyImg.src = 'images/opponent_car.svg';

    let horizon = canvas.height * 0.38;
    const SEGMENT_LENGTH = 60;
    const TOTAL_SEGMENTS = 1200;
    const ROAD_BASE_WIDTH = 0.7;
    const DRAW_DISTANCE = 1400;

    const segments = [];
    const scenery = ['mushroom', 'boosterTree', 'cheerballoon', 'hoverSign'];
    for (let i = 0; i < TOTAL_SEGMENTS; i++) {
      const curve = Math.sin(i / 35) * 0.7 + Math.sin(i / 18) * 0.45;
      const hill = Math.sin(i / 45) * 0.45 + Math.sin(i / 120) * 0.2;
      const deco = (i % 17 === 0) ? scenery[i % scenery.length] : (i % 23 === 0 ? 'crowd' : null);
      const color = (i % 2 === 0) ? '#4a4f8f' : '#3b3f72';
      segments.push({ curve, hill, color, deco });
    }

    const lanes = [-0.34, -0.12, 0.12, 0.34];

    let score = 0;
    let timeLeft = 75;
    let running = false;
    let trackPos = 0;
    let carOffset = 0;
    let speed = 0;
    let combo = 0;
    let comboTimer = 0;
    let lap = 1;
    const totalLaps = 3;
    const enemies = [];
    const particles = [];
    const floaters = [];

    const maxSpeed = 18;
    const acceleration = 0.24;
    const brakeForce = 0.35;
    const drag = 0.06;
    const lateral = 0.018;
    const driftInfluence = 0.028;
    let nitro = 100;
    let nitroGlow = 0;

    let leftPressed = false;
    let rightPressed = false;
    let accelPressed = false;
    let brakePressed = false;
    let driftPressed = false;
    let nitroPressed = false;

    let lastTime = performance.now();
    let dayCycle = 0;
    let cameraShake = 0;

    function resizeGame(){
      const sidebar = document.getElementById('sidebar');
      const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
      const padding = window.innerWidth > 1100 ? 120 : 40;
      const availableWidth = window.innerWidth - sidebarWidth - padding;
      const availableHeight = window.innerHeight - 260;
      let width = Math.min(1024, availableWidth);
      let height = width * 3 / 4;
      if(height > availableHeight){
        height = availableHeight;
        width = height * 4 / 3;
      }
      canvas.width = width;
      canvas.height = height;
      horizon = canvas.height * 0.38;
    }

    function spawnEnemy(force){
      const dist = trackPos + 260 + Math.random() * 760;
      const laneIndex = Math.floor(Math.random() * lanes.length);
      const rivalSpeed = (maxSpeed * 0.55) + Math.random() * (maxSpeed * 0.6);
      enemies.push({
        z: dist,
        lane: laneIndex,
        laneOffset: 0,
        speed: rivalSpeed,
        wiggle: Math.random() * Math.PI * 2,
        angry: Math.random() < 0.18 || force
      });
    }

    function spawnParticle(){
      if(speed < maxSpeed * 0.65) return;
      const tailX = canvas.width / 2 + carOffset * canvas.width * ROAD_BASE_WIDTH * 0.5;
      const tailY = canvas.height - 80;
      for(let i = 0; i < 2; i++){
        particles.push({
          x: tailX + (Math.random() - 0.5) * 18,
          y: tailY + Math.random() * 12,
          vx: (Math.random() - 0.5) * 1.5,
          vy: -Math.random() * 3 - 2,
          life: 1,
          color: nitroPressed && nitro > 0 ? '#7effff' : '#ff784f'
        });
      }
    }

    function addFloater(text, multiplier){
      floaters.push({
        text,
        x: canvas.width / 2,
        y: canvas.height * 0.52,
        life: 1.4,
        multiplier
      });
    }

    function updateGame(dt){
      if(!running) return;

      const deltaDistance = speed * 60 * dt;
      trackPos += deltaDistance;

      if(trackPos >= TOTAL_SEGMENTS * SEGMENT_LENGTH){
        trackPos -= TOTAL_SEGMENTS * SEGMENT_LENGTH;
        lap += 1;
        if(lap > totalLaps){
          running = false;
          document.getElementById('message').innerHTML = 'üèÜ Championship victory! Press <strong>Enter</strong> to run another heat.';
          speed = 0;
        } else {
          timeLeft = Math.min(120, timeLeft + 20);
          addFloater(`Lap ${lap}!`, 0);
        }
      }

      score += (speed * (1 + combo * 0.25)) * dt * 80;

      if(accelPressed){
        speed = Math.min(maxSpeed, speed + acceleration * 60 * dt);
      } else {
        speed = Math.max(0, speed - drag * 60 * dt);
      }
      if(brakePressed){
        speed = Math.max(0, speed - brakeForce * 60 * dt);
      }
      if(nitroPressed && nitro > 0){
        const boost = 0.6 * 60 * dt;
        speed = Math.min(maxSpeed * 1.35, speed + boost);
        nitro = Math.max(0, nitro - 25 * dt);
        nitroGlow = 1;
      } else {
        nitro = Math.min(100, nitro + 12 * dt);
        nitroGlow = Math.max(0, nitroGlow - 0.9 * dt);
      }

      const steerStrength = (speed / (maxSpeed * 1.1));
      if(leftPressed){
        carOffset = Math.max(-0.92, carOffset - (lateral + (driftPressed ? driftInfluence : 0)) * steerStrength * 60 * dt);
      }
      if(rightPressed){
        carOffset = Math.min(0.92, carOffset + (lateral + (driftPressed ? driftInfluence : 0)) * steerStrength * 60 * dt);
      }
      if(!leftPressed && !rightPressed){
        carOffset *= 1 - 0.7 * dt;
      }

      timeLeft = Math.max(0, timeLeft - dt);
      if(timeLeft <= 0){
        running = false;
        document.getElementById('message').innerHTML = '‚è±Ô∏è Time expired! Press <strong>Enter</strong> to try again.';
      }

      if(combo > 0){
        comboTimer -= dt;
        if(comboTimer <= 0){
          combo = 0;
          document.getElementById('message').textContent = '';
        }
      }

      for(const enemy of enemies){
        enemy.z += enemy.speed * 60 * dt;
        enemy.wiggle += dt * (enemy.angry ? 8 : 4);
        const wiggleOffset = Math.sin(enemy.wiggle) * 0.05;
        if(enemy.angry){
          enemy.laneOffset += Math.sin(enemy.wiggle * 0.35) * 0.0025;
          enemy.laneOffset = Math.max(-0.6, Math.min(0.6, enemy.laneOffset));
        } else {
          enemy.laneOffset *= 0.95;
        }
        enemy.wiggleOffset = wiggleOffset;
      }

      for(let i = enemies.length - 1; i >= 0; i--){
        if(enemies[i].z < trackPos - 200 || enemies[i].z > trackPos + DRAW_DISTANCE + 600){
          enemies.splice(i, 1);
        }
      }
      while(enemies.length < 7){
        spawnEnemy();
      }

      for(const enemy of enemies){
        const rel = enemy.z - trackPos;
        const laneOffset = lanes[enemy.lane] + (enemy.laneOffset || 0) + (enemy.wiggleOffset || 0);
        if(rel < 90 && rel > -120){
          const difference = Math.abs(carOffset - laneOffset);
          if(rel > 0 && difference < 0.12 && rel < 60){
            if(enemy.nearMissed !== true){
              combo += 1;
              comboTimer = 2.2;
              const comboScore = 200 * combo;
              score += comboScore;
              addFloater(`Near miss x${combo}!`, combo);
              enemy.nearMissed = true;
              document.getElementById('message').textContent = `Combo x${combo}! Keep it going!`;
            }
          }
          if(rel < 50 && difference < 0.1){
            running = false;
            speed *= 0.3;
            cameraShake = 0.7;
            document.getElementById('message').innerHTML = 'üí• Massive crash! Press <strong>Enter</strong> to reset.';
          }
        }
      }

      spawnParticle();

      for(const p of particles){
        p.x += p.vx * 60 * dt;
        p.y += p.vy * 60 * dt;
        p.life -= dt * 0.9;
      }
      while(particles.length && particles[0].life <= 0){
        particles.shift();
      }

      for(const f of floaters){
        f.y -= dt * 28;
        f.life -= dt;
      }
      while(floaters.length && floaters[0].life <= 0){
        floaters.shift();
      }

      dayCycle += dt * (0.04 + speed / (maxSpeed * 50));
      if(cameraShake > 0){
        cameraShake = Math.max(0, cameraShake - dt * 1.8);
      }

      updateHud();
    }

    function updateHud(){
      document.getElementById('hud-score').textContent = Math.floor(score).toLocaleString();
      const kmh = Math.floor(speed * 12);
      document.getElementById('hud-speed').textContent = kmh + ' km/h';
      document.getElementById('hud-lap').textContent = `${Math.min(lap, totalLaps)} / ${totalLaps}`;
      document.getElementById('hud-time').textContent = timeLeft.toFixed(1) + 's';
    }

    function drawBackground(){
      const cycle = (Math.sin(dayCycle * 0.6) + 1) / 2;
      const glow = (Math.cos(dayCycle * 0.8) + 1) / 2;

      const skyGradient = ctx.createLinearGradient(0, 0, 0, horizon);
      skyGradient.addColorStop(0, `rgba(${Math.floor(90 + cycle * 40)}, ${Math.floor(170 + cycle * 60)}, ${Math.floor(255 - cycle * 20)}, 1)`);
      skyGradient.addColorStop(0.55, `rgba(${Math.floor(130 + cycle * 40)}, ${Math.floor(200 + cycle * 35)}, ${Math.floor(255 - cycle * 50)}, 1)`);
      skyGradient.addColorStop(1, `rgba(${Math.floor(160 + glow * 35)}, ${Math.floor(220 + glow * 20)}, ${Math.floor(255 - glow * 40)}, 1)`);
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, horizon);

      const sunX = canvas.width * (0.15 + cycle * 0.7);
      const sunY = horizon * (0.18 + (1 - cycle) * 0.25);
      const sunRadius = 70 + glow * 50;
      const sunGradient = ctx.createRadialGradient(sunX, sunY, 12, sunX, sunY, sunRadius);
      sunGradient.addColorStop(0, `rgba(255, ${220 + Math.floor(cycle * 20)}, ${140 + Math.floor(cycle * 60)}, 0.95)`);
      sunGradient.addColorStop(0.45, `rgba(255, ${200 + Math.floor(glow * 40)}, ${150 + Math.floor(glow * 50)}, 0.55)`);
      sunGradient.addColorStop(1, 'rgba(255, 200, 140, 0)');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(sunX, sunY, sunRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.save();
      ctx.globalAlpha = 0.45 + glow * 0.25;
      ctx.strokeStyle = `rgba(${Math.floor(255 - glow * 30)}, ${Math.floor(190 + glow * 40)}, ${Math.floor(255)}, 0.6)`;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(canvas.width * 0.5, horizon * 0.75, horizon * 0.6, Math.PI * 0.05, Math.PI - Math.PI * 0.05);
      ctx.stroke();
      ctx.restore();

      for(let i = 0; i < 4; i++){
        const offset = ((dayCycle * 0.05) + i * 0.23) % 1;
        const cloudX = offset * canvas.width;
        const cloudY = horizon * (0.08 + (i % 2) * 0.12);
        const width = 120 + Math.sin(dayCycle + i) * 40;
        ctx.save();
        ctx.translate(cloudX, cloudY);
        ctx.scale(1, 0.65);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.ellipse(0, 0, width, 60, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.75)';
        ctx.beginPath();
        ctx.ellipse(-width * 0.4, -18, width * 0.45, 50, 0, 0, Math.PI * 2);
        ctx.ellipse(width * 0.35, -12, width * 0.4, 46, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      const ridgeColor = `rgba(${Math.floor(100 + cycle * 20)}, ${Math.floor(120 + cycle * 20)}, ${Math.floor(220 + cycle * 30)}, 0.45)`;
      ctx.fillStyle = ridgeColor;
      for(let i = 0; i < 5; i++){
        const peakX = (i / 4) * canvas.width + Math.sin(dayCycle * 0.7 + i) * canvas.width * 0.12;
        const peakY = horizon * (0.45 + Math.sin(dayCycle * 0.6 + i) * 0.05);
        ctx.beginPath();
        ctx.moveTo(peakX - canvas.width * 0.25, horizon * 0.95);
        ctx.quadraticCurveTo(peakX, peakY, peakX + canvas.width * 0.25, horizon * 0.95);
        ctx.closePath();
        ctx.fill();
      }

      const groundGradient = ctx.createLinearGradient(0, horizon, 0, canvas.height);
      groundGradient.addColorStop(0, `rgba(${Math.floor(90 + glow * 20)}, ${Math.floor(200 + cycle * 25)}, ${Math.floor(140 + cycle * 20)}, 1)`);
      groundGradient.addColorStop(1, `rgba(${Math.floor(40 + glow * 20)}, ${Math.floor(160 + glow * 20)}, ${Math.floor(90 + glow * 30)}, 1)`);
      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, horizon, canvas.width, canvas.height - horizon);

      ctx.fillStyle = `rgba(${Math.floor(60 + glow * 20)}, ${Math.floor(190 + cycle * 25)}, ${Math.floor(110 + cycle * 25)}, 0.8)`;
      for(let i = -1; i < 6; i++){
        const hillX = (i / 5) * canvas.width + Math.sin(dayCycle + i) * canvas.width * 0.08;
        const hillWidth = canvas.width * 0.45;
        const hillHeight = horizon * 0.4;
        ctx.beginPath();
        ctx.moveTo(hillX - hillWidth / 2, canvas.height);
        ctx.quadraticCurveTo(hillX, horizon + hillHeight, hillX + hillWidth / 2, canvas.height);
        ctx.closePath();
        ctx.fill();
      }
    }

    function drawRoad(){
      const roadWidth = canvas.width * ROAD_BASE_WIDTH;
      let currentCurve = 0;
      let curveDelta = 0;

      for(let y = canvas.height; y > horizon; y -= 2){
        const depth = (canvas.height - y) / (canvas.height - horizon);
        const distance = depth * DRAW_DISTANCE;
        const index = Math.floor((trackPos + distance) / SEGMENT_LENGTH) % TOTAL_SEGMENTS;
        const segment = segments[index];

        const targetCurve = segment.curve * Math.pow(depth, 2);
        curveDelta = curveDelta * 0.86 + targetCurve * 0.14;
        currentCurve += curveDelta * 0.7;

        const elevation = segment.hill * Math.pow(depth, 1.6) * 180;
        const roadCenter = canvas.width / 2 + currentCurve + carOffset * depth * 40;
        const lineWidth = Math.max(6, roadWidth * (1 - depth * 0.85));
        const shoulder = lineWidth * 0.15;
        const laneMark = lineWidth * 0.02;

        const rumbleColor = depth % 0.04 < 0.02 ? '#ff4d6d' : '#fef3f8';
        ctx.fillStyle = rumbleColor;
        ctx.fillRect(roadCenter - lineWidth / 2 - shoulder, y + elevation, lineWidth + shoulder * 2, 2);

        ctx.fillStyle = segment.color;
        ctx.fillRect(roadCenter - lineWidth / 2, y + elevation, lineWidth, 2);

        ctx.fillStyle = 'rgba(255, 205, 72, 0.92)';
        ctx.fillRect(roadCenter - lineWidth / 2 + laneMark, y + elevation, laneMark, 2);
        ctx.fillRect(roadCenter + lineWidth / 2 - laneMark * 2, y + elevation, laneMark, 2);

        if(Math.floor((trackPos / 12 + depth * 120)) % 2 === 0){
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.fillRect(roadCenter - laneMark / 2, y + elevation, laneMark, 2);
        }

        const segProgress = (trackPos + distance) % (SEGMENT_LENGTH * 2);
        if(segment.deco && depth > 0.02 && depth < 0.98 && segProgress < 1.4){
          drawDecoration(segment.deco, roadCenter, lineWidth, y + elevation, depth, -1);
          drawDecoration(segment.deco, roadCenter, lineWidth, y + elevation, depth, 1);
        }
      }
    }

    function drawDecoration(type, roadCenter, lineWidth, y, depth, side){
      const scale = (1 - depth) * 1.9;
      const offsetMultiplier = side;
      const baseOffset = type === 'crowd' ? lineWidth * 0.95 : (type === 'cheerballoon' ? lineWidth * 0.7 : lineWidth * 0.82);
      const vertical = type === 'cheerballoon' ? 120 : 70;
      const baseY = y - (vertical * (1 - depth));

      ctx.save();
      ctx.translate(roadCenter + offsetMultiplier * (lineWidth / 2 + baseOffset), baseY);
      ctx.scale(scale * (side < 0 ? -1 : 1), scale);

      switch(type){
        case 'mushroom':
          ctx.fillStyle = '#ffe8c6';
          ctx.fillRect(-6, 0, 12, 36);
          ctx.fillStyle = '#ff5fa6';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.bezierCurveTo(34, -12, 34, -44, 0, -48);
          ctx.bezierCurveTo(-34, -44, -34, -12, 0, -10);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.85)';
          for(let i=0;i<4;i++){
            const angle = (Math.PI * 2 / 4) * i;
            const spotX = Math.cos(angle) * 10;
            const spotY = -30 + Math.sin(angle) * 8;
            ctx.beginPath();
            ctx.ellipse(spotX, spotY, 6, 8, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          break;
        case 'boosterTree':
          ctx.fillStyle = '#8b5930';
          ctx.fillRect(-5, 0, 10, 48);
          const foliage = ['#5ef0a5', '#2ad8a1', '#0dc2a0'];
          for(let i=0; i<foliage.length; i++){
            ctx.fillStyle = foliage[i];
            ctx.beginPath();
            ctx.ellipse(0, -20 - i * 16, 26 - i * 6, 18, 0, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          ctx.beginPath();
          ctx.ellipse(6, -36, 10, 8, 0, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'cheerballoon':
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(0, 10);
          ctx.quadraticCurveTo(6, 36, 0, 60);
          ctx.stroke();
          ctx.fillStyle = '#ff85ff';
          ctx.beginPath();
          ctx.ellipse(0, -20, 26, 32, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#ffd966';
          ctx.beginPath();
          ctx.moveTo(0, -48);
          ctx.quadraticCurveTo(10, -58, 0, -62);
          ctx.quadraticCurveTo(-10, -58, 0, -48);
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.5)';
          ctx.beginPath();
          ctx.ellipse(-8, -26, 8, 12, -0.2, 0, Math.PI * 2);
          ctx.fill();
          break;
        case 'hoverSign':
          ctx.fillStyle = '#2b3280';
          ctx.fillRect(-8, 0, 16, 48);
          ctx.fillStyle = '#5961ff';
          ctx.fillRect(-32, -48, 64, 38);
          ctx.fillStyle = '#ffe66d';
          ctx.beginPath();
          ctx.moveTo(-10, -29);
          ctx.lineTo(0, -42);
          ctx.lineTo(10, -29);
          ctx.lineTo(0, -16);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.fillRect(-32, -10, 64, 6);
          break;
        case 'crowd':
          ctx.fillStyle = 'rgba(40, 60, 140, 0.85)';
          ctx.fillRect(-40, -14, 80, 14);
          const colors = ['#ffe066', '#ff6b6b', '#7bedff', '#b47bff'];
          for(let i=0;i<6;i++){
            ctx.fillStyle = colors[i % colors.length];
            ctx.beginPath();
            ctx.arc(-30 + i * 12, -14, 6, 0, Math.PI);
            ctx.fill();
          }
          break;
      }

      ctx.restore();
    }

    function drawEnemies(){
      const roadWidth = canvas.width * ROAD_BASE_WIDTH;
      for(const enemy of enemies){
        const rel = enemy.z - trackPos;
        if(rel < 0 || rel > DRAW_DISTANCE) continue;
        const depth = 1 - rel / DRAW_DISTANCE;
        const lineWidth = roadWidth * (1 - (1 - depth) * 0.9);
        const curveIndex = Math.floor((trackPos + rel) / SEGMENT_LENGTH) % TOTAL_SEGMENTS;
        const seg = segments[curveIndex];
        const curve = seg.curve * Math.pow(1 - depth, 2) * 120;
        const laneOffset = lanes[enemy.lane] + (enemy.laneOffset || 0) + (enemy.wiggleOffset || 0);
        const x = canvas.width / 2 + curve + laneOffset * lineWidth;
        const y = horizon + (1 - depth) * (canvas.height - horizon) - 120 * depth;
        const size = Math.max(0.35, depth);
        const carWidth = 70 * size;
        const carHeight = 120 * size;
        ctx.globalAlpha = 0.92;
        ctx.drawImage(enemyImg, x - carWidth / 2, y - carHeight, carWidth, carHeight);
        ctx.globalAlpha = 1;
      }
    }

    function drawPlayer(){
      const carWidth = 96;
      const carHeight = 156;
      const wobble = Math.sin(performance.now() / 120) * Math.min(12, speed * 0.8);
      const nitroShift = nitroGlow * 14;
      const x = canvas.width / 2 + carOffset * canvas.width * ROAD_BASE_WIDTH * 0.5 + wobble;
      const y = canvas.height - carHeight + 20 + (nitroGlow * -12);

      if(nitroGlow > 0.01){
        const gradient = ctx.createLinearGradient(x, y - carHeight, x, y);
        gradient.addColorStop(0, 'rgba(126,255,255,0.0)');
        gradient.addColorStop(1, 'rgba(126,255,255,0.45)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(x - 26, y - carHeight - 20);
        ctx.lineTo(x + 26, y - carHeight - 20);
        ctx.lineTo(x, y + 10);
        ctx.closePath();
        ctx.fill();
      }

      ctx.drawImage(playerImg, x - carWidth / 2, y - carHeight, carWidth, carHeight);
    }

    function drawParticles(){
      for(const p of particles){
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, 6, 12, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }

    function drawFloaters(){
      for(const f of floaters){
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, f.life));
        ctx.translate(f.x, f.y);
        ctx.scale(1 + f.multiplier * 0.05, 1 + f.multiplier * 0.05);
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 28px "Segoe UI"';
        ctx.textAlign = 'center';
        ctx.fillText(f.text, 0, 0);
        ctx.restore();
      }
    }

    function drawNitroMeter(){
      const width = Math.min(canvas.width * 0.35, 320);
      const height = 14;
      const x = canvas.width / 2 - width / 2;
      const y = canvas.height - 32;
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fillRect(x, y, width, height);
      const gradient = ctx.createLinearGradient(x, y, x + width, y);
      gradient.addColorStop(0, '#38f9d7');
      gradient.addColorStop(0.5, '#43e97b');
      gradient.addColorStop(1, '#ff9a9e');
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, width * (nitro / 100), height);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, width, height);
      ctx.font = 'bold 12px "Segoe UI"';
      ctx.fillStyle = 'rgba(255,255,255,0.7)';
      ctx.textAlign = 'center';
      ctx.fillText('Nitro', canvas.width / 2, y - 6);
    }

    function render(){
      ctx.save();
      if(cameraShake > 0){
        const shakeX = (Math.random() - 0.5) * 18 * cameraShake;
        const shakeY = (Math.random() - 0.5) * 12 * cameraShake;
        ctx.translate(shakeX, shakeY);
      }
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawRoad();
      drawEnemies();
      drawParticles();
      drawPlayer();
      drawFloaters();
      drawNitroMeter();
      ctx.restore();
    }

    function loop(time){
      const dt = Math.min(0.05, (time - lastTime) / 1000);
      lastTime = time;
      updateGame(dt);
      render();
      requestAnimationFrame(loop);
    }

    document.addEventListener('keydown', e => {
      if(e.repeat) return;
      if(e.code === 'ArrowLeft') leftPressed = true;
      if(e.code === 'ArrowRight') rightPressed = true;
      if(e.code === 'ArrowUp') accelPressed = true;
      if(e.code === 'KeyX') brakePressed = true;
      if(e.code === 'KeyZ') driftPressed = true;
      if(e.code === 'Space') nitroPressed = true;
      if(e.code === 'Enter' && !running){
        startGame();
      }
    });

    document.addEventListener('keyup', e => {
      if(e.code === 'ArrowLeft') leftPressed = false;
      if(e.code === 'ArrowRight') rightPressed = false;
      if(e.code === 'ArrowUp') accelPressed = false;
      if(e.code === 'KeyX') brakePressed = false;
      if(e.code === 'KeyZ') driftPressed = false;
      if(e.code === 'Space') nitroPressed = false;
    });

    function startGame(){
      score = 0;
      timeLeft = 75;
      running = true;
      trackPos = 0;
      carOffset = 0;
      speed = 0;
      combo = 0;
      comboTimer = 0;
      lap = 1;
      nitro = 100;
      nitroGlow = 0;
      dayCycle = 0;
      cameraShake = 0;
      enemies.length = 0;
      particles.length = 0;
      floaters.length = 0;
      document.getElementById('message').textContent = '';
      for(let i=0;i<6;i++){
        spawnEnemy(true);
      }
      updateHud();
    }

    window.addEventListener('load', () => {
      resizeGame();
      updateHud();
      loop(performance.now());
    });

    window.addEventListener('resize', resizeGame);
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
        resizeGame();
      });
  </script>
</body>
</html>
