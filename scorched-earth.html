<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Scorched Skies</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      margin: 0;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle at top, #1e2a3a 0%, #10141c 45%, #050608 100%);
      color: #f1f7ff;
      min-height: 100vh;
      display: flex;
    }
    #sidebar-placeholder,
    #sidebar {
      width: 240px;
      flex-shrink: 0;
      background: rgba(6, 9, 20, 0.85);
      padding: 24px 20px;
      box-shadow: 0 0 25px rgba(12, 20, 56, 0.7);
      backdrop-filter: blur(6px);
      border-right: 1px solid rgba(255, 255, 255, 0.08);
    }

    #sidebar img {
      display: block;
      width: 160px;
      margin: 0 auto 24px;
    }

    #sidebar h3 {
      margin: 0 0 14px;
      font-size: 0.85rem;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: rgba(216, 226, 255, 0.75);
    }

    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0 0 28px;
    }

    #sidebar li {
      margin: 15px 0;
    }

    #sidebar a {
      color: #dce3ff;
      text-decoration: none;
      letter-spacing: 0.5px;
      font-weight: 600;
      transition: color 0.3s, text-shadow 0.3s;
    }

    #sidebar a:hover {
      color: #fffb96;
      text-shadow: 0 0 8px rgba(255, 251, 150, 0.9);
    }
    #game-shell {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 18px;
      box-sizing: border-box;
      gap: 14px;
    }
    h1 {
      margin: 0;
      font-size: 2.2rem;
      text-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #hud {
      width: 100%;
      max-width: 1280px;
      background: rgba(17, 27, 39, 0.75);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 12px 18px;
      box-shadow: 0 12px 24px rgba(0,0,0,0.25);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #hud-top {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.95rem;
      letter-spacing: 0.02em;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }
    label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.95rem;
    }
    select, input[type="range"], button {
      font: inherit;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(15,25,35,0.9);
      color: #f5faff;
      padding: 6px 10px;
    }
    input[type="range"] {
      accent-color: #5ad6ff;
      width: 150px;
    }
    button {
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
      box-shadow: none;
      transform: none;
    }
    button:not(:disabled):hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 16px rgba(90, 214, 255, 0.25);
    }
    #skipFightBtn {
      display: none;
      background: rgba(255, 120, 120, 0.18);
      border-color: rgba(255, 120, 120, 0.4);
    }
    #gameCanvas {
      width: 100%;
      max-width: 1280px;
      height: auto;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,0.08);
      background: linear-gradient(#0b1523, #090b0f 65%, #1c120c 100%);
      box-shadow: 0 18px 38px rgba(0,0,0,0.5);
    }
    #status {
      width: 100%;
      max-width: 1280px;
      font-size: 1rem;
      min-height: 28px;
    }
    #inventory {
      width: 100%;
      max-width: 1280px;
      background: rgba(15, 22, 32, 0.7);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 10px;
      padding: 12px 16px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px 16px;
      font-size: 0.9rem;
    }
    #inventory span {
      background: rgba(255,255,255,0.04);
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.05);
    }
    #setupOverlay,
    #shopOverlay {
      position: fixed;
      inset: 0;
      background: rgba(3, 8, 15, 0.88);
      backdrop-filter: blur(6px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    #setupOverlay.active,
    #shopOverlay.active {
      display: flex;
    }
    #setupPanel {
      width: min(520px, 90vw);
      background: linear-gradient(160deg, rgba(19,34,46,0.96), rgba(10,16,24,0.92));
      border-radius: 16px;
      border: 1px solid rgba(90,214,255,0.28);
      box-shadow: 0 24px 48px rgba(0,0,0,0.45);
      padding: 26px 30px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    #setupPanel h2 {
      margin: 0;
      font-size: 1.6rem;
      color: #8fe6ff;
    }
    #setupIntro {
      margin: 0;
      line-height: 1.45;
      color: rgba(235,245,255,0.82);
      font-size: 0.95rem;
    }
    #setupControls {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .setup-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
    }
    #opponentSelectors {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .opponent-row {
      display: grid;
      grid-template-columns: auto 1fr;
      gap: 8px 12px;
      align-items: center;
      background: rgba(6,12,18,0.65);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px 12px;
    }
    .opponent-row span {
      font-weight: 600;
      letter-spacing: 0.02em;
      color: rgba(214,238,255,0.88);
    }
    .opponent-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .opponent-controls input[type="text"] {
      min-width: 140px;
    }
    .skill-select {
      display: none;
    }
    .skill-select.active {
      display: block;
    }
    .opponent-tag {
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(90,214,255,0.18);
      border: 1px solid rgba(90,214,255,0.25);
      font-size: 0.85rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    #startGameBtn,
    #weaponsTestBtn {
      padding: 10px 20px;
      font-weight: 600;
      letter-spacing: 0.02em;
      text-transform: uppercase;
    }
    #startGameBtn {
      background: linear-gradient(135deg, rgba(90,214,255,0.3), rgba(10,94,135,0.85));
      border-color: rgba(90,214,255,0.5);
    }
    #startGameBtn:hover {
      box-shadow: 0 12px 28px rgba(90,214,255,0.35);
    }
    #weaponsTestBtn {
      background: linear-gradient(135deg, rgba(255,168,120,0.24), rgba(190,82,34,0.82));
      border-color: rgba(255,168,120,0.55);
    }
    #weaponsTestBtn:hover {
      box-shadow: 0 12px 28px rgba(255,168,120,0.38);
    }
    #shopPanel {
      width: min(720px, 90vw);
      max-height: 85vh;
      overflow: auto;
      background: linear-gradient(160deg, rgba(19,34,46,0.96), rgba(10,16,24,0.92));
      border-radius: 16px;
      border: 1px solid rgba(90,214,255,0.3);
      box-shadow: 0 24px 48px rgba(0,0,0,0.45);
      padding: 22px 28px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    #shopHeader {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      flex-wrap: wrap;
      gap: 12px;
    }
    #shopItems {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 16px;
    }
    .shop-card {
      background: rgba(6,12,18,0.75);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 12px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .shop-card h3 {
      margin: 0;
      font-size: 1.05rem;
      color: #88e5ff;
    }
    .shop-card p {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(225,235,255,0.82);
      line-height: 1.3;
    }
    .shop-card button {
      align-self: flex-start;
    }
    #shopFooter {
      display: flex;
      justify-content: flex-end;
      gap: 12px;
    }
    @media (max-width: 1024px) {
      body { flex-direction: column; }
      #sidebar-placeholder,
      #sidebar { width: 100%; border-right: none; box-shadow: none; }
    }
  </style>
</head>
<body>
  <div id="setupOverlay" class="active">
    <div id="setupPanel">
      <h2>Mission Briefing</h2>
      <p id="setupIntro">Choose how many rival commanders join the sortie and calibrate their tactical aptitude. Higher skills mean ruthless accuracy and smarter targeting.</p>
      <div id="setupControls">
        <div class="opponent-row" id="commanderConfig">
          <span>Player 1</span>
          <div class="opponent-controls">
            <input type="text" id="commanderName" value="Commander" aria-label="Player 1 name">
            <div class="opponent-tag">Human</div>
          </div>
        </div>
        <label>Additional Combatants
          <select id="opponentCount">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
          </select>
        </label>
        <div id="opponentSelectors"></div>
        <div class="setup-actions">
          <button id="startGameBtn">Deploy Forces</button>
          <button id="weaponsTestBtn">Weapons Test</button>
        </div>
      </div>
    </div>
  </div>
  <div id="sidebar-placeholder"></div>
  <div id="game-shell">
    <h1>Scorched Skies</h1>
    <div id="hud">
      <div id="hud-top">
        <div>Round: <span id="roundDisplay">1</span></div>
        <div>Wind: <span id="windDisplay">Calm</span></div>
        <div>Credits: $<span id="moneyDisplay">0</span></div>
        <div>Current Turn: <span id="turnDisplay">Commander</span></div>
      </div>
      <div id="controls">
        <label>Weapon
          <select id="weaponSelect"></select>
        </label>
        <label>Angle
          <input type="range" id="angleSlider" min="0" max="180" value="60">
          <span id="angleValue">60°</span>
        </label>
        <label>Power
          <input type="range" id="powerSlider" min="10" max="120" value="65">
          <span id="powerValue">65</span>
        </label>
        <button id="fireBtn">Fire!</button>
        <button id="shopBtn">Field Depot</button>
        <button id="skipFightBtn">End Fight</button>
      </div>
    </div>
    <canvas id="gameCanvas" width="1280" height="640"></canvas>
    <div id="status"></div>
    <div id="inventory"></div>
  </div>
  <div id="shopOverlay">
    <div id="shopPanel">
      <div id="shopHeader">
        <h2>Battlefield Depot</h2>
        <div>Your Credits: $<span id="shopMoney">0</span></div>
      </div>
      <div id="shopItems"></div>
      <div id="shopFooter">
        <button id="closeShopBtn">Cancel</button>
        <button id="nextRoundBtn">Deploy Next Round</button>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const GRAVITY = 0.18;
    const SPEED_SCALE = 0.5;
    const POWER_ATTENUATION = 0.7;
    const WIND_EFFECT = 0.04;
    const tankWidth = 34;
    const tankHeight = 20;

    const weaponCatalog = {
      'Baby Missile': { type: 'explosive', radius: 24, damage: 32, cost: 0 },
      'Heavy Missile': { type: 'explosive', radius: 34, damage: 45, cost: 0 },
      'Mega Nuke': { type: 'explosive', radius: 52, damage: 72, cost: 0 },
      'MIRV': { type: 'mirv', radius: 26, damage: 28, cost: 0 },
      'Mini MIRV': { type: 'explosive', radius: 20, damage: 24, cost: 0 },
      'Napalm': { type: 'napalm', radius: 32, damage: 26, cost: 0 },
      'Dirt Bomb': { type: 'dirt', radius: 44, damage: 0, cost: 0 },
      'Tracer Round': { type: 'explosive', radius: 18, damage: 12, cost: 0, tracer: true }
    };

    const utilities = {
      'Shield Pulse': {
        description: 'Deploy a deflector shield that absorbs 40% damage for the next few hits.',
        action: (tank) => {
          if (tank.inventory['Shield Pulse'] <= 0) {
            setStatus(`${tank.name} is out of shield charges.`);
            return false;
          }
          tank.inventory['Shield Pulse']--;
          tank.activeShield = Math.min(0.6, tank.activeShield + 0.4);
          setStatus(`${tank.name} reinforces defenses.`);
          return true;
        }
      },
      'Repair Kit': {
        description: 'Restore 35 armor points mid-battle.',
        action: (tank) => {
          if (tank.inventory['Repair Kit'] <= 0) {
            setStatus(`${tank.name} is out of repair kits.`);
            return false;
          }
          tank.inventory['Repair Kit']--;
          tank.health = Math.min(tank.maxHealth, tank.health + 35);
          createParticles(tank.x, tank.y - tankHeight / 2, '#8cf7ff', 16);
          setStatus(`${tank.name} patches up for ${35} armor.`);
          return true;
        }
      }
    };

    const storeItems = [
      {
        id: 'baby',
        title: 'Baby Missiles (x5)',
        cost: 60,
        blurb: 'Reliable micro-warheads for dialing in your shots.',
        apply: (tank) => addWeapon(tank, 'Baby Missile', 5)
      },
      {
        id: 'heavy',
        title: 'Heavy Missiles (x3)',
        cost: 95,
        blurb: 'Bigger craters, bigger paydays. Ideal for exposed targets.',
        apply: (tank) => addWeapon(tank, 'Heavy Missile', 3)
      },
      {
        id: 'mega',
        title: 'Mega Nuke (x1)',
        cost: 150,
        blurb: 'Multi-kiloton devastation. Clears entire cliff faces.',
        apply: (tank) => addWeapon(tank, 'Mega Nuke', 1)
      },
      {
        id: 'mirv',
        title: 'MIRV Pod (x1)',
        cost: 125,
        blurb: 'Splits into a cluster of submunitions mid-air.',
        apply: (tank) => addWeapon(tank, 'MIRV', 1)
      },
      {
        id: 'napalm',
        title: 'Napalm Flood (x2)',
        cost: 110,
        blurb: 'Ignites terrain, carving molten channels and damage over time.',
        apply: (tank) => addWeapon(tank, 'Napalm', 2)
      },
      {
        id: 'dirt',
        title: 'Dirt Shroud (x3)',
        cost: 75,
        blurb: 'Sandblast enemies or shore up craters with rich loam.',
        apply: (tank) => addWeapon(tank, 'Dirt Bomb', 3)
      },
      {
        id: 'tracer',
        title: 'Tracer Rounds (x3)',
        cost: 40,
        blurb: 'Leave luminous trails to dial your next volley.',
        apply: (tank) => addWeapon(tank, 'Tracer Round', 3)
      },
      {
        id: 'shield',
        title: 'Deflector Shield Charge',
        cost: 90,
        blurb: 'Absorb the sting of incoming fire. Stacks with existing shielding.',
        apply: (tank) => {
          tank.inventory['Shield Pulse'] = (tank.inventory['Shield Pulse'] || 0) + 1;
        }
      },
      {
        id: 'repair',
        title: 'Repair Kits (x2)',
        cost: 80,
        blurb: 'Mid-round maintenance for when the armor plating buckles.',
        apply: (tank) => {
          tank.inventory['Repair Kit'] = (tank.inventory['Repair Kit'] || 0) + 2;
        }
      },
      {
        id: 'plating',
        title: 'Reactive Plating Upgrade',
        cost: 140,
        blurb: 'Increase max armor by 15 for every round going forward.',
        apply: (tank) => {
          tank.maxHealth += 15;
          tank.health = Math.min(tank.maxHealth, tank.health + 15);
        }
      }
    ];

    const terrain = {
      heights: new Array(canvas.width).fill(canvas.height * 0.7)
    };

    let nextTankId = 0;

    function baseInventory() {
      return {
        'Baby Missile': 6,
        'Heavy Missile': 2,
        'Mega Nuke': 1,
        'MIRV': 1,
        'Napalm': 1,
        'Dirt Bomb': 1,
        'Tracer Round': 2,
        'Shield Pulse': 1,
        'Repair Kit': 1
      };
    }

    function grantWeaponsTestLoadout(tank) {
      Object.keys(weaponCatalog).forEach(name => {
        tank.inventory[name] = Infinity;
      });
      Object.keys(utilities).forEach(name => {
        tank.inventory[name] = Infinity;
      });
    }

    function createTank(name, color, options = {}) {
      const skill = options.skill ?? 3;
      return {
        id: nextTankId++,
        name,
        color,
        x: 0,
        y: 0,
        facing: 1,
        angle: 60,
        power: 65,
        health: 100,
        maxHealth: 100,
        money: 400,
        inventory: baseInventory(),
        activeShield: 0,
        alive: true,
        tracerCache: [],
        ai: !!options.ai,
        aiSkill: options.ai ? clamp(skill, 1, 5) : null,
        lockedTargetId: null,
        solutionMemory: {},
        lastTargetId: null,
        isPlayer: !options.ai,
        selectedWeapon: 'Baby Missile'
      };
    }

    const humanPalette = ['#61f7a7', '#73f5ff', '#f7f77c', '#ff9cf2'];
    const aiPalette = ['#ff7676', '#ffb878', '#94a2ff', '#ffa0d4'];

    let humanPlayers = [];
    let aiOpponents = [];
    let tanks = [];
    let roundNumber = 0;
    let wind = 0;
    let currentPlayerIndex = 0;
    let currentPlayer = null;
    let roundStarterIndex = 0;
    let gameState = 'setup';
    let activeHuman = null;
    let shopQueue = [];
    let currentShopCommander = null;
    let fastForwardActive = false;
    let lastFrameTime = null;
    let weaponsTestMode = false;

    const projectiles = [];
    const particles = [];
    const fireZones = [];
    const stars = Array.from({ length: 120 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height * 0.42,
      r: Math.random() * 1.5
    }));
    let lastTracer = null;

    const aiNames = ['Oracle', 'Tempest', 'Aegis', 'Viper', 'Specter', 'Nova', 'Fury', 'Glacier'];

    function setActiveHuman(tank) {
      activeHuman = tank || null;
      updateHUD();
      updateInventoryUI();
      updateWeaponSelect();
    }

    function updateFastForwardState() {
      const aliveHumans = humanPlayers.filter(h => h.alive);
      const activeCombatants = tanks.filter(t => t.alive);
      const shouldFastForward = (gameState === 'aim' || gameState === 'projectile') && aliveHumans.length === 0 && activeCombatants.length > 1;
      fastForwardActive = shouldFastForward;
      const skipBtn = document.getElementById('skipFightBtn');
      if (skipBtn) {
        if (!weaponsTestMode && shouldFastForward && gameState !== 'roundEnd') {
          skipBtn.style.display = 'inline-flex';
          skipBtn.disabled = false;
        } else {
          skipBtn.style.display = 'none';
        }
      }
    }

    function updateOpponentSelectors(count) {
      const container = document.getElementById('opponentSelectors');
      if (!container) return;
      container.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const row = document.createElement('div');
        row.className = 'opponent-row';
        row.dataset.index = i;
        const label = document.createElement('span');
        label.textContent = `Player ${i + 2}`;
        const controls = document.createElement('div');
        controls.className = 'opponent-controls';

        const typeSelect = document.createElement('select');
        typeSelect.dataset.role = 'type';
        const cpuOption = document.createElement('option');
        cpuOption.value = 'cpu';
        cpuOption.textContent = 'CPU';
        const humanOption = document.createElement('option');
        humanOption.value = 'human';
        humanOption.textContent = 'Human';
        typeSelect.appendChild(cpuOption);
        typeSelect.appendChild(humanOption);

        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.dataset.role = 'name';
        nameInput.placeholder = 'Callsign';

        const skillSelect = document.createElement('select');
        skillSelect.dataset.role = 'skill';
        skillSelect.className = 'skill-select';
        for (let s = 1; s <= 5; s++) {
          const option = document.createElement('option');
          option.value = s;
          option.textContent = `Skill ${s}`;
          if (s === Math.min(3, 1 + i)) {
            option.selected = true;
          }
          skillSelect.appendChild(option);
        }

        const defaultCpuName = aiNames[(i) % aiNames.length];
        const defaultHumanName = `Commander ${i + 2}`;
        nameInput.value = defaultCpuName;
        nameInput.dataset.defaultCpu = defaultCpuName;
        nameInput.dataset.defaultHuman = defaultHumanName;

        const handleTypeChange = () => {
          const type = typeSelect.value;
          if (type === 'cpu') {
            skillSelect.classList.add('active');
            if (!nameInput.dataset.touched || nameInput.value.trim() === '') {
              nameInput.value = nameInput.dataset.defaultCpu;
            }
          } else {
            skillSelect.classList.remove('active');
            if (!nameInput.dataset.touched || nameInput.value.trim() === '' || nameInput.value === nameInput.dataset.defaultCpu) {
              nameInput.value = nameInput.dataset.defaultHuman;
            }
          }
        };

        typeSelect.addEventListener('change', handleTypeChange);
        nameInput.addEventListener('input', () => {
          if (nameInput.value.trim().length > 0) {
            nameInput.dataset.touched = 'true';
          } else {
            delete nameInput.dataset.touched;
          }
        });

        controls.appendChild(typeSelect);
        controls.appendChild(nameInput);
        controls.appendChild(skillSelect);
        row.appendChild(label);
        row.appendChild(controls);
        container.appendChild(row);
        handleTypeChange();
      }
    }

    function gatherOpponentConfigurations() {
      const container = document.getElementById('opponentSelectors');
      if (!container) return [];
      const rows = Array.from(container.querySelectorAll('.opponent-row'));
      return rows.map(row => {
        const typeSelect = row.querySelector('select[data-role="type"]');
        const nameInput = row.querySelector('input[data-role="name"]');
        const skillSelect = row.querySelector('select[data-role="skill"]');
        const type = typeSelect ? typeSelect.value : 'cpu';
        const nameValue = nameInput ? nameInput.value.trim() : '';
        const fallback = type === 'human' ? nameInput?.dataset.defaultHuman : nameInput?.dataset.defaultCpu;
        const name = nameValue || fallback || (type === 'human' ? 'Commander' : 'CPU');
        return type === 'human'
          ? { type: 'human', name }
          : { type: 'cpu', name, skill: Number(skillSelect ? skillSelect.value : 3) };
      });
    }

    function hideSetupOverlay() {
      const overlay = document.getElementById('setupOverlay');
      if (overlay) {
        overlay.classList.remove('active');
      }
    }

    function showSetupOverlay() {
      const overlay = document.getElementById('setupOverlay');
      if (overlay) {
        overlay.classList.add('active');
      }
      weaponsTestMode = false;
      gameState = 'setup';
      disablePlayerControls();
      setStatus('Configure opponents to begin the campaign.');
      if (typeof opponentCountSelect !== 'undefined' && opponentCountSelect) {
        updateOpponentSelectors(Number(opponentCountSelect.value));
      }
    }

    function resetTankForCampaign(tank, resetMoney = true) {
      tank.inventory = baseInventory();
      if (tank.isPlayer) {
        if (weaponsTestMode) {
          grantWeaponsTestLoadout(tank);
        } else {
          tank.inventory['Baby Missile'] = Infinity;
        }
      }
      if (resetMoney) {
        tank.money = tank.isPlayer ? 400 : 0;
      }
      tank.maxHealth = 100;
      tank.health = 100;
      tank.activeShield = 0;
      tank.alive = true;
      tank.lockedTargetId = null;
      tank.solutionMemory = {};
      tank.lastTargetId = null;
      tank.selectedWeapon = 'Baby Missile';
      tank.angle = 60;
      tank.power = 65;
    }

    function buildHuman(name, paletteIndex) {
      const color = humanPalette[paletteIndex % humanPalette.length];
      const tank = createTank(name, color, { ai: false });
      if (weaponsTestMode) {
        grantWeaponsTestLoadout(tank);
      } else {
        tank.inventory['Baby Missile'] = Infinity;
      }
      return tank;
    }

    function ensureDefaultCommander() {
      if (humanPlayers.length > 0) {
        setActiveHuman(humanPlayers[0]);
        return;
      }
      const commander = buildHuman('Commander', 0);
      resetTankForCampaign(commander, true);
      humanPlayers = [commander];
      aiOpponents = [];
      tanks = [commander];
      currentPlayer = commander;
      setActiveHuman(commander);
    }

    function configureRoster(configs, options = {}) {
      const isWeaponsTest = !!options.weaponsTest;
      weaponsTestMode = isWeaponsTest;
      const commanderField = document.getElementById('commanderName');
      const commanderName = commanderField && commanderField.value.trim().length
        ? commanderField.value.trim()
        : 'Commander';
      humanPlayers = [buildHuman(commanderName, 0)];
      aiOpponents = [];

      if (!isWeaponsTest) {
        configs.forEach((config, idx) => {
          if (config.type === 'human') {
            const humanIndex = humanPlayers.length;
            humanPlayers.push(buildHuman(config.name || `Commander ${idx + 2}`, humanIndex));
          } else {
            const aiIndex = aiOpponents.length;
            const color = aiPalette[aiIndex % aiPalette.length];
            const aiName = config.name || aiNames[aiIndex % aiNames.length];
            const tank = createTank(aiName, color, { ai: true, skill: config.skill ?? 3 });
            tank.money = 0;
            aiOpponents.push(tank);
          }
        });
      }

      tanks = [...humanPlayers, ...aiOpponents];
      const resetMoney = !isWeaponsTest;
      humanPlayers.forEach(tank => resetTankForCampaign(tank, resetMoney));
      if (!isWeaponsTest) {
        aiOpponents.forEach(tank => resetTankForCampaign(tank, true));
      }
      roundNumber = 0;
      wind = 0;
      roundStarterIndex = 0;
      currentPlayerIndex = 0;
      currentPlayer = humanPlayers[0] || null;
      shopQueue = [];
      currentShopCommander = null;
      gameState = 'aim';
      hideSetupOverlay();
      setActiveHuman(currentPlayer);
      startRound();
    }

    const opponentCountSelect = document.getElementById('opponentCount');
    if (opponentCountSelect) {
      updateOpponentSelectors(Number(opponentCountSelect.value));
      opponentCountSelect.addEventListener('change', () => {
        updateOpponentSelectors(Number(opponentCountSelect.value));
      });
    }

    const startGameBtn = document.getElementById('startGameBtn');
    if (startGameBtn) {
      startGameBtn.addEventListener('click', () => {
        if (!opponentCountSelect) return;
        const count = Number(opponentCountSelect.value);
        const configs = gatherOpponentConfigurations();
        if (configs.length !== count) {
          return;
        }
        configureRoster(configs);
      });
    }

    const weaponsTestBtn = document.getElementById('weaponsTestBtn');
    if (weaponsTestBtn) {
      weaponsTestBtn.addEventListener('click', () => {
        configureRoster([], { weaponsTest: true });
      });
    }

    function degToRad(angle) {
      return angle * Math.PI / 180;
    }

    function getLaunchRadians(angle) {
      const clamped = clamp(angle, 0, 180);
      return Math.PI - degToRad(clamped);
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function terrainHeightAt(x) {
      const idx = Math.max(0, Math.min(terrain.heights.length - 1, Math.floor(x)));
      return terrain.heights[idx];
    }

    function generateTerrain() {
      const heights = new Array(canvas.width);
      const segments = 16;
      const step = Math.ceil(canvas.width / segments);
      let lastHeight = canvas.height * (0.55 + Math.random() * 0.1);
      for (let s = 0; s <= segments; s++) {
        const nextHeight = canvas.height * (0.38 + Math.random() * 0.33);
        for (let i = 0; i < step; i++) {
          const x = s * step + i;
          if (x >= canvas.width) break;
          const t = i / step;
          const base = lastHeight * (1 - t) + nextHeight * t;
          const noise = Math.sin((x + Math.random() * 15) * 0.03) * 10;
          const y = Math.min(canvas.height - 18, Math.max(canvas.height * 0.28, base + noise));
          heights[x] = y;
        }
        lastHeight = nextHeight;
      }
      terrain.heights = heights;
    }

    function smoothTerrain(iterations = 2) {
      for (let k = 0; k < iterations; k++) {
        for (let x = 1; x < terrain.heights.length - 1; x++) {
          terrain.heights[x] = (terrain.heights[x - 1] + terrain.heights[x] + terrain.heights[x + 1]) / 3;
        }
      }
    }

    function addWeapon(tank, weapon, amount) {
      tank.inventory[weapon] = (tank.inventory[weapon] || 0) + amount;
    }

    function placeTanks() {
      function findSpot(minX, maxX) {
        let spot = Math.floor((minX + maxX) / 2);
        let bestSlope = Infinity;
        for (let i = 0; i < 90; i++) {
          const x = Math.floor(minX + Math.random() * Math.max(1, maxX - minX));
          const slope = Math.abs(terrainHeightAt(x + 12) - terrainHeightAt(x - 12));
          if (slope < bestSlope) {
            bestSlope = slope;
            spot = x;
          }
        }
        return Math.max(60, Math.min(canvas.width - 60, spot));
      }
      const padding = 70;
      const total = Math.max(1, tanks.length);
      const usableWidth = canvas.width - padding * 2;
      tanks.forEach((tank, index) => {
        const segment = usableWidth / total;
        const minX = padding + segment * index;
        const maxX = padding + segment * (index + 1);
        const xPos = findSpot(minX, maxX);
        tank.x = xPos;
        tank.y = terrainHeightAt(xPos);
        tank.health = tank.maxHealth;
        tank.alive = true;
        tank.activeShield = Math.min(tank.activeShield, 0.6);
        tank.tracerCache = [];
        tank.lockedTargetId = tank.aiSkill && tank.aiSkill > 1 ? tank.lockedTargetId : null;
        tank.angle = tank.x < canvas.width / 2 ? 120 : 60;
        tank.power = 65;
      });
      tanks.forEach(tank => {
        const rivals = tanks.filter(other => other !== tank && other.alive);
        if (rivals.length) {
          const nearest = rivals.reduce((acc, other) => {
            const dist = Math.abs(other.x - tank.x);
            if (!acc || dist < acc.dist) {
              return { tank: other, dist };
            }
            return acc;
          }, null);
          if (nearest) {
            tank.facing = nearest.tank.x >= tank.x ? 1 : -1;
            tank.angle = tank.facing === 1 ? 120 : 60;
          }
        } else {
          tank.facing = tank.x < canvas.width / 2 ? 1 : -1;
        }
      });
    }

    function resetProjectiles() {
      projectiles.length = 0;
      fireZones.length = 0;
      lastTracer = null;
    }

    function startRound() {
      if (tanks.length === 0) return;
      shopQueue = [];
      currentShopCommander = null;
      closeShopOverlay();
      if (weaponsTestMode) {
        roundNumber = roundNumber === 0 ? 1 : roundNumber;
      } else {
        roundNumber++;
      }
      generateTerrain();
      smoothTerrain(3);
      placeTanks();
      resetProjectiles();
      wind = (Math.random() * 0.6) - 0.3;
      prepareAiInventory();
      if (roundNumber === 1) {
        roundStarterIndex = 0;
      } else {
        roundStarterIndex = (roundStarterIndex + 1) % tanks.length;
      }
      currentPlayerIndex = roundStarterIndex;
      currentPlayer = tanks[currentPlayerIndex];
      gameState = 'aim';
      if (weaponsTestMode) {
        setStatus('Weapons test range ready. Fire at will.');
      } else {
        const opener = currentPlayer.isPlayer
          ? `${currentPlayer.name} takes the first shot.`
          : `${currentPlayer.name} seizes the initiative.`;
        setStatus(`Round ${roundNumber} begins. ${opener}`);
      }
      if (currentPlayer.isPlayer) {
        setActiveHuman(currentPlayer);
        enablePlayerControls();
      } else {
        disablePlayerControls();
        if (humanPlayers.length > 0) {
          setActiveHuman(activeHuman || humanPlayers[0]);
        } else {
          updateHUD();
        }
        scheduleAiTurn(currentPlayer);
      }
      updateFastForwardState();
    }

    function prepareAiInventory() {
      aiOpponents.forEach(tank => {
        tank.inventory = baseInventory();
        if (roundNumber > 3) {
          tank.inventory['Mega Nuke'] = 2;
        }
        if (roundNumber > 1) {
          tank.inventory['MIRV'] = 2;
        }
        tank.activeShield = Math.min(tank.activeShield, 0.4);
        tank.lockedTargetId = null;
        tank.solutionMemory = {};
      });
    }

    function disablePlayerControls() {
      document.getElementById('fireBtn').disabled = true;
      document.getElementById('weaponSelect').disabled = true;
      document.getElementById('angleSlider').disabled = true;
      document.getElementById('powerSlider').disabled = true;
    }

    function enablePlayerControls() {
      document.getElementById('fireBtn').disabled = false;
      document.getElementById('weaponSelect').disabled = false;
      document.getElementById('angleSlider').disabled = false;
      document.getElementById('powerSlider').disabled = false;
    }

    function setStatus(text) {
      document.getElementById('status').textContent = text;
    }

    function updateHUD() {
      const roundDisplay = document.getElementById('roundDisplay');
      if (roundDisplay) {
        roundDisplay.textContent = weaponsTestMode ? 'Test' : roundNumber;
      }
      const windDisplay = document.getElementById('windDisplay');
      if (windDisplay) {
        if (Math.abs(wind) < 0.05) {
          windDisplay.textContent = 'Calm';
        } else if (wind > 0) {
          windDisplay.textContent = `→ ${wind.toFixed(2)}`;
        } else {
          windDisplay.textContent = `← ${Math.abs(wind).toFixed(2)}`;
        }
      }
      const human = activeHuman;
      const moneyDisplay = document.getElementById('moneyDisplay');
      if (moneyDisplay) {
        if (weaponsTestMode) {
          moneyDisplay.textContent = '∞';
        } else {
          moneyDisplay.textContent = human ? human.money : 0;
        }
      }
      const turnDisplay = document.getElementById('turnDisplay');
      if (turnDisplay) {
        turnDisplay.textContent = currentPlayer && currentPlayer.alive ? currentPlayer.name : '—';
      }
      const angleSlider = document.getElementById('angleSlider');
      const angleValue = document.getElementById('angleValue');
      const powerSlider = document.getElementById('powerSlider');
      const powerValue = document.getElementById('powerValue');
      const angle = human ? human.angle : 60;
      const power = human ? human.power : 65;
      if (angleSlider) {
        angleSlider.value = angle;
      }
      if (angleValue) {
        angleValue.textContent = `${Math.round(angle)}°`;
      }
      if (powerSlider) {
        powerSlider.value = power;
      }
      if (powerValue) {
        powerValue.textContent = `${Math.round(power)}`;
      }
    }

    function formatInventoryCount(count) {
      return count === Infinity ? '∞' : count;
    }

    function updateInventoryUI() {
      const invDiv = document.getElementById('inventory');
      if (!invDiv) return;
      const human = activeHuman;
      if (!human) {
        invDiv.innerHTML = '';
        return;
      }
      const entries = [];
      for (const [item, count] of Object.entries(human.inventory)) {
        if (count > 0) {
          entries.push(`<span>${item}: ${formatInventoryCount(count)}</span>`);
        }
      }
      entries.push(`<span>Armor: ${Math.round(human.health)} / ${human.maxHealth}</span>`);
      if (human.activeShield > 0.05) {
        entries.push(`<span>Shield Strength: ${(human.activeShield * 100).toFixed(0)}%</span>`);
      }
      invDiv.innerHTML = entries.join('');
    }

    function updateWeaponSelect() {
      const select = document.getElementById('weaponSelect');
      if (!select) return;
      const human = activeHuman;
      const previous = select.value;
      select.innerHTML = '';
      if (!human) {
        const fallback = document.createElement('option');
        fallback.value = '';
        fallback.textContent = 'No commander';
        select.appendChild(fallback);
        select.disabled = true;
        const fireBtn = document.getElementById('fireBtn');
        if (fireBtn) fireBtn.disabled = true;
        return;
      }
      const options = [];
      const fireBtn = document.getElementById('fireBtn');
      for (const [name, count] of Object.entries(human.inventory)) {
        if ((weaponCatalog[name] || utilities[name]) && count > 0) {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = `${name} (${formatInventoryCount(count)})`;
          options.push(option);
        }
      }
      if (options.length === 0) {
        const fallback = document.createElement('option');
        fallback.value = '';
        fallback.textContent = 'Out of ammo';
        options.push(fallback);
        if (fireBtn) fireBtn.disabled = true;
        select.disabled = true;
      } else {
        select.disabled = false;
        if (fireBtn) fireBtn.disabled = false;
      }
      options.forEach(opt => select.appendChild(opt));
      let targetSelection = human.selectedWeapon;
      if (!targetSelection || !human.inventory[targetSelection]) {
        targetSelection = options.length > 0 ? options[0].value : '';
      }
      if (previous && human.inventory[previous] > 0) {
        targetSelection = previous;
      }
      if (targetSelection) {
        select.value = targetSelection;
        human.selectedWeapon = targetSelection;
      }
    }

    function addProjectile(projectile) {
      projectile.trail = [];
      projectile.life = 0;
      projectiles.push(projectile);
      gameState = 'projectile';
      disablePlayerControls();
      updateFastForwardState();
    }

    function launchProjectile(tank, weaponName) {
      const config = weaponCatalog[weaponName];
      if (!config) return;
      const angle = tank.angle;
      const power = tank.power;
      const rad = getLaunchRadians(angle);
      const speed = power * SPEED_SCALE * POWER_ATTENUATION;
      const vx = Math.cos(rad) * speed;
      const vy = -Math.sin(rad) * speed;
      const startX = tank.x + Math.cos(rad) * (tankWidth * 0.45);
      const startY = tank.y - tankHeight - Math.sin(rad) * (tankWidth * 0.2);
      const projectile = {
        weapon: weaponName,
        owner: tank,
        x: startX,
        y: startY,
        vx,
        vy,
        split: false,
        tracer: !!config.tracer
      };
      addProjectile(projectile);
      if (weaponName === 'Tracer Round') {
        setStatus(`${tank.name} lights up the sky with a tracer.`);
      }
    }

    function useUtility(tank, name) {
      const util = utilities[name];
      if (!util) return false;
      if (!tank.inventory[name] || tank.inventory[name] <= 0) {
        setStatus(`${tank.name} has no ${name}s remaining.`);
        return false;
      }
      const success = util.action(tank);
      if (success) {
        updateInventoryUI();
      }
      return success;
    }

    function fireSelectedWeapon() {
      if (gameState !== 'aim' || !currentPlayer || !currentPlayer.isPlayer || currentPlayer !== activeHuman) return;
      const tank = activeHuman;
      if (!tank) return;
      const select = document.getElementById('weaponSelect');
      if (!select) return;
      const weapon = select.value;
      if (!weapon || !tank.inventory[weapon]) {
        setStatus('No ammunition selected.');
        return;
      }
      tank.angle = Number(document.getElementById('angleSlider').value);
      tank.power = Number(document.getElementById('powerSlider').value);
      if (utilities[weapon]) {
        const used = useUtility(tank, weapon);
        if (used) {
          endTurn();
        }
        return;
      }
      if (!weaponCatalog[weapon]) {
        setStatus('Unknown weapon.');
        return;
      }
      if (weapon !== 'Baby Missile') {
        tank.inventory[weapon]--;
      }
      tank.selectedWeapon = weapon;
      launchProjectile(tank, weapon);
      updateInventoryUI();
      updateWeaponSelect();
    }

    document.getElementById('fireBtn').addEventListener('click', fireSelectedWeapon);
    document.getElementById('weaponSelect').addEventListener('change', () => {
      const weapon = document.getElementById('weaponSelect').value;
      if (activeHuman && weapon) {
        activeHuman.selectedWeapon = weapon;
      }
      setStatus(weapon ? `Selected ${weapon}.` : 'No weapon selected.');
    });

    document.getElementById('angleSlider').addEventListener('input', (e) => {
      if (activeHuman) {
        activeHuman.angle = Number(e.target.value);
      }
      document.getElementById('angleValue').textContent = `${e.target.value}°`;
    });
    document.getElementById('powerSlider').addEventListener('input', (e) => {
      if (activeHuman) {
        activeHuman.power = Number(e.target.value);
      }
      document.getElementById('powerValue').textContent = `${e.target.value}`;
    });

    document.addEventListener('keydown', (e) => {
      const isSpace = e.code === 'Space' || e.key === ' ';
      const isArrow = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key);
      if (!isArrow && !isSpace) {
        return;
      }
      if (gameState !== 'aim' || !currentPlayer || !currentPlayer.isPlayer || currentPlayer !== activeHuman) {
        return;
      }
      if (isSpace) {
        const activeElement = document.activeElement;
        if (activeElement) {
          const tag = activeElement.tagName;
          if (tag === 'INPUT') {
            const type = activeElement.getAttribute('type');
            if (type !== 'range') {
              return;
            }
          } else if (tag === 'SELECT' || tag === 'TEXTAREA') {
            return;
          }
        }
        e.preventDefault();
        fireSelectedWeapon();
        return;
      }
      const angleSlider = document.getElementById('angleSlider');
      const powerSlider = document.getElementById('powerSlider');
      let handled = false;
      if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        const currentAngle = Number(angleSlider.value);
        const step = 1;
        const delta = e.key === 'ArrowLeft' ? -step : step;
        const newAngle = clamp(currentAngle + delta, Number(angleSlider.min), Number(angleSlider.max));
        if (newAngle !== currentAngle) {
          handled = true;
        }
        angleSlider.value = newAngle;
        if (activeHuman) {
          activeHuman.angle = newAngle;
        }
        document.getElementById('angleValue').textContent = `${Math.round(newAngle)}°`;
      }
      if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
        const currentPower = Number(powerSlider.value);
        const step = 1;
        const delta = e.key === 'ArrowDown' ? -step : step;
        const newPower = clamp(currentPower + delta, Number(powerSlider.min), Number(powerSlider.max));
        if (newPower !== currentPower) {
          handled = true;
        }
        powerSlider.value = newPower;
        if (activeHuman) {
          activeHuman.power = newPower;
        }
        document.getElementById('powerValue').textContent = `${Math.round(newPower)}`;
      }
      if (handled) {
        e.preventDefault();
      }
    });

    const shopBtn = document.getElementById('shopBtn');
    if (shopBtn) {
      shopBtn.addEventListener('click', () => {
        if (weaponsTestMode) {
          setStatus('Weapons Test supplies are limitless—no depot required.');
          return;
        }
        if (gameState !== 'roundEnd') {
          setStatus('You can visit the depot between rounds. Finish the fight!');
          return;
        }
        if (currentShopCommander) {
          openShopFor(currentShopCommander);
          return;
        }
        if (shopQueue.length === 0 && humanPlayers.length > 0) {
          shopQueue = humanPlayers.slice();
        }
        if (shopQueue.length > 0) {
          openNextShopper();
        }
      });
    }

    const skipBtnControl = document.getElementById('skipFightBtn');
    if (skipBtnControl) {
      skipBtnControl.addEventListener('click', () => {
        if (gameState === 'roundEnd') return;
        skipCurrentFight();
      });
    }

    document.getElementById('closeShopBtn').addEventListener('click', () => {
      closeShopOverlay();
    });
    document.getElementById('nextRoundBtn').addEventListener('click', () => {
      if (gameState !== 'roundEnd') {
        closeShopOverlay();
        return;
      }
      if (shopQueue.length > 0) {
        openNextShopper();
        return;
      }
      currentShopCommander = null;
      closeShopOverlay();
      startRound();
    });

    function openShopFor(tank) {
      currentShopCommander = tank;
      setActiveHuman(tank);
      const overlay = document.getElementById('shopOverlay');
      const itemsDiv = document.getElementById('shopItems');
      itemsDiv.innerHTML = '';
      document.getElementById('shopMoney').textContent = tank.money;
      const deployBtn = document.getElementById('nextRoundBtn');
      if (deployBtn) {
        const remaining = shopQueue.length;
        deployBtn.disabled = false;
        deployBtn.textContent = remaining === 0 ? 'Deploy Next Round' : 'Next Commander';
      }
      storeItems.forEach(item => {
        const card = document.createElement('div');
        card.className = 'shop-card';
        const title = document.createElement('h3');
        title.textContent = `${item.title} — $${item.cost}`;
        const blurb = document.createElement('p');
        blurb.textContent = item.blurb;
        const btn = document.createElement('button');
        btn.textContent = `Purchase`;
        if (tank.money < item.cost) {
          btn.disabled = true;
          btn.textContent = 'Insufficient credits';
        }
        btn.addEventListener('click', () => {
          if (!currentShopCommander || currentShopCommander !== tank) return;
          if (tank.money < item.cost) return;
          tank.money -= item.cost;
          item.apply(tank);
          document.getElementById('shopMoney').textContent = tank.money;
          updateInventoryUI();
          updateWeaponSelect();
          btn.disabled = tank.money < item.cost;
          setStatus(`Purchased ${item.title} for ${tank.name}.`);
        });
        card.appendChild(title);
        card.appendChild(blurb);
        card.appendChild(btn);
        itemsDiv.appendChild(card);
      });
      overlay.classList.add('active');
    }

    function closeShopOverlay() {
      const overlay = document.getElementById('shopOverlay');
      if (overlay) {
        overlay.classList.remove('active');
      }
      if (currentShopCommander) {
        const moneyEl = document.getElementById('shopMoney');
        if (moneyEl) {
          moneyEl.textContent = currentShopCommander.money;
        }
      }
    }

    function openNextShopper() {
      if (shopQueue.length === 0) {
        currentShopCommander = null;
        closeShopOverlay();
        startRound();
        return;
      }
      const next = shopQueue.shift();
      openShopFor(next);
    }

    function skipCurrentFight() {
      if (weaponsTestMode) {
        setStatus('Weapons Test mode has no rival commanders to skip.');
        return;
      }
      const remaining = tanks.filter(t => t.alive);
      const winner = remaining[0] || null;
      resetProjectiles();
      particles.length = 0;
      endRound(winner, 'Engagement skipped');
    }

    function carveTerrain(cx, cy, radius) {
      const start = Math.floor(Math.max(0, cx - radius));
      const end = Math.ceil(Math.min(canvas.width - 1, cx + radius));
      for (let x = start; x <= end; x++) {
        const dist = Math.abs(x - cx);
        if (dist > radius) continue;
        const depth = Math.sqrt(radius * radius - dist * dist);
        const target = cy + depth;
        if (terrain.heights[x] < target) {
          terrain.heights[x] = Math.min(canvas.height - 2, target);
        }
      }
    }

    function depositTerrain(cx, cy, radius) {
      const start = Math.floor(Math.max(0, cx - radius));
      const end = Math.ceil(Math.min(canvas.width - 1, cx + radius));
      for (let x = start; x <= end; x++) {
        const dist = Math.abs(x - cx);
        if (dist > radius) continue;
        const lift = Math.sqrt(radius * radius - dist * dist);
        const target = cy - lift;
        if (terrain.heights[x] > target) {
          terrain.heights[x] = Math.max(canvas.height * 0.18, target);
        }
      }
    }

    function applyDamage(tank, amount, source = null) {
      if (!tank.alive) return;
      let dmg = amount;
      if (tank.activeShield > 0) {
        dmg *= (1 - tank.activeShield);
        tank.activeShield = Math.max(0, tank.activeShield - 0.25);
      }
      tank.health -= dmg;
      if (source && source.ai && source !== tank && source.aiSkill >= 2 && source.aiSkill <= 4 && dmg > 0.1) {
        source.lockedTargetId = tank.id;
      }
      if (tank.health <= 0) {
        destroyTank(tank, source);
      }
    }

    function destroyTank(tank, source = null) {
      if (!tank.alive) return;
      tank.alive = false;
      tank.health = 0;
      createParticles(tank.x, tank.y - tankHeight / 2, '#ffba64', 40);
      if (source && source !== tank) {
        source.money += 250;
        setStatus(`${source.name} obliterates ${tank.name}!`);
      } else {
        setStatus(`${tank.name} is obliterated!`);
      }
      tanks.forEach(actor => {
        if (actor.lockedTargetId === tank.id) {
          actor.lockedTargetId = null;
        }
        if (actor.solutionMemory && actor.solutionMemory[tank.id]) {
          delete actor.solutionMemory[tank.id];
        }
        if (actor.lastTargetId === tank.id) {
          actor.lastTargetId = null;
        }
      });
      updateHUD();
      const survivors = tanks.filter(t => t.alive);
      if (survivors.length <= 1) {
        if (weaponsTestMode) {
          const tester = humanPlayers[0] || survivors[0] || tank;
          resetProjectiles();
          particles.length = 0;
          fireZones.length = 0;
          if (tester) {
            resetTankForCampaign(tester, false);
          }
          tanks = humanPlayers.slice();
          currentPlayerIndex = 0;
          currentPlayer = tester || null;
          setActiveHuman(tester || null);
          setStatus('Weapons test recalibrating...');
          setTimeout(() => {
            if (tester && !tester.alive) {
              tester.alive = true;
            }
            startRound();
          }, 600);
          return;
        }
        const winner = survivors[0] || source || null;
        endRound(winner, `${tank.name} destroyed`);
      }
      updateFastForwardState();
    }

    function endRound(winner, reason) {
      if (gameState === 'roundEnd') return;
      gameState = 'roundEnd';
      disablePlayerControls();
      const victorName = winner ? winner.name : 'No commander';
      fastForwardActive = false;
      const suffix = humanPlayers.length > 0 ? ' Commanders may visit the depot before redeploying.' : '';
      setStatus(`Round ${roundNumber} complete: ${victorName} prevails — ${reason}.${suffix}`);
      setActiveHuman(humanPlayers[0] || null);
      shopQueue = humanPlayers.slice();
      currentShopCommander = null;
      updateFastForwardState();
      if (shopQueue.length > 0) {
        setTimeout(() => {
          if (gameState === 'roundEnd') {
            openNextShopper();
          }
        }, 700);
      } else {
        setTimeout(() => {
          if (gameState === 'roundEnd') {
            startRound();
          }
        }, 900);
      }
    }

    function settleTank(tank) {
      if (!tank.alive) return;
      const previous = tank.y;
      const newSurface = terrainHeightAt(tank.x);
      tank.y = newSurface;
      const drop = newSurface - previous;
      if (drop > 18) {
        applyDamage(tank, drop * 0.6);
      }
      if (tank.y > canvas.height - 5) {
        destroyTank(tank, null);
      }
    }

    function settleAllTanks() {
      tanks.forEach(tank => settleTank(tank));
    }

    function handleExplosion(projectile, impactX, impactY) {
      const catalogConfig = weaponCatalog[projectile.weapon];
      if (!catalogConfig) return;
      const effectiveType = catalogConfig.type === 'mirv' ? 'explosive' : catalogConfig.type;
      if (projectile.tracer) {
        lastTracer = { points: projectile.trail.slice(), timer: 240 };
      }
      switch (effectiveType) {
        case 'explosive':
          carveTerrain(impactX, impactY, catalogConfig.radius);
          createParticles(impactX, impactY, '#ff944a', 26);
          damageFromBlast(projectile.owner, impactX, impactY, catalogConfig.radius, catalogConfig.damage);
          break;
        case 'napalm':
          carveTerrain(impactX, impactY, catalogConfig.radius * 0.75);
          createParticles(impactX, impactY, '#ff5a2e', 32);
          damageFromBlast(projectile.owner, impactX, impactY, catalogConfig.radius, catalogConfig.damage);
          fireZones.push({
            x: impactX,
            y: impactY,
            radius: catalogConfig.radius + 12,
            timer: 240,
            damage: 4,
            owner: projectile.owner || null
          });
          break;
        case 'dirt':
          depositTerrain(impactX, impactY, catalogConfig.radius);
          createParticles(impactX, impactY, '#b78a55', 20);
          break;
      }
      settleAllTanks();
    }

    function damageFromBlast(owner, cx, cy, radius, damage) {
      tanks.forEach(tank => {
        if (!tank.alive) return;
        const tx = tank.x;
        const ty = tank.y - tankHeight / 2;
        const dist = Math.hypot(cx - tx, cy - ty);
        if (dist <= radius + 12) {
          const falloff = Math.max(0.2, 1 - dist / (radius + 12));
          applyDamage(tank, damage * falloff, owner || null);
          if (owner && owner !== tank) {
            owner.money += Math.round(25 * falloff);
          }
        }
      });
      updateHUD();
      updateInventoryUI();
    }

    function updateProjectiles(delta) {
      if (projectiles.length === 0) return;
      for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.life += delta;
        p.vy += GRAVITY * delta;
        p.vx += wind * WIND_EFFECT * delta;
        p.x += p.vx * delta;
        p.y += p.vy * delta;
        p.trail.push({ x: p.x, y: p.y });
        if (p.trail.length > 120) p.trail.shift();
        if (p.weapon === 'MIRV' && !p.split && p.vy > 0) {
          splitMirv(p);
          projectiles.splice(i, 1);
          continue;
        }
        if (p.x < -40 || p.x > canvas.width + 40 || p.y > canvas.height + 40 || p.life > 1200) {
          projectiles.splice(i, 1);
          continue;
        }
        const ground = terrainHeightAt(p.x);
        if (p.y >= ground) {
          handleExplosion(p, p.x, ground);
          projectiles.splice(i, 1);
          continue;
        }
        for (const tank of tanks) {
          if (!tank.alive) continue;
          const tx = tank.x;
          const ty = tank.y - tankHeight / 2;
          if (Math.hypot(p.x - tx, p.y - ty) <= tankWidth * 0.6) {
            handleExplosion(p, p.x, p.y);
            projectiles.splice(i, 1);
            break;
          }
        }
      }
      if (projectiles.length === 0) {
        finishShot();
      }
    }

    function splitMirv(projectile) {
      projectile.split = true;
      const count = 4;
      const spread = Math.PI / 6;
      for (let i = 0; i < count; i++) {
        const offset = -spread / 2 + (spread / (count - 1)) * i;
        const speed = Math.hypot(projectile.vx, projectile.vy) * 0.65;
        const angle = Math.atan2(projectile.vy, projectile.vx) + offset;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const sub = {
          weapon: 'Mini MIRV',
          owner: projectile.owner,
          x: projectile.x,
          y: projectile.y,
          vx,
          vy,
          split: true,
          tracer: false,
          trail: []
        };
        addProjectile(sub);
      }
      createParticles(projectile.x, projectile.y, '#ffd866', 20);
    }

    function finishShot() {
      if (gameState !== 'projectile') return;
      gameState = 'aim';
      settleAllTanks();
      const alive = tanks.filter(tank => tank.alive);
      if (alive.length <= 1) {
        return;
      }
      endTurn();
    }

    function endTurn() {
      if (gameState !== 'aim') return;
      const alive = tanks.filter(tank => tank.alive);
      if (alive.length <= 1) return;
      let nextIndex = currentPlayerIndex;
      for (let i = 0; i < tanks.length; i++) {
        nextIndex = (nextIndex + 1) % tanks.length;
        if (tanks[nextIndex].alive) {
          currentPlayerIndex = nextIndex;
          currentPlayer = tanks[currentPlayerIndex];
          break;
        }
      }
      updateHUD();
      if (currentPlayer && currentPlayer.isPlayer && currentPlayer.alive) {
        setActiveHuman(currentPlayer);
        enablePlayerControls();
        setStatus(`${currentPlayer.name}, adjust angle and power, then fire.`);
      } else {
        disablePlayerControls();
        if (currentPlayer && currentPlayer.alive) {
          setStatus(`${currentPlayer.name} is calibrating targeting solutions...`);
          scheduleAiTurn(currentPlayer);
        }
      }
      updateFastForwardState();
    }

    function updateFireZones(delta) {
      for (let i = fireZones.length - 1; i >= 0; i--) {
        const zone = fireZones[i];
        zone.timer -= delta * 10;
        if (zone.timer <= 0) {
          fireZones.splice(i, 1);
          continue;
        }
        for (const tank of tanks) {
          if (!tank.alive) continue;
          const dist = Math.hypot(zone.x - tank.x, zone.y - (tank.y - tankHeight / 2));
          if (dist < zone.radius) {
            applyDamage(tank, zone.damage * (delta / 2), zone.owner || null);
          }
        }
        if (Math.random() < 0.4) {
          carveTerrain(zone.x + (Math.random() - 0.5) * zone.radius, zone.y, 6);
        }
      }
    }

    function updateParticles(delta) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life -= delta;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        p.vx *= 0.98;
        p.vy += 0.05 * delta;
        p.x += p.vx * delta;
        p.y += p.vy * delta;
      }
    }

    function createParticles(x, y, color, count) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x,
          y,
          vx: (Math.random() - 0.5) * 4,
          vy: (Math.random() - 0.5) * 3,
          life: 40 + Math.random() * 30,
          color
        });
      }
    }

    function drawBackground() {
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#081020');
      grad.addColorStop(0.4, '#0b1732');
      grad.addColorStop(1, '#1b120d');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.12)';
      stars.forEach(star => {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.r, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.restore();
    }

    function drawTerrain() {
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.lineTo(0, terrain.heights[0]);
      for (let x = 1; x < terrain.heights.length; x++) {
        ctx.lineTo(x, terrain.heights[x]);
      }
      ctx.lineTo(canvas.width, canvas.height);
      ctx.closePath();
      const grad = ctx.createLinearGradient(0, canvas.height * 0.4, 0, canvas.height);
      grad.addColorStop(0, '#3a2f28');
      grad.addColorStop(1, '#1b110c');
      ctx.fillStyle = grad;
      ctx.fill();
    }

    function drawRoundedRect(x, y, width, height, radius) {
      const r = Math.min(radius, Math.abs(width) / 2, Math.abs(height) / 2);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + width - r, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + r);
      ctx.lineTo(x + width, y + height - r);
      ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
      ctx.lineTo(x + r, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    function drawTank(tank) {
      if (!tank.alive) return;
      const baseY = tank.y;
      const topY = baseY - tankHeight;
      ctx.save();
      ctx.fillStyle = tank.color;
      drawRoundedRect(tank.x - tankWidth / 2, topY, tankWidth, tankHeight - 6, 6);
      ctx.fill();
      ctx.fillStyle = '#111821';
      ctx.fillRect(tank.x - tankWidth / 2, baseY - 6, tankWidth, 6);
      const angle = getLaunchRadians(tank.angle);
      const turretX = tank.x;
      const turretY = topY + 6;
      ctx.strokeStyle = '#d0f7ff';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(turretX, turretY);
      ctx.lineTo(turretX + Math.cos(angle) * 28, turretY - Math.sin(angle) * 28);
      ctx.stroke();
      if (tank.activeShield > 0.05) {
        ctx.strokeStyle = `rgba(138, 234, 255, ${0.3 + tank.activeShield})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(tank.x, turretY + tankHeight / 4, 28, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.fillStyle = '#fff';
      ctx.font = '14px "Segoe UI"';
      ctx.textAlign = 'center';
      ctx.fillText(`${tank.name}`, tank.x, topY - 20);
      ctx.fillStyle = '#ff6a6a';
      const healthRatio = Math.max(0, tank.health) / tank.maxHealth;
      ctx.fillRect(tank.x - 26, topY - 14, 52 * healthRatio, 5);
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.strokeRect(tank.x - 26, topY - 14, 52, 5);
      ctx.restore();
    }

    function drawProjectiles() {
      ctx.fillStyle = '#ffe7a3';
      projectiles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        ctx.fill();
        if (p.trail && p.trail.length > 1) {
          ctx.strokeStyle = p.tracer ? 'rgba(255,233,120,0.8)' : 'rgba(255,255,255,0.3)';
          ctx.lineWidth = p.tracer ? 2 : 1;
          ctx.beginPath();
          ctx.moveTo(p.trail[0].x, p.trail[0].y);
          for (let i = 1; i < p.trail.length; i++) {
            ctx.lineTo(p.trail[i].x, p.trail[i].y);
          }
          ctx.stroke();
        }
      });
    }

    function drawParticles() {
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = Math.max(0, p.life / 60);
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      });
    }

    function drawFireZones() {
      fireZones.forEach(zone => {
        const grad = ctx.createRadialGradient(zone.x, zone.y, 4, zone.x, zone.y, zone.radius);
        grad.addColorStop(0, 'rgba(255,120,0,0.65)');
        grad.addColorStop(0.6, 'rgba(200,60,0,0.25)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(zone.x, zone.y, zone.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawLastTracer() {
      if (!lastTracer) return;
      lastTracer.timer -= 1;
      if (lastTracer.timer <= 0) {
        lastTracer = null;
        return;
      }
      ctx.strokeStyle = 'rgba(120, 210, 255, 0.6)';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 6]);
      const pts = lastTracer.points;
      if (pts.length > 1) {
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y);
        }
        ctx.stroke();
      }
      ctx.setLineDash([]);
    }

    function draw() {
      drawBackground();
      drawTerrain();
      drawFireZones();
      drawProjectiles();
      drawParticles();
      tanks.forEach(drawTank);
      drawLastTracer();
    }

    function loop(timestamp) {
      if (lastFrameTime === null) {
        lastFrameTime = timestamp;
      }
      const frameDelta = (timestamp - lastFrameTime) / (1000 / 60);
      lastFrameTime = timestamp;
      const speed = fastForwardActive ? 5 : 1;
      const delta = Math.min(frameDelta * speed, 5);
      updateProjectiles(delta);
      updateFireZones(delta);
      updateParticles(delta);
      draw();
      requestAnimationFrame(loop);
    }

    function simulateShot(tank, weapon, angle, power, facing = tank.facing, target = null) {
      const config = weaponCatalog[weapon];
      if (!config) {
        return { dist: Infinity, impactX: tank.x, impactY: tank.y };
      }
      const aimFacing = facing ?? (target && target.x < tank.x ? -1 : 1);
      const rad = getLaunchRadians(angle);
      const speed = power * SPEED_SCALE * POWER_ATTENUATION;
      let vx = Math.cos(rad) * speed;
      let vy = -Math.sin(rad) * speed;
      let x = tank.x + Math.cos(rad) * (tankWidth * 0.45);
      let y = tank.y - tankHeight - Math.sin(rad) * (tankWidth * 0.2);
      let closest = Infinity;
      let impactX = x;
      let impactY = y;
      const targetCenterY = target ? target.y - tankHeight / 2 : null;
      for (let step = 0; step < 600; step++) {
        vy += GRAVITY;
        vx += wind * WIND_EFFECT;
        x += vx;
        y += vy;
        if (target) {
          const distCenter = Math.hypot(x - target.x, y - targetCenterY) - config.radius;
          if (distCenter < closest) {
            closest = distCenter;
          }
        }
        if (x < 0 || x > canvas.width || y > canvas.height) break;
        const ground = terrainHeightAt(x);
        if (y >= ground) {
          impactX = x;
          impactY = ground;
          if (target) {
            const finalDist = Math.hypot(impactX - target.x, impactY - targetCenterY) - config.radius;
            closest = Math.min(closest, finalDist);
          }
          break;
        }
      }
      return { dist: closest, impactX, impactY };
    }

    function getAliveOpponents(tank) {
      return tanks.filter(other => other !== tank && other.alive);
    }

    function aiChooseTarget(tank) {
      const options = getAliveOpponents(tank);
      if (options.length === 0) return null;
      if (tank.aiSkill === 1) {
        return options[Math.floor(Math.random() * options.length)];
      }
      if (tank.aiSkill >= 2 && tank.aiSkill <= 4 && tank.lockedTargetId) {
        const locked = options.find(opt => opt.id === tank.lockedTargetId);
        if (locked) {
          return locked;
        }
      }
      if (tank.aiSkill === 5) {
        const playerTarget = options.find(opt => opt.isPlayer);
        if (playerTarget) return playerTarget;
        return options.reduce((weakest, opt) => (opt.health < weakest.health ? opt : weakest), options[0]);
      }
      const playerTarget = options.find(opt => opt.isPlayer);
      if (playerTarget) return playerTarget;
      return options.reduce((weakest, opt) => (opt.health < weakest.health ? opt : weakest), options[0]);
    }

    function aiChooseWeapon(tank, target) {
      const available = Object.entries(tank.inventory)
        .filter(([name, count]) => count > 0 && (weaponCatalog[name] || utilities[name]))
        .map(([name]) => name);
      if (tank.health < 40 && tank.inventory['Repair Kit'] > 0) {
        return 'Repair Kit';
      }
      if (tank.activeShield < 0.15 && tank.inventory['Shield Pulse'] > 0 && Math.random() < 0.3) {
        return 'Shield Pulse';
      }
      if (!target) {
        return available.length ? available[Math.floor(Math.random() * available.length)] : 'Baby Missile';
      }
      const distance = Math.abs(tank.x - target.x);
      if (target.health > 60 && tank.inventory['Mega Nuke'] > 0 && Math.random() < 0.6) {
        return 'Mega Nuke';
      }
      if (distance > 420 && tank.inventory['MIRV'] > 0) {
        return 'MIRV';
      }
      if (tank.inventory['Heavy Missile'] > 0 && Math.random() < 0.5) {
        return 'Heavy Missile';
      }
      if (tank.inventory['Napalm'] > 0 && Math.random() < 0.35) {
        return 'Napalm';
      }
      if (tank.inventory['Dirt Bomb'] > 0 && target.activeShield > 0.3) {
        return 'Dirt Bomb';
      }
      return available.length ? available[Math.floor(Math.random() * available.length)] : 'Baby Missile';
    }

    function aiPlanShot(tank, target, weapon) {
      const skill = tank.aiSkill || 1;
      const facing = target ? (target.x >= tank.x ? 1 : -1) : tank.facing;
      if (skill === 1 || !target) {
        return {
          angle: clamp(20 + Math.random() * 140, 0, 180),
          power: clamp(45 + Math.random() * 70, 10, 120),
          facing
        };
      }
      const angleStep = skill >= 4 ? 2 : skill === 3 ? 4 : 6;
      const powerStep = skill >= 4 ? 4 : skill === 3 ? 6 : 8;
      let best = { dist: Infinity, angle: 60, power: 70, facing };
      for (let angle = 0; angle <= 180; angle += angleStep) {
        for (let power = 10; power <= 120; power += powerStep) {
          const result = simulateShot(tank, weapon, angle, power, facing, target);
          if (result.dist < best.dist) {
            best = { dist: result.dist, angle, power, facing };
          }
        }
      }
      const plan = { angle: best.angle, power: best.power, facing: best.facing };
      const memory = tank.solutionMemory[target.id];
      if (skill === 5) {
        if (tank.lastTargetId === target.id && memory) {
          plan.angle = clamp(memory.angle + (Math.random() - 0.5) * 2, 0, 180);
          plan.power = clamp(memory.power + (Math.random() - 0.5) * 3, 10, 120);
          plan.facing = memory.facing;
        } else {
          tank.solutionMemory[target.id] = { angle: best.angle, power: best.power, facing: best.facing };
          plan.angle = clamp(best.angle + (Math.random() - 0.5) * 10, 0, 180);
          plan.power = clamp(best.power + (Math.random() - 0.5) * 18, 10, 120);
        }
      } else {
        const accuracyTaper = Math.max(0, 5 - skill);
        plan.angle = clamp(plan.angle + (Math.random() - 0.5) * angleStep * (accuracyTaper * 0.6), 0, 180);
        plan.power = clamp(plan.power + (Math.random() - 0.5) * powerStep * (accuracyTaper * 1.1), 10, 120);
        if (skill >= 4) {
          tank.solutionMemory[target.id] = { angle: plan.angle, power: plan.power, facing: plan.facing };
        }
      }
      return plan;
    }

    function scheduleAiTurn(tank) {
      const baseDelay = 900 + Math.random() * 500;
      const scale = fastForwardActive ? 5 : 1;
      setTimeout(() => aiTakeTurn(tank), baseDelay / scale);
    }

    function aiTakeTurn(tank) {
      if (gameState !== 'aim' || currentPlayer !== tank || !tank.alive) return;
      const target = aiChooseTarget(tank);
      if (!target) {
        endTurn();
        return;
      }
      const weapon = aiChooseWeapon(tank, target);
      if (utilities[weapon]) {
        const used = useUtility(tank, weapon);
        if (used) {
          endTurn();
        } else {
          endTurn();
        }
        return;
      }
      const plan = aiPlanShot(tank, target, weapon);
      tank.facing = plan.facing;
      tank.angle = plan.angle;
      tank.power = plan.power;
      tank.lastTargetId = target.id;
      if (tank.inventory[weapon] !== Infinity && tank.inventory[weapon] > 0) {
        tank.inventory[weapon]--;
      }
      launchProjectile(tank, weapon);
    }

    function init() {
      ensureDefaultCommander();
      updateFastForwardState();
      setStatus('Configure opponents to begin the campaign.');
      requestAnimationFrame(loop);
    }

    init();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
