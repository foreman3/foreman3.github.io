<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Treasure Hunt Pinball</title>
  <style>
    :root {
      --bg: radial-gradient(circle at 15% 20%, #0a1223, #03050e 65%);
      --glass: rgba(255, 255, 255, 0.06);
      --frame: linear-gradient(180deg, rgba(120, 180, 255, 0.6), rgba(0, 140, 200, 0.28));
      --rail: linear-gradient(135deg, #3a2315 0%, #8a5a32 18%, #5c371e 42%, #2d1a12 100%);
      --gold: #ffdc73;
      --teal: #5ee2f8;
      --ink: #0b142d;
      --muted: #d9e6ff;
      --danger: #ff7e9c;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      grid-template-columns: 1fr 380px;
      gap: 18px;
      padding: 28px;
      background: var(--bg);
      color: #f3f6ff;
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
    }

    header {
      grid-column: 1 / -1;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 2.8rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      text-shadow: 0 0 30px rgba(120, 200, 255, 0.6);
    }

    p.lede {
      margin: 10px auto 0;
      max-width: 960px;
      color: #d3e4ff;
    }

    #main-card, #side-card {
      background: rgba(8, 16, 36, 0.8);
      border: 1px solid rgba(120, 200, 255, 0.3);
      border-radius: 18px;
      box-shadow: 0 0 28px rgba(0, 180, 255, 0.16);
    }

    #main-card {
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    #side-card {
      padding: 16px 16px 18px;
      display: grid;
      grid-template-rows: auto 1fr auto;
      gap: 12px;
    }

    canvas {
      position: relative;
      border-radius: 18px;
      width: 100%;
      height: 780px;
      border: 3px solid var(--frame);
      background: radial-gradient(circle at 55% 15%, rgba(255, 255, 255, 0.14), transparent 45%),
                  radial-gradient(circle at 55% 85%, rgba(65, 120, 255, 0.12), transparent 50%),
                  linear-gradient(135deg, #091024, #0c172e 35%, #0a1627 55%, #040913 100%);
      box-shadow:
        inset 0 0 40px rgba(0,0,0,0.6),
        inset 0 0 120px rgba(14, 24, 48, 0.85),
        0 0 34px rgba(0, 160, 255, 0.28);
    }

    #mini-overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(4, 6, 12, 0.8);
      backdrop-filter: blur(4px);
      visibility: hidden;
      opacity: 0;
      transition: opacity 0.35s ease, visibility 0.35s ease;
    }

    #mini-overlay.active { visibility: visible; opacity: 1; }

    #hud {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-weight: 700;
      color: var(--muted);
    }

    #hud .stat {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(120, 200, 255, 0.24);
      border-radius: 12px;
      padding: 10px 12px;
      display: grid;
      gap: 6px;
    }

    #quest-log h2, #gear h2, #controls h2 {
      margin: 0 0 8px;
      letter-spacing: 0.12em;
      color: var(--teal);
      text-transform: uppercase;
      font-size: 1rem;
    }

    #objective-list { list-style: none; padding: 0; margin: 0; display: grid; gap: 10px; }
    #objective-list li { padding: 8px 10px; border-radius: 10px; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05); }
    #objective-list li.complete { border-color: rgba(94, 226, 248, 0.6); color: #b2f2ff; }

    #gear ul { list-style: none; padding: 0; margin: 0; display: flex; flex-wrap: wrap; gap: 8px; }
    #gear li { padding: 6px 10px; border-radius: 12px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); }
    #gear li.owned { border-color: var(--gold); color: var(--gold); box-shadow: 0 0 10px rgba(255, 220, 115, 0.4); }

    #controls ul { list-style: none; padding: 0; margin: 0; display: grid; gap: 8px; color: #cdd8ff; }

    #message {
      margin: 0;
      text-align: center;
      font-size: 1.1rem;
      letter-spacing: 0.06em;
      color: var(--gold);
      text-shadow: 0 0 16px rgba(255, 200, 120, 0.5);
    }

    #actions { display: flex; gap: 10px; }

    button {
      border: 1px solid rgba(120, 200, 255, 0.35);
      background: linear-gradient(180deg, rgba(80, 140, 255, 0.6), rgba(40, 90, 200, 0.7));
      color: #f9fcff;
      padding: 10px 14px;
      border-radius: 12px;
      letter-spacing: 0.08em;
      cursor: pointer;
      font-weight: 700;
      text-transform: uppercase;
      box-shadow: 0 0 18px rgba(0, 160, 255, 0.35);
    }

    button.secondary { background: rgba(255, 255, 255, 0.04); color: #d4e0ff; }
    button:active { transform: translateY(1px); }

    .badge { font-size: 0.86em; letter-spacing: 0.1em; }
    .danger { color: var(--danger); }
  </style>
</head>
<body>
  <header>
    <h1>Treasure Hunt Pinball</h1>
    <p class="lede">Single-table adventure with fast multi-ball, spinning bookcase clues, and themed mini-table showdowns. Two treasures are playable now; three more are marked for the next expedition.</p>
  </header>

  <div id="main-card">
    <div id="hud">
      <div class="stat">
        <div class="badge">Score</div>
        <div id="score">0</div>
      </div>
      <div class="stat">
        <div class="badge">Balls</div>
        <div id="balls">3</div>
      </div>
      <div class="stat">
        <div class="badge">Combo</div>
        <div id="combo">x1.0</div>
      </div>
    </div>

    <div style="position: relative;">
      <canvas id="table" width="520" height="780" aria-label="Pinball table"></canvas>
      <div id="mini-overlay">
        <div style="text-align: center; color: #f8fbff;">
          <canvas id="mini" width="420" height="620" aria-label="Mini table"></canvas>
          <p id="mini-info" style="margin: 12px 0 0; letter-spacing: 0.1em;"></p>
        </div>
      </div>
    </div>

    <div id="actions">
      <button id="start">New Game</button>
      <button id="nudge" class="secondary">Nudge (Space)</button>
      <button id="fire" class="secondary">Launch (Enter)</button>
    </div>
    <p id="message">Plunge the ball to begin the hunt.</p>
  </div>

  <div id="side-card">
    <section id="quest-log">
      <h2>Current Mission</h2>
      <ul id="objective-list"></ul>
    </section>
    <section id="gear">
      <h2>Gear Collected</h2>
      <ul id="gear-list"></ul>
    </section>
    <section id="controls">
      <h2>Controls</h2>
      <ul>
        <li>Left / Right arrows or A / D to flip</li>
        <li>Enter to launch a ball</li>
        <li>Space to nudge the table</li>
        <li>Complete clues & items to reveal a mini table</li>
      </ul>
    </section>
  </div>

  <script>
    const table = document.getElementById('table');
    const ctx = table.getContext('2d');
    const mini = document.getElementById('mini');
    const mctx = mini.getContext('2d');
    const overlay = document.getElementById('mini-overlay');
    const scoreEl = document.getElementById('score');
    const ballsEl = document.getElementById('balls');
    const comboEl = document.getElementById('combo');
    const msgEl = document.getElementById('message');
    const objectivesEl = document.getElementById('objective-list');
    const gearEl = document.getElementById('gear-list');
    const miniInfo = document.getElementById('mini-info');

    const WIDTH = table.width;
    const HEIGHT = table.height;
    const gravity = 0.22;
    const friction = 0.995;

    const keys = { left: false, right: false };
    let balls = [];
    let score = 0;
    let ballsLeft = 3;
    let combo = 1;
    let activeMission = null;
    let missionQueue = [];
    let bookTargets = [];
    let rampGlow = 0;
    let tunnelOpen = false;
    let multiBallReady = false;
    let trapTimer = 0;
    let miniState = null;
    let globalTick = 0;

    const missions = [
      {
        id: 'pharaoh',
        name: "Pharaoh's Scepter",
        theme: 'Obsidian pyramid, sandfall lanes, and scarab drop targets.',
        requiredItems: ['Ancient Map', 'Sun Talisman'],
        treasure: "Pharaoh's Scepter",
        description: 'Knock down book clues, claim relics, open the obelisk tunnel, survive the pyramid mini table.',
        miniLayout: 'pyramid'
      },
      {
        id: 'neptune',
        name: "Neptune's Trident",
        theme: 'Bioluminescent currents with shell bumpers and whirlpool scoop.',
        requiredItems: ['Secret Journal', 'Pearl Compass'],
        treasure: "Neptune's Trident",
        description: 'Chart clues, grab oceanic tools, dive into the whirlpool mini table.',
        miniLayout: 'ocean'
      },
      { id: 'skyforge', name: 'Skyforge Relic', todo: true },
      { id: 'ember-heart', name: 'Heart of the Ember Dragon', todo: true },
      { id: 'aurora-crown', name: 'Crown of Aurora', todo: true }
    ];

    const gearPool = ['Ancient Map', 'Sun Talisman', 'Secret Journal', 'Pearl Compass', 'Obsidian Key', 'Silver Lens'];

    class Ball {
      constructor(x, y, speed = 12, miniMode = false) {
        const angle = (-Math.PI / 2) + (Math.random() * 0.2 - 0.1);
        this.x = x; this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.r = miniMode ? 6 : 7;
        this.alive = true;
        this.miniMode = miniMode;
      }
      update(obstacles, flippers) {
        if (!this.alive) return;
        this.vy += gravity * (this.miniMode ? 0.8 : 1);
        this.vx *= friction; this.vy *= friction;
        this.x += this.vx; this.y += this.vy;

        // walls
        if (this.x < this.r + 12) { this.x = this.r + 12; this.vx = Math.abs(this.vx) * 0.95; }
        if (this.x > WIDTH - this.r - 12) { this.x = WIDTH - this.r - 12; this.vx = -Math.abs(this.vx) * 0.95; }
        if (this.y < this.r + 10) { this.y = this.r + 10; this.vy = Math.abs(this.vy); }

        // drain
        if (!this.miniMode && this.y > HEIGHT + 30) { this.alive = false; }

        // obstacles
        obstacles.forEach(ob => ob.collide?.(this));
        // flippers
        flippers.forEach(f => f.collide(this));
      }
      draw(ctx) {
        if (!this.alive) return;
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 12;
        ctx.shadowOffsetY = 6;
        const grad = ctx.createRadialGradient(this.x - 6, this.y - 8, 1, this.x + 2, this.y + 2, 18);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.45, '#d9edff');
        grad.addColorStop(1, '#9fb8d6');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.6)';
        ctx.lineWidth = 1.2;
        ctx.stroke();
        ctx.restore();
      }
    }

    class Bumper {
      constructor(x, y, r, power = 1.1) { this.x = x; this.y = y; this.r = r; this.power = power; }
      collide(ball) {
        const dx = ball.x - this.x, dy = ball.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < this.r + ball.r) {
          const nx = dx / dist, ny = dy / dist;
          const dot = ball.vx * nx + ball.vy * ny;
          ball.vx -= 2 * dot * nx * this.power;
          ball.vy -= 2 * dot * ny * this.power;
          ball.x = this.x + (this.r + ball.r + 0.5) * nx;
          ball.y = this.y + (this.r + ball.r + 0.5) * ny;
          addScore(250 * this.power);
          combo += 0.02; updateCombo();
        }
      }
      draw(ctx) {
        const base = ctx.createRadialGradient(this.x - 10, this.y - 12, 2, this.x, this.y, this.r + 18);
        base.addColorStop(0, 'rgba(255, 255, 255, 0.15)');
        base.addColorStop(1, 'rgba(0,0,0,0.35)');
        ctx.fillStyle = base;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r + 8, 0, Math.PI * 2);
        ctx.fill();

        const grad = ctx.createRadialGradient(this.x - 6, this.y - 8, 3, this.x, this.y, this.r + 6);
        grad.addColorStop(0, '#fff7d7');
        grad.addColorStop(0.6, '#ffc568');
        grad.addColorStop(1, '#a85a14');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = 'rgba(255,255,255,0.75)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r - 5, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = 'rgba(30, 40, 80, 0.8)';
        ctx.beginPath();
        ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    class Target {
      constructor(x, y, w, h, onHit, color = '#72f7ff') {
        this.x = x; this.y = y; this.w = w; this.h = h; this.onHit = onHit; this.cool = 0; this.color = color;
      }
      collide(ball) {
        if (this.cool > 0) { this.cool--; return; }
        if (ball.x > this.x && ball.x < this.x + this.w && ball.y > this.y && ball.y < this.y + this.h) {
          this.onHit?.();
          this.cool = 12;
          ball.vy = -Math.abs(ball.vy) * 0.8;
          addScore(400);
          combo += 0.05; updateCombo();
        }
      }
      draw(ctx) {
        const grad = ctx.createLinearGradient(this.x, this.y, this.x, this.y + this.h);
        grad.addColorStop(0, 'rgba(255,255,255,0.65)');
        grad.addColorStop(0.28, this.color);
        grad.addColorStop(1, 'rgba(0,0,0,0.35)');
        ctx.fillStyle = grad;
        ctx.globalAlpha = this.cool > 0 ? 0.6 : 1;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.globalAlpha = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 2;
        ctx.strokeRect(this.x + 1, this.y + 1, this.w - 2, this.h - 2);
      }
    }

    class Spinner {
      constructor(x, y, r, onCycle) { this.x = x; this.y = y; this.r = r; this.angle = 0; this.onCycle = onCycle; }
      collide(ball) {
        const dx = ball.x - this.x, dy = ball.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist < this.r + ball.r) {
          const nx = dx / dist, ny = dy / dist;
          const dot = ball.vx * nx + ball.vy * ny;
          ball.vx -= 2 * dot * nx * 0.9;
          ball.vy -= 2 * dot * ny * 0.9;
          this.angle += 0.5;
          if (this.angle > Math.PI * 2) { this.angle = 0; this.onCycle?.(); }
          addScore(200);
        }
      }
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        const hub = ctx.createRadialGradient(0, 0, 0, 0, 0, this.r + 8);
        hub.addColorStop(0, 'rgba(255,255,255,0.9)');
        hub.addColorStop(1, 'rgba(90, 150, 255, 0.5)');
        ctx.strokeStyle = hub;
        ctx.lineWidth = 4.5;
        ctx.beginPath();
        ctx.moveTo(-this.r, 0); ctx.lineTo(this.r, 0);
        ctx.moveTo(0, -this.r); ctx.lineTo(0, this.r);
        ctx.stroke();

        ctx.fillStyle = 'rgba(20, 32, 66, 0.85)';
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    class Flipper {
      constructor(x, y, length, side) {
        this.x = x; this.y = y; this.length = length; this.side = side; this.angle = side === 'left' ? -0.4 : Math.PI + 0.4;
        this.activeAngle = side === 'left' ? -1.1 : Math.PI + 1.1;
      }
      collide(ball) {
        const ang = this.angle;
        const cos = Math.cos(ang), sin = Math.sin(ang);
        const fx = this.x + cos * this.length;
        const fy = this.y + sin * this.length;
        const dist = pointToSegment(ball.x, ball.y, this.x, this.y, fx, fy);
        if (dist < ball.r + 4 && ball.y > this.y - 40) {
          const dir = this.side === 'left' ? -1 : 1;
          ball.vx = (ball.vx + dir * 9) * 0.8;
          ball.vy = -Math.abs(ball.vy) * 0.3 - 9;
          addScore(150);
        }
      }
      draw(ctx, pressed) {
        this.angle = lerp(this.angle, pressed ? this.activeAngle : (this.side === 'left' ? -0.4 : Math.PI + 0.4), 0.35);
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        const grad = ctx.createLinearGradient(0, 0, this.length, 0);
        grad.addColorStop(0, '#fff'); grad.addColorStop(1, '#8ab6ff');
        ctx.fillStyle = grad;
        ctx.strokeStyle = '#3a74ff';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.roundRect(0, -8, this.length, 16, 10);
        ctx.fill(); ctx.stroke();
        ctx.restore();
      }
    }

    class Ramp {
      constructor(path, onHit) { this.path = path; this.onHit = onHit; }
      draw(ctx) {
        ctx.save();
        ctx.lineWidth = 8;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'rgba(12, 18, 30, 0.65)';
        ctx.beginPath();
        ctx.moveTo(this.path[0].x, this.path[0].y + 3);
        for (let i = 1; i < this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y + 3);
        ctx.stroke();

        const rail = ctx.createLinearGradient(this.path[0].x, this.path[0].y, this.path[this.path.length-1].x, this.path[this.path.length-1].y);
        rail.addColorStop(0, `rgba(255, 230, 180, ${0.42 + rampGlow})`);
        rail.addColorStop(1, `rgba(120, 200, 255, ${0.5 + rampGlow})`);
        ctx.lineWidth = 6;
        ctx.strokeStyle = rail;
        ctx.beginPath();
        ctx.moveTo(this.path[0].x, this.path[0].y);
        for (let i = 1; i < this.path.length; i++) ctx.lineTo(this.path[i].x, this.path[i].y);
        ctx.stroke();
        ctx.restore();
      }
      collide(ball) {
        for (let i = 0; i < this.path.length - 1; i++) {
          const p1 = this.path[i], p2 = this.path[i + 1];
          const dist = pointToSegment(ball.x, ball.y, p1.x, p1.y, p2.x, p2.y);
          if (dist < ball.r + 2 && ball.vy > 0) {
            ball.vy = -Math.abs(ball.vy) - 2;
            ball.vx += (Math.random() - 0.5) * 2;
            this.onHit?.();
            addScore(600);
            combo += 0.1; updateCombo();
            break;
          }
        }
      }
    }

    const leftFlipper = new Flipper(200, HEIGHT - 90, 90, 'left');
    const rightFlipper = new Flipper(WIDTH - 200, HEIGHT - 90, 90, 'right');

    const bumpers = [
      new Bumper(160, 200, 24, 1.1),
      new Bumper(360, 210, 24, 1.1),
      new Bumper(260, 320, 26, 1.2),
    ];

    const spinner = new Spinner(260, 150, 32, () => {
      addScore(800);
      addClue();
    });

    const ramp = new Ramp([
      { x: WIDTH - 120, y: HEIGHT - 180 },
      { x: WIDTH - 60, y: HEIGHT - 420 },
      { x: WIDTH - 140, y: HEIGHT - 620 }
    ], () => {
      rampGlow = 0.6;
      if (activeMission && activeMission.itemsUnlocked < activeMission.requiredItems.length && cluesFound >= activeMission.clueTarget) {
        const item = activeMission.requiredItems[activeMission.itemsUnlocked];
        activeMission.itemsUnlocked++;
        addGear(item);
        toast(`Found ${item}!`);
        refreshObjectives();
      }
      if (activeMission && activeMission.itemsUnlocked >= activeMission.requiredItems.length && cluesFound >= activeMission.clueTarget) {
        tunnelOpen = true;
      }
    });

    const tunnel = new Target(WIDTH - 190, HEIGHT - 500, 90, 32, () => {
      if (activeMission && tunnelOpen) {
        startMini(activeMission);
      }
    }, 'rgba(120, 255, 200, 0.7)');

    const multiTrap = new Target(40, HEIGHT - 200, 52, 60, () => {
      trapTimer = 120;
      multiBallReady = true;
      toast('Ball locked! Multiball ready.');
    }, 'rgba(255, 120, 200, 0.6)');

    function buildBookTargets() {
      bookTargets = [];
      for (let i = 0; i < 3; i++) {
        const bt = new Target(80 + i * 48, 120 + i * 10, 28, 46, () => {
          addScore(500);
          bookTargets[i].down = !bookTargets[i].down;
          if (bookTargets.every(t => t.down)) {
            bookTargets.forEach(t => t.down = false);
            addClue();
          }
        }, '#8cf');
        bt.down = false;
        bookTargets.push(bt);
      }
    }

    const wallTargets = [
      new Target(40, 70, WIDTH - 80, 10, () => {}, 'rgba(255,255,255,0.05)'),
    ];

    function addScore(v) { score = Math.floor(score + v * combo); scoreEl.textContent = score.toLocaleString(); }
    function updateCombo() { combo = Math.min(5, combo); comboEl.textContent = `x${combo.toFixed(1)}`; }
    function toast(text) { msgEl.textContent = text; }

    let cluesFound = 0;
    function addClue() {
      if (!activeMission) return;
      cluesFound++;
      toast(`Clue ${cluesFound}/${activeMission.clueTarget}`);
      if (cluesFound >= activeMission.clueTarget) {
        toast('Clues complete! Shoot ramp for items.');
      }
      refreshObjectives();
    }

    function addGear(item) {
      if (!activeMission) return;
      activeMission.items = activeMission.items || [];
      if (!activeMission.items.includes(item)) {
        activeMission.items.push(item);
      }
      renderGear();
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function startGame() {
      score = 0; combo = 1; ballsLeft = 3; balls = []; tunnelOpen = false; rampGlow = 0;
      missionQueue = shuffle(missions.slice(0));
      activeMission = nextMission();
      cluesFound = 0;
      rampGlow = 0;
      multiBallReady = false;
      trapTimer = 0;
      buildBookTargets();
      renderGear();
      refreshObjectives();
      toast('Launch the ball and chase clues!');
      addBall();
      updateStats();
    }

    function nextMission() {
      const m = missionQueue.find(ms => !ms.todo);
      if (!m) return null;
      m.itemsUnlocked = 0;
      m.items = [];
      m.clueTarget = 3 + Math.floor(Math.random() * 4);
      return m;
    }

    function addBall(yOffset = 0, miniMode = false) {
      balls.push(new Ball(WIDTH - 40, HEIGHT - 120 + yOffset, miniMode ? 9 : 12, miniMode));
      updateStats();
    }

    function updateStats() {
      ballsEl.textContent = ballsLeft;
      comboEl.textContent = `x${combo.toFixed(1)}`;
    }

    function refreshObjectives() {
      objectivesEl.innerHTML = '';
      if (!activeMission) {
        const li = document.createElement('li');
        li.textContent = 'All treasures claimed. TODO: add the remaining three relics.';
        objectivesEl.appendChild(li);
        return;
      }
      const stages = [
        `Collect ${activeMission.clueTarget} clues by toppling the spinning bookcase targets and spinner (clues: ${cluesFound}/${activeMission.clueTarget}).`,
        `Shoot the golden ramp to claim items (${(activeMission.items||[]).length}/${activeMission.requiredItems.length}): ${activeMission.requiredItems.join(', ')}.`,
        `Open the secret tunnel by the upper right orbit, then shoot it to enter the ${activeMission.name} mini table.`
      ];
      stages.forEach((text, i) => {
        const li = document.createElement('li');
        li.textContent = text;
        if ((i === 0 && cluesFound >= activeMission.clueTarget) ||
            (i === 1 && (activeMission.items||[]).length >= activeMission.requiredItems.length) ||
            (i === 2 && tunnelOpen)) {
          li.classList.add('complete');
        }
        objectivesEl.appendChild(li);
      });
      if (missionQueue.some(m => m.todo)) {
        const li = document.createElement('li');
        li.textContent = 'TODO: Add three more treasures with their own mini tables.';
        objectivesEl.appendChild(li);
      }
    }

    function renderGear() {
      gearEl.innerHTML = '';
      gearPool.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        if (activeMission && activeMission.items?.includes(item)) li.classList.add('owned');
        gearEl.appendChild(li);
      });
    }

    function pointToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1, dy = y2 - y1;
      const len2 = dx*dx + dy*dy;
      let t = ((px - x1) * dx + (py - y1) * dy) / len2;
      t = Math.max(0, Math.min(1, t));
      const projx = x1 + t * dx, projy = y1 + t * dy;
      const dist = Math.hypot(px - projx, py - projy);
      return dist;
    }

    function lerp(a, b, t) { return a + (b - a) * t; }

    function drawTable() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawPlayfieldBase();
      drawRails();
      drawApronAndPlunger();
      drawLanes();
      drawLightWells();

      bumpers.forEach(b => b.draw(ctx));
      spinner.draw(ctx);
      bookTargets.forEach(t => { ctx.save(); ctx.globalAlpha = t.down ? 0.4 : 1; t.draw(ctx); ctx.restore(); });
      ramp.draw(ctx);
      tunnel.draw(ctx);
      multiTrap.draw(ctx);
      wallTargets.forEach(t => t.draw(ctx));
      drawKickback();
      drawLabels();
      leftFlipper.draw(ctx, keys.left);
      rightFlipper.draw(ctx, keys.right);
      balls.forEach(b => b.draw(ctx));
    }

    function drawPlayfieldBase() {
      const playfield = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      playfield.addColorStop(0, 'rgba(34, 48, 76, 0.95)');
      playfield.addColorStop(0.35, 'rgba(28, 40, 64, 0.94)');
      playfield.addColorStop(1, 'rgba(24, 30, 52, 0.96)');
      ctx.fillStyle = playfield;
      ctx.fillRect(10, 10, WIDTH - 20, HEIGHT - 20);

      const vignette = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, 80, WIDTH/2, HEIGHT/2, 380);
      vignette.addColorStop(0, 'rgba(255,255,255,0)');
      vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      const grain = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
      grain.addColorStop(0, 'rgba(255,255,255,0.05)');
      grain.addColorStop(1, 'rgba(255,255,255,0.01)');
      ctx.fillStyle = grain;
      ctx.globalAlpha = 0.12;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      ctx.globalAlpha = 1;
    }

    function drawRails() {
      ctx.save();
      ctx.lineWidth = 18;
      const railGrad = ctx.createLinearGradient(0, 0, WIDTH, HEIGHT);
      railGrad.addColorStop(0, '#4d301c');
      railGrad.addColorStop(0.5, '#8a5d34');
      railGrad.addColorStop(1, '#402513');
      ctx.strokeStyle = railGrad;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(26, 26); ctx.lineTo(26, HEIGHT - 70); ctx.quadraticCurveTo(26, HEIGHT - 20, 70, HEIGHT - 20); ctx.lineTo(WIDTH - 70, HEIGHT - 20); ctx.quadraticCurveTo(WIDTH - 20, HEIGHT - 20, WIDTH - 20, HEIGHT - 70); ctx.lineTo(WIDTH - 20, 26); ctx.quadraticCurveTo(WIDTH - 20, 26, WIDTH - 40, 26); ctx.lineTo(40, 26);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(40, 60); ctx.lineTo(40, HEIGHT - 120);
      ctx.moveTo(WIDTH - 40, 60); ctx.lineTo(WIDTH - 40, HEIGHT - 240);
      ctx.stroke();
      ctx.restore();
    }

    function drawApronAndPlunger() {
      const apron = ctx.createLinearGradient(0, HEIGHT - 200, 0, HEIGHT);
      apron.addColorStop(0, 'rgba(18, 26, 40, 0.4)');
      apron.addColorStop(1, 'rgba(16, 18, 28, 0.85)');
      ctx.fillStyle = apron;
      ctx.fillRect(10, HEIGHT - 170, WIDTH - 20, 180);

      ctx.fillStyle = 'rgba(255, 219, 137, 0.08)';
      ctx.fillRect(WIDTH - 90, HEIGHT - 200, 70, 180);

      ctx.strokeStyle = 'rgba(255,255,255,0.15)';
      ctx.lineWidth = 2;
      ctx.strokeRect(WIDTH - 94, HEIGHT - 205, 78, 190);
    }

    function drawLanes() {
      ctx.save();
      ctx.lineWidth = 4;
      const laneGlow = ctx.createLinearGradient(0, 0, 0, HEIGHT);
      laneGlow.addColorStop(0, 'rgba(120, 200, 255, 0.4)');
      laneGlow.addColorStop(1, 'rgba(255, 225, 180, 0.4)');
      ctx.strokeStyle = laneGlow;
      ctx.beginPath();
      ctx.moveTo(70, 60); ctx.lineTo(70, HEIGHT - 190);
      ctx.moveTo(WIDTH - 70, 60); ctx.lineTo(WIDTH - 70, HEIGHT - 260);
      ctx.stroke();
      ctx.restore();
    }

    function drawLightWells() {
      const wells = [
        { x: 120, y: HEIGHT - 260 },
        { x: WIDTH - 120, y: HEIGHT - 260 },
        { x: WIDTH/2, y: 120 }
      ];
      wells.forEach(w => {
        const glow = ctx.createRadialGradient(w.x, w.y, 10, w.x, w.y, 90);
        glow.addColorStop(0, 'rgba(255, 240, 170, 0.35)');
        glow.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = glow;
        ctx.fillRect(w.x - 90, w.y - 90, 180, 180);
      });
    }

    function drawKickback() {
      ctx.save();
      ctx.translate(30, HEIGHT - 140);
      ctx.fillStyle = 'rgba(120, 255, 220, 0.25)';
      ctx.beginPath();
      ctx.moveTo(0, 60); ctx.lineTo(40, 10); ctx.lineTo(70, 0); ctx.lineTo(70, 70); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawLabels() {
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '12px "Inter"';
      ctx.fillText('Bookcase Clues', 70, 110);
      ctx.fillText('Spinner', 240, 100);
      ctx.fillText('Ramp Items', WIDTH - 160, HEIGHT - 190);
      ctx.fillText('Secret Tunnel', WIDTH - 200, HEIGHT - 520);
      ctx.fillText('Trap -> Multiball', 22, HEIGHT - 210);
    }

    function update() {
      globalTick++;
      rampGlow = Math.max(0, rampGlow - 0.01);
      if (trapTimer > 0) {
        trapTimer--;
        if (trapTimer === 0 && multiBallReady) {
          addBall(-30);
          multiBallReady = false;
          toast('Multiball released!');
        }
      }

      const obstacles = [...bumpers, spinner, ...bookTargets, ramp, tunnel, multiTrap, ...wallTargets];
      const flippers = [leftFlipper, rightFlipper];
      balls.forEach(b => b.update(obstacles, flippers));
      balls = balls.filter(b => b.alive);

      if (balls.length === 0 && ballsLeft > 0 && !miniState) {
        ballsLeft--;
        combo = 1;
        updateStats();
        if (ballsLeft >= 0) {
          addBall();
          toast('New ball!');
        }
      }

      drawTable();
      requestAnimationFrame(update);
    }

    function startMini(mission) {
      overlay.classList.add('active');
      miniState = { mission, success: false };
      miniInfo.textContent = `${mission.name}: ${mission.theme}`;
      mctx.clearRect(0, 0, mini.width, mini.height);
      miniBalls = [new Ball(mini.width/2, mini.height - 80, 10, true)];
      miniLoop();
    }

    let miniBalls = [];
    const miniFlippers = [new Flipper(150, mini.height - 70, 70, 'left'), new Flipper(mini.width - 150, mini.height - 70, 70, 'right')];

    function miniObstacles(layout) {
      if (layout === 'pyramid') {
        return [
          new Bumper(150, 180, 18, 1.2),
          new Bumper(270, 220, 18, 1.1),
          new Target(110, mini.height - 220, 200, 16, () => { endMini(true); }, 'rgba(255, 220, 120, 0.8)')
        ];
      }
      if (layout === 'ocean') {
        return [
          new Bumper(120, 170, 16, 1.3),
          new Bumper(300, 200, 16, 1.3),
          new Target(140, mini.height - 260, 160, 18, () => { endMini(true); }, 'rgba(120, 240, 255, 0.9)')
        ];
      }
      return [];
    }

    function drawMini(layout) {
      mctx.clearRect(0, 0, mini.width, mini.height);
      const grad = mctx.createLinearGradient(0, 0, 0, mini.height);
      grad.addColorStop(0, layout === 'pyramid' ? '#2b1a12' : '#041d2e');
      grad.addColorStop(1, layout === 'pyramid' ? '#5a3a1d' : '#073a48');
      mctx.fillStyle = grad;
      mctx.fillRect(0, 0, mini.width, mini.height);
      miniObstacles(layout).forEach(o => o.draw(mctx));
      miniFlippers.forEach(f => f.draw(mctx, keys.left && f.side==='left' || keys.right && f.side==='right'));
      miniBalls.forEach(b => b.draw(mctx));
      mctx.fillStyle = 'rgba(255,255,255,0.7)';
      mctx.font = '14px "Inter"';
      mctx.fillText('Hit the glowing lane to claim the treasure!', 70, 24);
    }

    function miniLoop() {
      if (!miniState) return;
      const layout = miniState.mission.miniLayout;
      const obstacles = miniObstacles(layout);
      miniBalls.forEach(b => b.update(obstacles, miniFlippers));
      miniBalls = miniBalls.filter(b => b.alive && b.y < mini.height + 40);
      drawMini(layout);
      if (miniBalls.length === 0) {
        endMini(false);
        return;
      }
      requestAnimationFrame(miniLoop);
    }

    function endMini(success) {
      if (!miniState) return;
      overlay.classList.remove('active');
      if (success) {
        addScore(5000);
        toast(`${miniState.mission.treasure} recovered!`);
      } else {
        toast('Mini table failed. Gather clues again.');
      }
      activeMission = nextMission();
      if (activeMission) {
        cluesFound = 0;
        tunnelOpen = false;
        activeMission.itemsUnlocked = 0;
        activeMission.items = [];
      }
      refreshObjectives();
      renderGear();
      miniState = null;
    }

    document.getElementById('start').addEventListener('click', startGame);
    document.getElementById('fire').addEventListener('click', () => { addBall(); });
    document.getElementById('nudge').addEventListener('click', () => { balls.forEach(b => { b.vx += (Math.random() - 0.5) * 6; }); });

    window.addEventListener('keydown', (e) => {
      if (['ArrowLeft', 'a', 'A'].includes(e.key)) keys.left = true;
      if (['ArrowRight', 'd', 'D'].includes(e.key)) keys.right = true;
      if (e.key === 'Enter') addBall();
      if (e.code === 'Space') balls.forEach(b => b.vx += (Math.random() - 0.5) * 6);
    });
    window.addEventListener('keyup', (e) => {
      if (['ArrowLeft', 'a', 'A'].includes(e.key)) keys.left = false;
      if (['ArrowRight', 'd', 'D'].includes(e.key)) keys.right = false;
    });

    startGame();
    update();
  </script>
</body>
</html>
