<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Joust</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: linear-gradient(135deg, #ff9966 0%, #ff5e62 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #sidebar li {
      margin: 15px 0;
    }
    #sidebar a {
      color: #fff;
      text-decoration: none;
      transition: color 0.3s;
    }
    #sidebar a:hover {
      color: #ffea00;
    }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      margin-top: 0;
      font-size: 3em;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }
    canvas {
      background: rgba(0,0,0,0.6);
      border: 2px solid #fff;
      margin-top: 20px;
      border-radius: 8px;
    }
    #info {
      margin-top: 10px;
      font-size: 20px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
    #message {
      margin-top: 10px;
      font-size: 24px;
      color: #ff3333;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Joust</h1>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    <div id="info">Lives: 3 | Stage: 1</div>
    <div id="message"></div>
  </div>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const GRAVITY = 0.3;
  const FLAP_FORCE = GRAVITY * 1.5; // force per flap
  const FLAP_DURATION = 0.3; // seconds
  const HORIZ_SPEED = 3;
  const BIRD_RADIUS = 12;
  const KNIGHT_HEIGHT = 10;

  const GROUND_Y = canvas.height - 30; // just above lava
  const ROOF_HEIGHT = 30; // roof thickness

  const playerImg = new Image();
  playerImg.src = 'images/player_knight.svg';
  const enemyImg = new Image();
  enemyImg.src = 'images/enemy_knight.svg';

  let keys = { left:false, right:false, up:false };
  let upHeld = false;
  let spikes = [];
  let stagePause = 0; // frames to pause with stage text

  document.addEventListener('keydown', e => {
    if(e.key==='ArrowLeft' || e.key==='a') keys.left = true;
    if(e.key==='ArrowRight' || e.key==='d') keys.right = true;
    if((e.key==='ArrowUp' || e.key==='w') && !upHeld){
      keys.up = true;
      upHeld = true;
      const dir = keys.left ? -1 : (keys.right ? 1 : 0);
      if(player){
        const currentForce = player.flaps.reduce((s,f)=>s+f.force,0);
        let force = FLAP_FORCE;
        if(player.vy < 0 && currentForce>0){
          const boost = Math.min(FLAP_FORCE, currentForce * 0.2);
          force = boost;
        }
        player.flaps.push({time:FLAP_DURATION, dir, force});
      }
    }
  });
  document.addEventListener('keyup', e => {
    if(e.key==='ArrowLeft' || e.key==='a') keys.left = false;
    if(e.key==='ArrowRight' || e.key==='d') keys.right = false;
    if(e.key==='ArrowUp' || e.key==='w') { keys.up = false; upHeld = false; }
  });

  function createPlatforms() {
    const plats = [];
    const num = 5;
    for(let i=0;i<num;i++){
      const width = 100 + Math.random()*80;
      const x = Math.random()*(canvas.width-width);
      const y = 150 + Math.random()*400; // expanded range for taller field
      plats.push({x,y,width,height:10});
    }
    return plats;
  }

  function createSpikes(){
    spikes = [];
    if(stage < 3) return;
    // spikes along the roof
    const roofCount = Math.min(stage, 6);
    const spacing = canvas.width / roofCount;
    for(let i=0;i<roofCount;i++){
      spikes.push({x:i*spacing + spacing/2 - 10, y:ROOF_HEIGHT, width:20, height:20});
    }
    if(stage > 3){
      for(const p of platforms){
        const count = Math.min(2, stage-3);
        for(let i=0;i<count;i++){
          const sx = p.x + Math.random()*(p.width-20);
          spikes.push({x:sx, y:p.y, width:20, height:20});
        }
      }
    }
  }

  let platforms = createPlatforms();

  class Knight {
    constructor(x,y,isPlayer=false){
      this.x=x; this.y=y; this.vx=0; this.vy=0;
      this.isPlayer=isPlayer; this.alive=true; this.spawnTime=Date.now();
      this.flaps=[];
      if(!isPlayer){
        this.mode='attack';
        this.modeTimer=stage;
        this.restDir=Math.random()<0.5?1:-1;
      }
    }
    update(){
      if(this.isPlayer){
        if(keys.left) this.vx = -HORIZ_SPEED; else if(keys.right) this.vx = HORIZ_SPEED; else this.vx=0;
      } else {
        const speed = 1 + 0.5*(stage-1); // enemies get faster each stage
        let dir = Math.sign(player.x - this.x);
        if(stage >= 3){
          if(this.mode === 'attack'){
            this.modeTimer -= 1/60;
            if(this.y > player.y){
              const flapChance = (stage >= 3 ? 0.15 : 0.01 * stage) * stage;
              if(Math.random() < flapChance){
                this.flaps.push({time:FLAP_DURATION, dir, force:FLAP_FORCE});
              }
              this.vx = dir * speed;
            } else {
              this.vy += GRAVITY * 0.4; // swoop down
              let attackSpeedBonus = stage >= 4 ? 1 : 0.5; // staged curve
              this.vx = dir * (speed + attackSpeedBonus);
            }
            if(this.modeTimer <= 0){
              this.mode = 'rest';
              const restMax = Math.max(1, 10 - stage);
              this.modeTimer = Math.random() * restMax;
              this.restDir = Math.random() < 0.5 ? 1 : -1;
            }
          } else {
            this.modeTimer -= 1/60;
            this.vx = this.restDir * speed;
            if(this.modeTimer <= 0){
              this.mode = 'attack';
              this.modeTimer = stage;
            }
          }
        } else {
          if(stage >= 2 && this.y > player.y){
            dir *= -1; // avoid player when lower
          }
          this.vx = dir * speed;
          const flapChance = 0.01 * stage; // aggressiveness
          if(player.y < this.y && Math.random() < flapChance){
            this.flaps.push({time:FLAP_DURATION, dir, force:FLAP_FORCE});
          }
        }
      }

      let ax = 0;
      let ay = GRAVITY;
      for(let i=this.flaps.length-1;i>=0;i--){
        const f = this.flaps[i];
        const force = f.force ?? FLAP_FORCE;
        if(f.dir===0){
          ay -= force;
        }else{
          ay -= force*0.8; // reduced upward force when moving horizontally
          ax += f.dir*(force*0.5); // horizontal is half of upward
        }
        f.time -= 1/60;
        if(f.time<=0) this.flaps.splice(i,1);
      }

      this.vx += ax;
      this.vy += ay;

      const prevX=this.x, prevY=this.y;
      this.x += this.vx;
      this.y += this.vy;

      if(this.x < BIRD_RADIUS){ this.x=BIRD_RADIUS; this.vx=0; }
      if(this.x > canvas.width-BIRD_RADIUS){ this.x=canvas.width-BIRD_RADIUS; this.vx=0; }
      if(this.y < ROOF_HEIGHT + BIRD_RADIUS){ this.y = ROOF_HEIGHT + BIRD_RADIUS; if(this.vy < 0) this.vy = 0; }

      let onGround=false;
      if(this.y > GROUND_Y-BIRD_RADIUS){
        this.y = GROUND_Y-BIRD_RADIUS;
        this.vy = 0;
        onGround=true;
      }

      for(const p of platforms){
        if(this.x > p.x-BIRD_RADIUS && this.x < p.x+p.width+BIRD_RADIUS &&
           this.y+BIRD_RADIUS > p.y && this.y-BIRD_RADIUS < p.y+p.height){
          if(prevY + BIRD_RADIUS <= p.y){
            if(this.vy >= 0){
              this.y = p.y - BIRD_RADIUS;
              this.vy = 0; onGround=true;
            }
          } else if(prevY - BIRD_RADIUS >= p.y + p.height){
            this.y = p.y + p.height + BIRD_RADIUS;
            if(this.vy<0) this.vy=0;
          } else if(prevX < p.x){
            this.x = p.x - BIRD_RADIUS; this.vx=0;
          } else if(prevX > p.x + p.width){
            this.x = p.x + p.width + BIRD_RADIUS; this.vx=0;
          }
        }
      }
    }
    draw(){
      const img = this.isPlayer ? playerImg : enemyImg;
      ctx.drawImage(img,this.x-16,this.y-32,32,32);
    }
  }

  let player = new Knight(canvas.width/2,GROUND_Y-BIRD_RADIUS,true);
  let lives = 3;
  let stage = 1;
  let enemies = [];
  let effects = [];
  let totalToSpawn = 3;
  let spawned = 0;
  let nextSpawn = 0;

  function startStage(){
    platforms = createPlatforms();
    createSpikes();
    enemies=[]; spawned=0; nextSpawn=0;
    totalToSpawn = 3 + (stage-1)*2;
    const immediate = 1 + (stage-1);
    for(let i=0;i<immediate && spawned<totalToSpawn;i++){ spawnEnemy(); }
    stagePause = 120; // display stage text for 2 seconds
  }

  function spawnEnemy(){
    if(spawned>=totalToSpawn) return;
    const x = Math.random()*(canvas.width-40)+20;
    enemies.push(new Knight(x,GROUND_Y-BIRD_RADIUS));
    spawned++;
  }

  function scheduleSpawn(){
    if(spawned < totalToSpawn) {
      nextSpawn = Date.now() + 1000;
    }
  }

  function resetPlayer(){
    player = new Knight(canvas.width/2,GROUND_Y-BIRD_RADIUS,true);
  }

  function createEffect(x,y){
    effects.push({x,y,r:0,alpha:1});
  }

  function updateEffects(){
    for(let i=effects.length-1;i>=0;i--){
      const ef=effects[i];
      ef.r+=2;
      ef.alpha-=0.04;
      if(ef.alpha<=0) effects.splice(i,1);
    }
  }

  function drawEffects(){
    for(const ef of effects){
      ctx.save();
      ctx.globalAlpha=ef.alpha;
      ctx.strokeStyle='yellow';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(ef.x,ef.y,ef.r,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function checkSpikeHits(){
    const all=[player,...enemies];
    for(const k of all){
      for(const s of spikes){
        if(k.x > s.x - BIRD_RADIUS && k.x < s.x + s.width + BIRD_RADIUS &&
           k.y - BIRD_RADIUS < s.y + s.height && k.y + BIRD_RADIUS > s.y){
          if(k.isPlayer){
            lives--;
            if(lives<=0){
              document.getElementById('message').textContent='Game Over';
              running=false;
            } else {
              resetPlayer();
            }
          } else {
            const idx=enemies.indexOf(k);
            if(idx>=0){
              enemies.splice(idx,1);
              scheduleSpawn();
            }
          }
          createEffect(k.x,k.y);
          break;
        }
      }
    }
  }

  function checkCollisions(){
    const all=[player,...enemies];
    for(let i=0;i<all.length;i++){
      for(let j=i+1;j<all.length;j++){
        const a=all[i], b=all[j];
        if(!a.alive || !b.alive) continue;
        const dx=a.x-b.x;
        const dy=a.y-b.y;
        if(Math.hypot(dx,dy) < BIRD_RADIUS*2){
          const diff=a.y-b.y;
          if(Math.abs(diff) > 2){
            const lower = diff>0 ? a : b;
            const higher = diff>0 ? b : a;
            if(lower.isPlayer){
              lives--;
              if(lives<=0){
                document.getElementById('message').textContent='Game Over';
                running=false;
              } else {
                resetPlayer();
              }
            }
            if(lower!==player){
              const idx=enemies.indexOf(lower);
              if(idx>=0){
                enemies.splice(idx,1);
                scheduleSpawn();
              }
            }
            createEffect(lower.x,lower.y);
          } else {
            const tempVy=a.vy;
            a.vy=-Math.abs(b.vy);
            b.vy=-Math.abs(tempVy);
          }
        }
      }
    }
  }

  let running=true;
  startStage();

  function update(){
    if(!running) return;
    if(stagePause>0){
      stagePause--;
      document.getElementById('info').textContent=`Lives: ${lives} | Stage: ${stage}`;
      return;
    }
    if(nextSpawn && Date.now()>nextSpawn){
      spawnEnemy();
      nextSpawn=0;
    }
    player.update();
    enemies.forEach(e=>e.update());
    updateEffects();
    checkCollisions();
    checkSpikeHits();
    if(spawned>=totalToSpawn && enemies.length===0){
      stage++; lives=3; resetPlayer(); startStage();
      return;
    }
    if(player.y > canvas.height+50){
      lives--; if(lives<=0){
        document.getElementById('message').textContent='Game Over';
        running=false;
      } else resetPlayer();
    }
    const beforeLen = enemies.length;
    enemies = enemies.filter(e=>e.y<canvas.height+50);
    if(enemies.length < beforeLen) scheduleSpawn();
    document.getElementById('info').textContent=`Lives: ${lives} | Stage: ${stage}`;
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // lava
    ctx.fillStyle = '#ff3300';
    ctx.fillRect(0,canvas.height-20,canvas.width,20);
    // roof
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0,0,canvas.width,ROOF_HEIGHT);
    // ground
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0,GROUND_Y,canvas.width,10);
    // platforms
    ctx.fillStyle = '#654321';
    for(const p of platforms){
      ctx.fillRect(p.x,p.y,p.width,p.height);
    }
    // spikes
    ctx.fillStyle = 'grey';
    for(const s of spikes){
      ctx.beginPath();
      ctx.moveTo(s.x, s.y);
      ctx.lineTo(s.x + s.width/2, s.y + s.height);
      ctx.lineTo(s.x + s.width, s.y);
      ctx.closePath();
      ctx.fill();
    }
    player.draw();
    enemies.forEach(e=>e.draw());
    drawEffects();
    if(stagePause>0){
      ctx.fillStyle='gold';
      ctx.font='bold 72px sans-serif';
      ctx.textAlign='center';
      ctx.fillText(`Stage ${stage}`, canvas.width/2, canvas.height/2);
    }
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if(placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
