<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Joust</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: linear-gradient(135deg, #ff9966 0%, #ff5e62 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #sidebar li {
      margin: 15px 0;
    }
    #sidebar a {
      color: #fff;
      text-decoration: none;
      transition: color 0.3s;
    }
    #sidebar a:hover {
      color: #ffea00;
    }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      margin-top: 0;
      font-size: 3em;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }
    canvas {
      background: rgba(0,0,0,0.6);
      border: 2px solid #fff;
      margin-top: 20px;
      border-radius: 8px;
    }
    #info {
      margin-top: 10px;
      font-size: 20px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
    #message {
      margin-top: 10px;
      font-size: 24px;
      color: #ff3333;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Joust</h1>
    <canvas id="gameCanvas" width="1200" height="800"></canvas>
    <div id="info">Lives: 3 | Stage: 1</div>
    <div id="message"></div>
  </div>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const GRAVITY = 0.3;
  const FLAP_FORCE = GRAVITY * 1.5; // force per flap
  const FLAP_DURATION = 0.3; // seconds
  const HORIZ_SPEED = 3;
  const BIRD_RADIUS = 12;
  const KNIGHT_HEIGHT = 10;

  const GROUND_Y = canvas.height - 30; // just above lava

  const playerImg = new Image();
  playerImg.src = 'images/player_knight.svg';
  const enemyImg = new Image();
  enemyImg.src = 'images/enemy_knight.svg';

  let keys = { left:false, right:false, up:false };
  let upHeld = false;

  document.addEventListener('keydown', e => {
    if(e.key==='ArrowLeft' || e.key==='a') keys.left = true;
    if(e.key==='ArrowRight' || e.key==='d') keys.right = true;
    if((e.key==='ArrowUp' || e.key==='w') && !upHeld){
      keys.up = true;
      upHeld = true;
      const dir = keys.left ? -1 : (keys.right ? 1 : 0);
      if(player) player.flaps.push({time:FLAP_DURATION, dir});
    }
  });
  document.addEventListener('keyup', e => {
    if(e.key==='ArrowLeft' || e.key==='a') keys.left = false;
    if(e.key==='ArrowRight' || e.key==='d') keys.right = false;
    if(e.key==='ArrowUp' || e.key==='w') { keys.up = false; upHeld = false; }
  });

  function createPlatforms() {
    const plats = [];
    const num = 5;
    for(let i=0;i<num;i++){
      const width = 100 + Math.random()*80;
      const x = Math.random()*(canvas.width-width);
      const y = 150 + Math.random()*400; // expanded range for taller field
      plats.push({x,y,width,height:10});
    }
    return plats;
  }

  let platforms = createPlatforms();

  class Knight {
    constructor(x,y,isPlayer=false){
      this.x=x; this.y=y; this.vx=0; this.vy=0;
      this.isPlayer=isPlayer; this.alive=true; this.spawnTime=Date.now();
      this.flaps=[];
    }
    update(){
      if(this.isPlayer){
        if(keys.left) this.vx = -HORIZ_SPEED; else if(keys.right) this.vx = HORIZ_SPEED; else this.vx=0;
      } else {
        const speed = 1 + 0.5*(stage-1); // enemies get faster each stage
        const dir = Math.sign(player.x - this.x);
        this.vx = dir * speed;
        const flapChance = 0.01 * stage; // aggressiveness
        if(player.y < this.y && Math.random() < flapChance){
          this.flaps.push({time:FLAP_DURATION, dir});
        }
      }

      let ax = 0;
      let ay = GRAVITY;
      for(let i=this.flaps.length-1;i>=0;i--){
        const f = this.flaps[i];
        const force = FLAP_FORCE;
        if(f.dir===0){
          ay -= force;
        }else{
          ay -= force*0.8; // reduced upward force when moving horizontally
          ax += f.dir*(force*0.5); // horizontal is half of upward
        }
        f.time -= 1/60;
        if(f.time<=0) this.flaps.splice(i,1);
      }

      this.vx += ax;
      this.vy += ay;

      const prevX=this.x, prevY=this.y;
      this.x += this.vx;
      this.y += this.vy;

      if(this.x < BIRD_RADIUS){ this.x=BIRD_RADIUS; this.vx=0; }
      if(this.x > canvas.width-BIRD_RADIUS){ this.x=canvas.width-BIRD_RADIUS; this.vx=0; }

      let onGround=false;
      if(this.y > GROUND_Y-BIRD_RADIUS){
        this.y = GROUND_Y-BIRD_RADIUS;
        this.vy = 0;
        onGround=true;
      }

      for(const p of platforms){
        if(this.x > p.x-BIRD_RADIUS && this.x < p.x+p.width+BIRD_RADIUS &&
           this.y+BIRD_RADIUS > p.y && this.y-BIRD_RADIUS < p.y+p.height){
          if(prevY + BIRD_RADIUS <= p.y){
            if(this.vy >= 0){
              this.y = p.y - BIRD_RADIUS;
              this.vy = 0; onGround=true;
            }
          } else if(prevY - BIRD_RADIUS >= p.y + p.height){
            this.y = p.y + p.height + BIRD_RADIUS;
            if(this.vy<0) this.vy=0;
          } else if(prevX < p.x){
            this.x = p.x - BIRD_RADIUS; this.vx=0;
          } else if(prevX > p.x + p.width){
            this.x = p.x + p.width + BIRD_RADIUS; this.vx=0;
          }
        }
      }
    }
    draw(){
      const img = this.isPlayer ? playerImg : enemyImg;
      ctx.drawImage(img,this.x-16,this.y-32,32,32);
    }
  }

  let player = new Knight(canvas.width/2,GROUND_Y-BIRD_RADIUS,true);
  let lives = 3;
  let stage = 1;
  let enemies = [];
  let effects = [];
  let totalToSpawn = 6;
  let spawned = 0;
  let nextSpawn = 0;

  function startStage(){
    platforms = createPlatforms();
    enemies=[]; spawned=0;
    totalToSpawn = 6 + (stage-1)*2;
    const immediate = 1 + (stage-1);
    for(let i=0;i<immediate;i++){ spawnEnemy(); }
    nextSpawn = Date.now()+10000;
  }

  function spawnEnemy(){
    if(spawned>=totalToSpawn) return;
    const x = Math.random()*(canvas.width-40)+20;
    enemies.push(new Knight(x,GROUND_Y-BIRD_RADIUS));
    spawned++;
  }

  function resetPlayer(){
    player = new Knight(canvas.width/2,GROUND_Y-BIRD_RADIUS,true);
  }

  function createEffect(x,y){
    effects.push({x,y,r:0,alpha:1});
  }

  function updateEffects(){
    for(let i=effects.length-1;i>=0;i--){
      const ef=effects[i];
      ef.r+=2;
      ef.alpha-=0.04;
      if(ef.alpha<=0) effects.splice(i,1);
    }
  }

  function drawEffects(){
    for(const ef of effects){
      ctx.save();
      ctx.globalAlpha=ef.alpha;
      ctx.strokeStyle='yellow';
      ctx.lineWidth=2;
      ctx.beginPath();
      ctx.arc(ef.x,ef.y,ef.r,0,Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }
  }

  function checkCollisions(){
    const all=[player,...enemies];
    for(let i=0;i<all.length;i++){
      for(let j=i+1;j<all.length;j++){
        const a=all[i], b=all[j];
        if(!a.alive || !b.alive) continue;
        const dx=a.x-b.x;
        const dy=a.y-b.y;
        if(Math.hypot(dx,dy) < BIRD_RADIUS*2){
          const diff=a.y-b.y;
          if(Math.abs(diff) > 2){
            const lower = diff>0 ? a : b;
            const higher = diff>0 ? b : a;
            if(lower.isPlayer){
              lives--;
              if(lives<=0){
                document.getElementById('message').textContent='Game Over';
                running=false;
              } else {
                resetPlayer();
              }
            }
            if(lower!==player){
              const idx=enemies.indexOf(lower);
              if(idx>=0) enemies.splice(idx,1);
            }
            createEffect(lower.x,lower.y);
          } else {
            const tempVy=a.vy;
            a.vy=-Math.abs(b.vy);
            b.vy=-Math.abs(tempVy);
          }
        }
      }
    }
  }

  let running=true;
  startStage();

  function update(){
    if(!running) return;
    if(Date.now()>nextSpawn){
      spawnEnemy();
      nextSpawn=Date.now()+10000;
    }
    player.update();
    enemies.forEach(e=>e.update());
    updateEffects();
    checkCollisions();
    if(spawned>=totalToSpawn && enemies.length===0){
      stage++; lives=3; resetPlayer(); startStage();
    }
    if(player.y > canvas.height+50){
      lives--; if(lives<=0){
        document.getElementById('message').textContent='Game Over';
        running=false;
      } else resetPlayer();
    }
    enemies = enemies.filter(e=>e.y<canvas.height+50);
    document.getElementById('info').textContent=`Lives: ${lives} | Stage: ${stage}`;
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // lava
    ctx.fillStyle = '#ff3300';
    ctx.fillRect(0,canvas.height-20,canvas.width,20);
    // ground
    ctx.fillStyle = '#228B22';
    ctx.fillRect(0,GROUND_Y,canvas.width,10);
    // platforms
    ctx.fillStyle = '#654321';
    for(const p of platforms){
      ctx.fillRect(p.x,p.y,p.width,p.height);
    }
    player.draw();
    enemies.forEach(e=>e.draw());
    drawEffects();
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if(placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
