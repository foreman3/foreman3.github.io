<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Neon Flight</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: #000;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      overflow: hidden;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul { list-style:none; padding:0; margin:0; }
    #sidebar li { margin:15px 0; }
    #sidebar a { color:#fff; text-decoration:none; transition:color 0.3s; }
    #sidebar a:hover { color:#0f0; }
    #game-container {
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:20px;
    }
    canvas {
      background:#000;
      border:2px solid #0f0;
      border-radius:8px;
      width:100%;
      height:auto;
      max-height:80vh;
    }
    #info {
      margin-top:10px;
      font-size:20px;
      color:#0f0;
    }
    #message {
      margin-top:10px;
      font-size:24px;
      color:#0f0;
      text-shadow:1px 1px 3px rgba(0,255,0,0.5);
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Neon Flight</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">Distance: 0 | Score: 0</div>
    <div id="message">Use arrow keys to dodge buildings and bridges</div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function clamp(value, min, max){
      return Math.max(min, Math.min(max, value));
    }

    function hexToRgb(hex){
      const clean = hex.replace('#','');
      const value = clean.length === 3
        ? clean.split('').map(c => c + c).join('')
        : clean.padEnd(6, '0');
      const r = parseInt(value.slice(0,2),16);
      const g = parseInt(value.slice(2,4),16);
      const b = parseInt(value.slice(4,6),16);
      return {r,g,b};
    }

    function adjustColor(hex, amount){
      const {r,g,b} = hexToRgb(hex);
      return `rgb(${clamp(r+amount,0,255)},${clamp(g+amount,0,255)},${clamp(b+amount,0,255)})`;
    }

    function withAlpha(hex, alpha){
      const {r,g,b} = hexToRgb(hex);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function lerp(a,b,t){
      return a + (b-a)*t;
    }

    function lerpPoint(p1,p2,t){
      return {
        x: lerp(p1.x, p2.x, t),
        y: lerp(p1.y, p2.y, t)
      };
    }

    function resizeGame(){
      const sidebar = document.getElementById('sidebar');
      const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
      const header = document.querySelector('#game-container h1');
      const info = document.getElementById('info');
      const message = document.getElementById('message');
      const aspect = 4/3;
      const availableWidth = window.innerWidth - sidebarWidth - 40;
      const availableHeight = window.innerHeight -
            header.offsetHeight - info.offsetHeight - message.offsetHeight - 40;
      let width = availableWidth;
      let height = width / aspect;
      if(height > availableHeight){
        height = availableHeight;
        width = height * aspect;
      }
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
    }

    const FOV = 300;
    const PLANE_Z = -FOV * 0.8; // place the plane further down the z-axis
    const palettes = [
      { base:'#06f2ff', accent:'#25a8ff', glow:'#7dffff', windows:'#b9f9ff' },
      { base:'#ff3be7', accent:'#ff6ab3', glow:'#ff9df2', windows:'#ffd6fa' },
      { base:'#6bff8a', accent:'#30ffa7', glow:'#9affc3', windows:'#d2ffe6' },
      { base:'#ffd166', accent:'#ffa733', glow:'#ffe9ab', windows:'#fff2cf' }
    ];

    let plane, buildings, rings, distance, score, nextRing, running;
    let left=false, right=false, up=false, down=false;
    let stars = [];
    let nebulae = [];
    let auroraBands = [];

    function resetGame(){
      plane = { x:0, y:50, z:PLANE_Z, speed:8 };
      buildings = [];
      rings = [];
      distance = 0;
      score = 0;
      nextRing = 1000;
      running = true;
      document.getElementById('message').textContent = '';
      stars = Array.from({length:160}, () => ({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height,
        size: 1 + Math.random()*2,
        speed: 0.4 + Math.random()*0.6,
        phase: Math.random()*Math.PI*2,
        color: ['#8affff','#9d9dff','#ff92ff','#ffe3a2'][Math.floor(Math.random()*4)]
      }));
      nebulae = Array.from({length:3}, (_,i) => ({
        xRatio: 0.2 + 0.3*i + Math.random()*0.15,
        yRatio: 0.1 + Math.random()*0.2,
        radiusRatio: 0.18 + Math.random()*0.12,
        inner: ['#1d8bff','#8c2fff','#1fff9e'][Math.floor(Math.random()*3)]
      }));
      auroraBands = Array.from({length:2}, () => ({
        amplitudeRatio: 0.05 + Math.random()*0.07,
        offsetRatio: 0.2 + Math.random()*0.1,
        speed: 0.002 + Math.random()*0.003,
        phase: Math.random()*Math.PI*2,
        color: ['#20ffd5','#9b4dff','#58ff83'][Math.floor(Math.random()*3)]
      }));
      for(let i=0;i<10;i++) spawnBuilding();
      document.getElementById('info').textContent = 'Distance: 0 | Score: 0';
    }

    function spawnBuilding(){
      const cityWidth = 600;
      const palette = palettes[Math.floor(Math.random()*palettes.length)];
      if(Math.random() < 0.03){
        const width = cityWidth + 120;
        const depth = 60 + Math.random()*50;
        const deckHeight = 150 + Math.random()*35;
        const deckThickness = 12 + Math.random()*6;
        const clearanceHeight = 65 + Math.random()*25;
        const design = Math.floor(Math.random()*3);
        const z = 400 + Math.random()*1200;
        const bridge = {
          type: 'bridge',
          x: 0,
          width,
          depth,
          z,
          palette,
          deckHeight,
          deckThickness,
          clearanceHeight,
          design,
          supports: [],
          features: {}
        };

        const halfWidth = width / 2;
        const supportDepth = Math.min(depth * 0.75, 70);

        if(design === 0){
          const archHeight = deckHeight + 80 + Math.random()*30;
          bridge.features.archHeight = archHeight;
          bridge.features.archThickness = 16 + Math.random()*8;
          bridge.features.cableCount = 6 + Math.floor(Math.random()*4);
          bridge.supports.push(
            { xOffset: -halfWidth + 70, width: 70, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -15 },
            { xOffset: halfWidth - 70, width: 70, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -15 }
          );
          bridge.height = archHeight;
        } else if(design === 1){
          const towerHeight = deckHeight + 90 + Math.random()*40;
          const towerOffset = width * 0.22;
          const towerWidth = 60;
          bridge.features.towerHeight = towerHeight;
          bridge.features.cableSag = 40 + Math.random()*20;
          bridge.features.towerOffset = towerOffset;
          bridge.supports.push(
            { xOffset: -halfWidth + 55, width: 60, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -20 },
            { xOffset: halfWidth - 55, width: 60, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -20 },
            { xOffset: -towerOffset, width: towerWidth, depth: supportDepth * 0.9, bottom: 0, height: towerHeight, colorShift: -5 },
            { xOffset: towerOffset, width: towerWidth, depth: supportDepth * 0.9, bottom: 0, height: towerHeight, colorShift: -5 }
          );
          bridge.height = towerHeight;
        } else {
          const frameHeight = deckHeight + 60 + Math.random()*25;
          const frameCount = 4 + Math.floor(Math.random()*2);
          bridge.features.frameCount = frameCount;
          bridge.features.frameHeight = frameHeight;
          bridge.supports.push(
            { xOffset: -halfWidth + 50, width: 55, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -12 },
            { xOffset: halfWidth - 50, width: 55, depth: supportDepth, bottom: 0, height: deckHeight, colorShift: -12 },
            { xOffset: 0, width: 70, depth: supportDepth * 0.85, bottom: 0, height: deckHeight, colorShift: -18 }
          );
          bridge.height = frameHeight;
        }

        buildings.push(bridge);
      } else {
        const x = (Math.random()-0.5) * cityWidth;
        const width = 40 + Math.random()*60;
        const depth = 40 + Math.random()*60;
        const coreHeight = 90 + Math.random()*160;
        let totalHeight = coreHeight;
        const z = 400 + Math.random()*1200;
        const windows = 3 + Math.floor(Math.random()*4);
        const windowCols = 2 + Math.floor(Math.random()*3);
        const accentPositions = [];
        if(Math.random() < 0.65){
          const accentCount = 1 + Math.floor(Math.random()*2);
          for(let i=0;i<accentCount;i++){
            accentPositions.push(0.2 + Math.random()*0.55);
          }
        }
        const segments = [];
        if(Math.random() < 0.45){
          const levels = 1 + Math.floor(Math.random()*3);
          let currentTop = coreHeight;
          for(let i=0;i<levels;i++){
            const segHeight = 20 + Math.random()*45;
            const segWidth = width * (0.6 - i*0.1);
            const segDepth = depth * (0.7 - i*0.1);
            const bottom = currentTop - 5;
            const top = bottom + segHeight;
            const segAccents = Math.random() < 0.5 ? [0.35 + Math.random()*0.4] : [];
            segments.push({width: segWidth, depth: segDepth, bottom, top, color: palette.accent, windows: Math.max(1, Math.floor(windows*0.6) - i), accents: segAccents});
            currentTop = top;
          }
          totalHeight = segments.length ? segments[segments.length-1].top : totalHeight;
        }
        let topper = null;
        if(Math.random() < 0.35){
          const topperHeight = 20 + Math.random()*35;
          topper = {height: topperHeight, color: palette.glow};
          totalHeight += topperHeight;
        }
        buildings.push({
          type:'building', x, width, depth, bottom:0, coreHeight,
          height: totalHeight, z, palette, windows, windowCols,
          segments, topper, accentPositions
        });
      }
    }

    function spawnRing(){
      const radius = 20;
      const z = 1600;
      const y = 60 + Math.random()*80;
      let x;
      let attempts;
      for(attempts=0; attempts<10; attempts++){
        x = (Math.random()-0.5) * 600;
        let overlap = false;
        for(const b of buildings){
          const withinZ = Math.abs(b.z - z) < b.depth;
          const width = b.type === 'bridge' ? b.width : b.width;
          const withinX = Math.abs(x - b.x) < width/2 + radius*2;
          let bottom = b.bottom || 0;
          if(b.type === 'bridge'){
            const rel = x - b.x;
            bottom = bridgeBottomAt(b, rel);
            for(const support of b.supports){
              const half = support.width/2 + radius;
              if(Math.abs(rel - support.xOffset) < half){
                bottom = Math.max(bottom, support.height);
                break;
              }
            }
          }
          const withinY = y > bottom - radius*2 && y < b.height + radius*2;
          if(withinZ && withinX && withinY){
            overlap = true;
            break;
          }
        }
        if(!overlap) break;
      }
  if(attempts < 10){
    rings.push({x,y,z,radius,collected:false});
    return true;
  }
  return false;
}

 function bridgeBottomAt(bridge, rel){
   const halfWidth = bridge.width / 2;
   if(halfWidth <= 0) return 0;
   const ratio = Math.min(1, Math.abs(rel) / halfWidth);
   const deckBottom = bridge.deckHeight - bridge.deckThickness;
   let clearance = bridge.clearanceHeight * (1 - ratio*ratio);
   if(bridge.design === 1){
     clearance += Math.sin(ratio * Math.PI) * 6;
   } else if(bridge.design === 2){
     clearance -= Math.sin(ratio * Math.PI) * 8;
   }
   clearance = Math.max(0, clearance);
   let bottom = Math.min(deckBottom, clearance);
   if(bridge.design === 0){
     bottom += Math.cos(ratio * Math.PI) * 4;
   }
   return Math.max(0, bottom);
 }

  function update(){
      if(!running) return;
      // Increased control responsiveness
      const ctrl = 8;
      if(left) plane.x -= ctrl;
      if(right) plane.x += ctrl;
      if(up) plane.y += ctrl;
      if(down) plane.y -= ctrl;
      plane.x = Math.max(-300, Math.min(300, plane.x));
      plane.y = Math.max(20, Math.min(150, plane.y));
      for(const s of stars){
        s.y += plane.speed*0.25 * s.speed;
        s.phase += 0.02;
        if(s.y > canvas.height){
          s.y = 0;
          s.x = Math.random()*canvas.width;
          s.speed = 0.4 + Math.random()*0.6;
        }
      }
      for(const band of auroraBands){
        band.phase += band.speed * plane.speed;
      }
      for(let i = buildings.length - 1; i >= 0; i--){
        const b = buildings[i];
        b.z -= plane.speed;
        const front = b.z - b.depth/2;
        const back = b.z + b.depth/2;
        const withinZ = front <= plane.z && back >= plane.z;
        let collision = false;
        if(b.type === 'bridge'){
          const w = b.width/2;
          const rel = plane.x - b.x;
          const bottom = bridgeBottomAt(b, rel);
          if(Math.abs(rel) < w && plane.y < b.height && plane.y > bottom){
            collision = true;
          }
          if(!collision){
            for(const support of b.supports){
              const half = support.width/2;
              const supportBottom = support.bottom ?? 0;
              const supportTop = support.collisionHeight || support.height;
              if(Math.abs(rel - support.xOffset) < half &&
                 plane.y < supportTop && plane.y > supportBottom){
                collision = true;
                break;
              }
            }
          }
        } else {
          const withinX = Math.abs(b.x - plane.x) < b.width/2;
          const bottom = b.bottom || 0;
          const withinY = plane.y < b.height && plane.y > bottom;
          collision = withinX && withinY;
        }
        if(withinZ && collision){
          running = false;
          document.getElementById('message').textContent = 'Crash! Press Space';
        }
        if(back <= plane.z){
          buildings.splice(i, 1);
        }
      }
      while(buildings.length < 10) spawnBuilding();

      for(let i = rings.length - 1; i >= 0; i--){
        const r = rings[i];
        r.z -= plane.speed;
        if(!r.collected &&
           Math.abs(r.z - plane.z) < r.radius &&
           Math.abs(r.x - plane.x) < r.radius &&
           Math.abs(r.y - plane.y) < r.radius){
          r.collected = true;
          score += 100;
        }
        if(r.z + r.radius <= plane.z){
          rings.splice(i,1);
        }
      }

      if(distance >= nextRing){
        if(spawnRing()) nextRing += 1000;
      }

      distance += plane.speed;
      document.getElementById('info').textContent = `Distance: ${Math.floor(distance)} | Score: ${score}`;
    }

    function project(x,y,z){
      const scale = FOV / (FOV + z);
      return {
        x: canvas.width/2 + (x - plane.x)*scale,
        y: canvas.height*0.7 - (y - plane.y)*scale
      };
    }

    function drawBackground(){
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#040012');
      grad.addColorStop(0.3, '#0b0630');
      grad.addColorStop(0.65, '#001e2c');
      grad.addColorStop(1, '#000000');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawNebulae(){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for(const n of nebulae){
        const x = n.xRatio * canvas.width;
        const y = n.yRatio * canvas.height;
        const radius = n.radiusRatio * canvas.width;
        const gradient = ctx.createRadialGradient(x, y, radius*0.2, x, y, radius);
        gradient.addColorStop(0, withAlpha(n.inner, 0.45));
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawAurora(){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      ctx.lineJoin = 'round';
      for(const band of auroraBands){
        const baseY = band.offsetRatio * canvas.height;
        const amplitude = band.amplitudeRatio * canvas.height;
        const gradient = ctx.createLinearGradient(0, baseY - 40, 0, baseY + 120);
        gradient.addColorStop(0, withAlpha(band.color, 0.35));
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0, baseY + amplitude);
        const segments = 32;
        for(let i=0;i<=segments;i++){
          const t = i/segments;
          const x = t * canvas.width;
          const wave = Math.sin(band.phase + t * Math.PI * 4) * amplitude;
          ctx.lineTo(x, baseY + wave);
        }
        ctx.lineTo(canvas.width, baseY + amplitude*2);
        ctx.lineTo(0, baseY + amplitude*2);
        ctx.closePath();
        ctx.fill();
      }
      ctx.restore();
    }

    function drawStars(){
      ctx.save();
      for(const s of stars){
        const twinkle = 0.5 + 0.5 * Math.sin(s.phase);
        ctx.globalAlpha = 0.3 + twinkle*0.7;
        ctx.fillStyle = s.color;
        ctx.fillRect(s.x, s.y, s.size, s.size);
      }
      ctx.restore();
    }

    function drawDistantCity(){
      const horizonY = canvas.height * 0.72;
      ctx.save();
      ctx.fillStyle = 'rgba(12,32,58,0.55)';
      ctx.beginPath();
      ctx.moveTo(0, horizonY);
      const segments = 18;
      for(let i=0;i<=segments;i++){
        const t = i/segments;
        const x = t * canvas.width;
        const wave = Math.sin(distance*0.0004 + t*Math.PI*3) * 35;
        ctx.lineTo(x, horizonY - 70 - wave);
      }
      ctx.lineTo(canvas.width, horizonY);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'rgba(20,54,86,0.45)';
      ctx.beginPath();
      ctx.moveTo(0, horizonY + 4);
      for(let i=0;i<=segments;i++){
        const t = i/segments;
        const x = t * canvas.width;
        const wave = Math.sin(distance*0.00055 + 1.1 + t*Math.PI*4) * 28;
        ctx.lineTo(x, horizonY - 40 - wave);
      }
      ctx.lineTo(canvas.width, horizonY + 4);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawHorizonGlow(){
      const horizonY = canvas.height * 0.72;
      const glow = ctx.createLinearGradient(0, horizonY - 120, 0, horizonY + 120);
      glow.addColorStop(0, 'rgba(0,0,0,0)');
      glow.addColorStop(0.5, 'rgba(40,255,210,0.18)');
      glow.addColorStop(1, 'rgba(0,0,0,0.6)');
      ctx.fillStyle = glow;
      ctx.fillRect(0, horizonY - 120, canvas.width, 240);
    }

    function drawGroundGrid(){
      ctx.save();
      ctx.strokeStyle = 'rgba(100,255,190,0.25)';
      ctx.lineWidth = 1;
      for(let i=1;i<16;i++){
        const z = plane.z + i*120;
        const left = project(-450, 0, z);
        const right = project(450, 0, z);
        ctx.beginPath();
        ctx.moveTo(left.x, left.y);
        ctx.lineTo(right.x, right.y);
        ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(100,255,190,0.18)';
      for(let i=-6;i<=6;i++){
        const x = i * 90;
        const near = project(x, 0, plane.z + 40);
        const far = project(x, 0, plane.z + 900);
        ctx.beginPath();
        ctx.moveTo(near.x, near.y);
        ctx.lineTo(far.x, far.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawPrism({x, width, depth, bottom, top, z, palette, windows=0, windowCols=0, baseColor, accentColor, accents=[]}){
      const w = width/2;
      const d = depth/2;
      let frontBottomLeft = project(x - w, bottom, z - d);
      let frontBottomRight = project(x + w, bottom, z - d);
      let backBottomLeft = project(x - w, bottom, z + d);
      let backBottomRight = project(x + w, bottom, z + d);
      let frontTopLeft = project(x - w, top, z - d);
      let frontTopRight = project(x + w, top, z - d);
      let backTopLeft = project(x - w, top, z + d);
      let backTopRight = project(x + w, top, z + d);

      const allPoints = [
        frontBottomLeft, frontBottomRight, backBottomLeft, backBottomRight,
        frontTopLeft, frontTopRight, backTopLeft, backTopRight
      ];
      if(allPoints.some(p => !Number.isFinite(p.x) || !Number.isFinite(p.y))){
        return;
      }

      if(frontBottomLeft.x > frontBottomRight.x){
        [frontBottomLeft, frontBottomRight] = [frontBottomRight, frontBottomLeft];
        [frontTopLeft, frontTopRight] = [frontTopRight, frontTopLeft];
      }
      if(backBottomLeft.x > backBottomRight.x){
        [backBottomLeft, backBottomRight] = [backBottomRight, backBottomLeft];
        [backTopLeft, backTopRight] = [backTopRight, backTopLeft];
      }

      const base = baseColor || palette.base;
      const accent = accentColor || palette.accent;
      const glow = palette.glow;
      const windowColor = palette.windows;

      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      const frontGradient = ctx.createLinearGradient(frontBottomLeft.x, frontBottomLeft.y, frontBottomRight.x, frontBottomRight.y);
      frontGradient.addColorStop(0, adjustColor(base, 35));
      frontGradient.addColorStop(1, adjustColor(base, -15));
      ctx.beginPath();
      ctx.moveTo(frontBottomLeft.x, frontBottomLeft.y);
      ctx.lineTo(frontBottomRight.x, frontBottomRight.y);
      ctx.lineTo(frontTopRight.x, frontTopRight.y);
      ctx.lineTo(frontTopLeft.x, frontTopLeft.y);
      ctx.closePath();
      ctx.fillStyle = frontGradient;
      ctx.fill();

      const sideGradient = ctx.createLinearGradient(frontBottomRight.x, frontBottomRight.y, backBottomRight.x, backBottomRight.y);
      sideGradient.addColorStop(0, adjustColor(base, -5));
      sideGradient.addColorStop(1, adjustColor(base, -45));
      ctx.beginPath();
      ctx.moveTo(frontBottomRight.x, frontBottomRight.y);
      ctx.lineTo(backBottomRight.x, backBottomRight.y);
      ctx.lineTo(backTopRight.x, backTopRight.y);
      ctx.lineTo(frontTopRight.x, frontTopRight.y);
      ctx.closePath();
      ctx.fillStyle = sideGradient;
      ctx.fill();

      const topGradient = ctx.createLinearGradient(frontTopLeft.x, frontTopLeft.y, backTopLeft.x, backTopLeft.y);
      topGradient.addColorStop(0, adjustColor(base, 60));
      topGradient.addColorStop(1, adjustColor(base, 10));
      ctx.beginPath();
      ctx.moveTo(frontTopLeft.x, frontTopLeft.y);
      ctx.lineTo(frontTopRight.x, frontTopRight.y);
      ctx.lineTo(backTopRight.x, backTopRight.y);
      ctx.lineTo(backTopLeft.x, backTopLeft.y);
      ctx.closePath();
      ctx.fillStyle = topGradient;
      ctx.fill();

      ctx.shadowColor = withAlpha(glow, 0.4);
      ctx.shadowBlur = 12;
      ctx.strokeStyle = withAlpha(glow, 0.9);
      ctx.lineWidth = 1.6;
      ctx.beginPath();
      const edges = [
        [frontBottomLeft, frontBottomRight],
        [frontBottomLeft, backBottomLeft],
        [frontBottomRight, backBottomRight],
        [backBottomLeft, backBottomRight],
        [frontTopLeft, frontTopRight],
        [frontTopLeft, backTopLeft],
        [frontTopRight, backTopRight],
        [backTopLeft, backTopRight],
        [frontBottomLeft, frontTopLeft],
        [frontBottomRight, frontTopRight],
        [backBottomLeft, backTopLeft],
        [backBottomRight, backTopRight]
      ];
      for(const [a,b] of edges){
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0;

      if(accents && accents.length){
        ctx.strokeStyle = withAlpha(accent, 0.75);
        ctx.lineWidth = 1.2;
        for(const pos of accents){
          const t = clamp(pos, 0.05, 0.95);
          const left = lerpPoint(frontBottomLeft, frontTopLeft, t);
          const right = lerpPoint(frontBottomRight, frontTopRight, t);
          ctx.beginPath();
          ctx.moveTo(left.x, left.y);
          ctx.lineTo(right.x, right.y);
          ctx.stroke();
        }
      }

      if(windows > 0){
        ctx.strokeStyle = withAlpha(windowColor, 0.6);
        ctx.lineWidth = 1;
        for(let i=1;i<=windows;i++){
          const t = i/(windows+1);
          const left = lerpPoint(frontBottomLeft, frontTopLeft, t);
          const right = lerpPoint(frontBottomRight, frontTopRight, t);
          ctx.beginPath();
          ctx.moveTo(left.x, left.y);
          ctx.lineTo(right.x, right.y);
          ctx.stroke();
        }
      }

      if(windowCols > 0){
        ctx.strokeStyle = withAlpha(windowColor, 0.35);
        ctx.lineWidth = 0.8;
        for(let i=1;i<=windowCols;i++){
          const t = i/(windowCols+1);
          const bottomPoint = lerpPoint(frontBottomLeft, frontBottomRight, t);
          const topPoint = lerpPoint(frontTopLeft, frontTopRight, t);
          ctx.beginPath();
          ctx.moveTo(bottomPoint.x, bottomPoint.y);
          ctx.lineTo(topPoint.x, topPoint.y);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function drawTopper(b){
      if(!b.topper) return;
      const basePoint = project(b.x, b.height - b.topper.height, b.z);
      const tipPoint = project(b.x, b.height, b.z);
      const glow = b.topper.color || b.palette.glow;
      ctx.save();
      ctx.strokeStyle = withAlpha(glow, 0.9);
      ctx.lineWidth = 2;
      ctx.shadowColor = withAlpha(glow, 0.7);
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.moveTo(basePoint.x, basePoint.y);
      ctx.lineTo(tipPoint.x, tipPoint.y);
      ctx.stroke();
      ctx.shadowBlur = 16;
      ctx.fillStyle = withAlpha(glow, 0.95);
      ctx.beginPath();
      ctx.arc(tipPoint.x, tipPoint.y, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    function drawBuilding(b){
      if(b.type === 'bridge') return drawBridge(b);
      const bottom = b.bottom || 0;
      drawPrism({
        x: b.x,
        width: b.width,
        depth: b.depth,
        bottom,
        top: b.coreHeight,
        z: b.z,
        palette: b.palette,
        windows: b.windows,
        windowCols: b.windowCols,
        baseColor: b.palette.base,
        accentColor: b.palette.accent,
        accents: b.accentPositions
      });
      if(b.segments){
        for(const seg of b.segments){
          drawPrism({
            x: b.x,
            width: seg.width,
            depth: seg.depth,
            bottom: seg.bottom,
            top: seg.top,
            z: b.z,
            palette: b.palette,
            windows: seg.windows || 0,
            windowCols: Math.max(0, b.windowCols - 1),
            baseColor: seg.color,
            accentColor: seg.color,
            accents: seg.accents || []
          });
        }
      }
      drawTopper(b);
    }

    function drawBridgeSupport(bridge, support){
      const baseColor = adjustColor(bridge.palette.base, support.colorShift || 0);
      drawPrism({
        x: bridge.x + support.xOffset,
        width: support.width,
        depth: support.depth || Math.min(bridge.depth*0.9, 80),
        bottom: support.bottom ?? 0,
        top: support.height,
        z: bridge.z,
        palette: bridge.palette,
        windows: 0,
        windowCols: 0,
        baseColor,
        accentColor: adjustColor(bridge.palette.accent, 8)
      });
    }

    function drawBridgeDeck(bridge){
      const deckBottom = bridge.deckHeight - bridge.deckThickness;
      drawPrism({
        x: bridge.x,
        width: bridge.width,
        depth: bridge.depth,
        bottom: deckBottom,
        top: bridge.deckHeight,
        z: bridge.z,
        palette: bridge.palette,
        windows: 0,
        windowCols: 0,
        baseColor: adjustColor(bridge.palette.base, -35),
        accentColor: adjustColor(bridge.palette.accent, -5)
      });
    }

    function drawBridgeRails(bridge){
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const y = bridge.deckHeight + 6;
      const leftFront = project(bridge.x - w, y, bridge.z - d);
      const rightFront = project(bridge.x + w, y, bridge.z - d);
      const leftBack = project(bridge.x - w, y, bridge.z + d);
      const rightBack = project(bridge.x + w, y, bridge.z + d);
      ctx.save();
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.8);
      ctx.lineWidth = 2.2;
      ctx.shadowColor = withAlpha(bridge.palette.glow, 0.6);
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(leftFront.x, leftFront.y);
      ctx.lineTo(rightFront.x, rightFront.y);
      ctx.moveTo(leftBack.x, leftBack.y);
      ctx.lineTo(rightBack.x, rightBack.y);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawBridgeUnderside(bridge){
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const underside = bridge.deckHeight - bridge.deckThickness - 6;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.35);
      ctx.lineWidth = 1.6;
      for(const offset of [-0.35, 0, 0.35]){
        const x = bridge.x + w * offset;
        const front = project(x, underside, bridge.z - d);
        const back = project(x, underside, bridge.z + d);
        ctx.beginPath();
        ctx.moveTo(front.x, front.y);
        ctx.lineTo(back.x, back.y);
        ctx.stroke();
      }
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    }

    function drawArchBridgeDetails(bridge){
      const {archHeight, archThickness, cableCount} = bridge.features;
      if(!archHeight) return;
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const span = Math.max(10, archHeight - bridge.deckHeight);
      const segments = 28;
      ctx.save();
      ctx.shadowColor = withAlpha(bridge.palette.glow, 0.55);
      ctx.shadowBlur = 18;
      ctx.strokeStyle = withAlpha(bridge.palette.accent, 0.85);
      ctx.lineWidth = Math.max(3, archThickness/3);
      for(const depth of [-d, d]){
        ctx.beginPath();
        for(let i=0;i<=segments;i++){
          const t = -w + (2*w*i)/segments;
          const ratio = t / w;
          const y = bridge.deckHeight + span * (1 - ratio*ratio);
          const p = project(bridge.x + t, y, bridge.z + depth);
          if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      ctx.shadowBlur = 9;
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.75);
      ctx.lineWidth = 1.4;
      const cables = cableCount || 6;
      for(let i=1;i<=cables;i++){
        const t = i/(cables+1);
        const x = -w + bridge.width * t;
        const ratio = x / w;
        const y = bridge.deckHeight + span * (1 - ratio*ratio);
        for(const depth of [-d, d]){
          const top = project(bridge.x + x, y, bridge.z + depth);
          const bottom = project(bridge.x + x, bridge.deckHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(top.x, top.y);
          ctx.lineTo(bottom.x, bottom.y);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawSuspensionBridgeDetails(bridge){
      const {towerHeight, cableSag, towerOffset} = bridge.features;
      if(!towerHeight) return;
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const segments = 36;
      ctx.save();
      ctx.shadowColor = withAlpha(bridge.palette.glow, 0.5);
      ctx.shadowBlur = 16;
      ctx.strokeStyle = withAlpha(bridge.palette.accent, 0.85);
      ctx.lineWidth = 2.2;

      function cableHeight(t){
        const eased = Math.sin(Math.PI * t);
        return towerHeight - eased * (cableSag || 45);
      }

      for(const depth of [-d, d]){
        ctx.beginPath();
        for(let i=0;i<=segments;i++){
          const t = i/segments;
          const x = -w + 2*w*t;
          const y = cableHeight(t);
          const p = project(bridge.x + x, y, bridge.z + depth);
          if(i===0) ctx.moveTo(p.x, p.y); else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
      }

      ctx.shadowBlur = 8;
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.7);
      ctx.lineWidth = 1.3;
      const hangerCount = 12;
      for(let i=1;i<hangerCount;i++){
        const t = i/hangerCount;
        const x = -w + 2*w*t;
        const y = cableHeight(t);
        for(const depth of [-d, d]){
          const top = project(bridge.x + x, y, bridge.z + depth);
          const bottom = project(bridge.x + x, bridge.deckHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(top.x, top.y);
          ctx.lineTo(bottom.x, bottom.y);
          ctx.stroke();
        }
      }

      if(towerOffset){
        ctx.shadowBlur = 14;
        ctx.lineWidth = 2.4;
        for(const depth of [-d, d]){
          const leftTop = project(bridge.x - towerOffset, towerHeight, bridge.z + depth);
          const rightTop = project(bridge.x + towerOffset, towerHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(leftTop.x, leftTop.y);
          ctx.lineTo(rightTop.x, rightTop.y);
          ctx.stroke();
        }
      }
      ctx.restore();
    }

    function drawTrussBridgeDetails(bridge){
      const {frameCount, frameHeight} = bridge.features;
      if(!frameCount || !frameHeight) return;
      const w = bridge.width/2;
      const d = bridge.depth/2;
      const step = bridge.width / (frameCount + 1);
      ctx.save();
      ctx.shadowColor = withAlpha(bridge.palette.accent, 0.55);
      ctx.shadowBlur = 12;
      ctx.strokeStyle = withAlpha(bridge.palette.accent, 0.85);
      ctx.lineWidth = 2;
      for(const depth of [-d, d]){
        for(let i=0;i<=frameCount+1;i++){
          const x = -w + step*i;
          const base = project(bridge.x + x, bridge.deckHeight, bridge.z + depth);
          const top = project(bridge.x + x, frameHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(base.x, base.y);
          ctx.lineTo(top.x, top.y);
          ctx.stroke();
        }
        ctx.lineWidth = 1.6;
        for(let i=0;i<frameCount+1;i++){
          const x1 = -w + step*i;
          const x2 = x1 + step;
          const base1 = project(bridge.x + x1, bridge.deckHeight, bridge.z + depth);
          const base2 = project(bridge.x + x2, bridge.deckHeight, bridge.z + depth);
          const apex = project(bridge.x + (x1 + x2)/2, frameHeight, bridge.z + depth);
          ctx.beginPath();
          ctx.moveTo(base1.x, base1.y);
          ctx.lineTo(apex.x, apex.y);
          ctx.lineTo(base2.x, base2.y);
          ctx.stroke();
        }
      }
      ctx.shadowBlur = 6;
      ctx.lineWidth = 1.4;
      ctx.strokeStyle = withAlpha(bridge.palette.glow, 0.75);
      for(const depth of [-d, d]){
        const topLeft = project(bridge.x - w, frameHeight, bridge.z + depth);
        const topRight = project(bridge.x + w, frameHeight, bridge.z + depth);
        ctx.beginPath();
        ctx.moveTo(topLeft.x, topLeft.y);
        ctx.lineTo(topRight.x, topRight.y);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawBridge(b){
      ctx.save();
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      const supports = [...b.supports].sort((a,b) => (a.height - b.height));
      for(const support of supports){
        drawBridgeSupport(b, support);
      }

      drawBridgeDeck(b);
      drawBridgeRails(b);
      drawBridgeUnderside(b);

      if(b.design === 0){
        drawArchBridgeDetails(b);
      } else if(b.design === 1){
        drawSuspensionBridgeDetails(b);
      } else {
        drawTrussBridgeDetails(b);
      }

      ctx.restore();
    }

  function drawRing(r){
    const center = project(r.x, r.y, r.z);
    const scale = FOV / (FOV + r.z);
    const rad = r.radius * scale;
    ctx.save();
    const glow = ctx.createRadialGradient(center.x, center.y, rad*0.2, center.x, center.y, rad);
    glow.addColorStop(0, 'rgba(255,255,200,0.7)');
    glow.addColorStop(1, 'rgba(255,140,0,0)');
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(center.x, center.y, rad, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
    ctx.lineWidth = 3;
    ctx.strokeStyle = 'rgba(255,230,130,0.95)';
    ctx.shadowColor = 'rgba(255,220,160,0.85)';
    ctx.shadowBlur = 18;
    ctx.beginPath();
    ctx.arc(center.x, center.y, rad*0.8, 0, Math.PI*2);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

  function drawCrosshair(){
    const len = 14;
    const x = canvas.width/2;
    const y = canvas.height*0.7;
    ctx.save();
    ctx.strokeStyle = 'rgba(120,255,210,0.9)';
    ctx.lineWidth = 1.3;
    ctx.shadowColor = 'rgba(120,255,210,0.6)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.moveTo(x - len, y);
    ctx.lineTo(x + len, y);
    ctx.moveTo(x, y - len);
    ctx.lineTo(x, y + len);
    ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();
  }

    function draw(){
      drawBackground();
      drawNebulae();
      drawAurora();
      drawStars();
      drawDistantCity();
      drawHorizonGlow();
      drawGroundGrid();

      const visibleBuildings = buildings
        .filter(b => b.z + b.depth/2 >= plane.z)
        .sort((a,b) => b.z - a.z);
      for(const building of visibleBuildings){
        drawBuilding(building);
      }

      const visibleRings = rings
        .filter(r => r.z + r.radius >= plane.z && !r.collected)
        .sort((a,b) => b.z - a.z);
      for(const ring of visibleRings){
        drawRing(ring);
      }

      drawCrosshair();
    }

    function loop(){
      update();
      draw();
    }

    window.addEventListener('keydown', e => {
      if(e.code === 'ArrowLeft'){ left = true; }
      if(e.code === 'ArrowRight'){ right = true; }
      if(e.code === 'ArrowUp'){ up = true; }
      if(e.code === 'ArrowDown'){ down = true; }
      if(e.code === 'Space' && !running) resetGame();
    });
    window.addEventListener('keyup', e => {
      if(e.code === 'ArrowLeft') left = false;
      if(e.code === 'ArrowRight') right = false;
      if(e.code === 'ArrowUp') up = false;
      if(e.code === 'ArrowDown') down = false;
    });

    window.addEventListener('load', () => {
      resizeGame();
      resetGame();
      setInterval(loop, 1000/60);
    });
    window.addEventListener('resize', resizeGame);
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
