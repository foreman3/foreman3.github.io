<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Space Invaders</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: radial-gradient(circle at 30% 20%, #142965 0%, #050713 45%, #02030a 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      overflow: hidden;
    }
    #sidebar {
      width: 220px;
      background: rgba(5, 7, 18, 0.82);
      backdrop-filter: blur(6px);
      padding: 20px;
      box-shadow: 2px 0 18px rgba(0,0,0,0.55);
      border-right: 1px solid rgba(0, 200, 255, 0.2);
    }
    #sidebar ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    #sidebar li {
      margin: 15px 0;
    }
    #sidebar a {
      color: #fff;
      text-decoration: none;
      transition: color 0.3s;
    }
    #sidebar a:hover {
      color: #ffea00;
    }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 30px;
      position: relative;
    }
    #game-container::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at center, rgba(0, 174, 255, 0.18) 0%, rgba(0,0,0,0) 70%);
      pointer-events: none;
      z-index: 0;
      filter: blur(24px);
    }
    h1 {
      z-index: 1;
      letter-spacing: 0.08em;
      text-shadow: 0 0 22px rgba(0, 255, 198, 0.6);
    }
    canvas {
      background: transparent;
      border: 2px solid rgba(0, 174, 255, 0.5);
      border-radius: 16px;
      box-shadow: 0 0 30px rgba(0, 174, 255, 0.35), inset 0 0 20px rgba(4, 20, 68, 0.6);
      z-index: 1;
    }
    #info {
      margin-top: 12px;
      font-size: 20px;
      background: linear-gradient(135deg, rgba(4, 20, 68, 0.9), rgba(3, 51, 89, 0.6));
      padding: 8px 18px;
      border-radius: 999px;
      box-shadow: 0 0 12px rgba(0, 174, 255, 0.5);
      position: relative;
      z-index: 1;
    }
    #message {
      margin-top: 14px;
      font-size: 24px;
      color: #ffd93b;
      text-shadow: 0 0 14px rgba(255, 217, 59, 0.7);
      min-height: 28px;
      position: relative;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Space Invaders</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="info">Score: 0 | Lives: 3</div>
    <div id="message"></div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const player = { x: canvas.width/2, y: canvas.height - 38, w: 54, h: 32, pulse: 0 };
    const playerImg = new Image();
    playerImg.src = 'images/player_ship.svg';
    let bullet = null;
    const aliens = [];
    const alienSpriteSources = [
      'images/invader_scout.svg',
      'images/invader_barrage.svg',
      'images/invader_mystic.svg',
      'images/invader_vanguard.svg',
      'images/invader_overlord.svg'
    ];
    const alienSprites = alienSpriteSources.map(src => {
      const img = new Image();
      img.src = src;
      return img;
    });
    const bombs = [];
    const explosions = [];
    const sparks = [];
    const starfield = Array.from({length: 160}, () => ({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height,
      speed: Math.random()*25 + 20,
      size: Math.random()*1.8 + 0.4,
      twinkle: Math.random()*Math.PI*2,
      trail: Math.random() < 0.1
    }));
    const auroras = Array.from({length: 3}, () => ({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height*0.5,
      r: Math.random()*220 + 120,
      hue: Math.random()*120 + 160,
      alpha: Math.random()*0.25 + 0.1
    }));
    const parallaxClouds = Array.from({length: 4}, () => ({
      x: Math.random()*canvas.width,
      y: Math.random()*canvas.height*0.7,
      r: Math.random()*240 + 240,
      hue: Math.random()*80 + 180,
      alpha: Math.random()*0.25 + 0.15,
      speed: Math.random()*12 + 6
    }));
    const constellations = Array.from({length: 6}, () => ({
      points: Array.from({length: 5 + Math.floor(Math.random()*4)}, () => ({
        x: Math.random()*canvas.width,
        y: Math.random()*canvas.height*0.55,
      })).sort((a,b) => a.x - b.x),
      glow: Math.random()*0.4 + 0.4
    }));
    const horizonGlow = { hue: 205, alpha: 0.35 };
    const planet = {
      x: canvas.width*0.18,
      y: canvas.height*0.32,
      r: 180,
      ringTilt: -0.35
    };
    let shields = [];
    let score = 0;
    let lives = 3;
    let alienDir = 1; // 1=right, -1=left
    let moveCounter = 0;
    let startingSpeed = 5;
    let level = 1;
    let alienSpeed = startingSpeed;
    let gameOver = false;
    let nextLevel = false;

    const keys = {};

    function createAliens(){
      aliens.length = 0;
      const rows = 5;
      const cols = 10;
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          aliens.push({
            x: 80 + c*64,
            y: 80 + r*56,
            w: 42,
            h: 32,
            alive: true,
            row: r,
            wobble: Math.random()*Math.PI*2
          });
        }
      }
    }

    function createShields(){
      shields = [];
      const shieldCount = 4;
      const startX = 100;
      for(let s=0;s<shieldCount;s++){
        const bricks = [];
        for(let r=0;r<3;r++){
          for(let c=0;c<6;c++){
            bricks.push({x: startX + s*170 + c*10, y: canvas.height-120 + r*10, alive: true});
          }
        }
        shields.push(bricks);
      }
    }

    function createExplosion(x, y, color = 'rgba(0, 255, 198, 1)'){
      explosions.push({x, y, r: 0, alpha: 1, color});
      for(let i=0;i<12;i++){
        const angle = Math.random()*Math.PI*2;
        sparks.push({
          x,
          y,
          vx: Math.cos(angle)*(40 + Math.random()*80),
          vy: Math.sin(angle)*(40 + Math.random()*80),
          life: 0.6 + Math.random()*0.4,
          size: Math.random()*2 + 1,
          color
        });
      }
    }

    function updateExplosions(dt){
      for(let i=explosions.length-1;i>=0;i--){
        const ex = explosions[i];
        ex.r += 240*dt;
        ex.alpha -= dt*0.6;
        if(ex.alpha <= 0){
          explosions.splice(i,1);
        }
      }
    }

    function updateSparks(dt){
      for(let i=sparks.length-1;i>=0;i--){
        const s = sparks[i];
        s.x += s.vx*dt;
        s.y += s.vy*dt;
        s.life -= dt;
        s.vx *= 0.98;
        s.vy *= 0.98;
        if(s.life <= 0) sparks.splice(i,1);
      }
    }

    function updateStars(dt){
      for(const star of starfield){
        star.y += star.speed*dt;
        star.twinkle += dt*4;
        if(star.y > canvas.height){
          star.y = -5;
          star.x = Math.random()*canvas.width;
          star.speed = Math.random()*25 + 20;
          star.size = Math.random()*1.8 + 0.4;
          star.trail = Math.random() < 0.12;
        }
      }
      for(const cloud of parallaxClouds){
        cloud.x += cloud.speed*dt;
        if(cloud.x - cloud.r > canvas.width + 80){
          cloud.x = -cloud.r - 80;
          cloud.y = Math.random()*canvas.height*0.7;
          cloud.hue = Math.random()*80 + 180;
          cloud.alpha = Math.random()*0.25 + 0.15;
          cloud.speed = Math.random()*12 + 6;
        }
      }
      for(const aurora of auroras){
        aurora.hue += dt*8;
      }
      horizonGlow.alpha = 0.28 + Math.sin(performance.now()/1200)*0.08;
    }

    function resetGame(){
      alienDir = 1;
      moveCounter = 0;
      alienSpeed = startingSpeed;
      gameOver = false;
      nextLevel = false;
      bullet = null;
      bombs.length = 0;
      createAliens();
      createShields();
      updateInfo();
      document.getElementById('message').textContent = '';
    }

    function startNewGame(){
      score = 0;
      lives = 3;
      startingSpeed = 5;
      level = 1;
      resetGame();
    }

    function startNextLevel(){
      startingSpeed *= 2;
      level++;
      resetGame();
    }

    function updateInfo(){
      document.getElementById('info').textContent = `Score: ${score} | Lives: ${lives} | Level: ${level}`;
    }

    function shoot(){
      if(!bullet){
        bullet = {x: player.x, y: player.y - player.h/2, r: 4};
      }
    }

    function update(dt){
      const playerSpeed = 360;
      if(gameOver){
        updateExplosions(dt);
        updateSparks(dt);
        updateStars(dt);
        return;
      }
      if(keys['ArrowLeft']) player.x -= playerSpeed*dt;
      if(keys['ArrowRight']) player.x += playerSpeed*dt;
      player.x = Math.max(player.w/2, Math.min(canvas.width-player.w/2, player.x));
      player.pulse += 0.08;

      if(bullet){
        bullet.y -= 480*dt;
        if(bullet.y < 0) bullet = null;
      }

      bombs.forEach(b => b.y += 180*dt);
      updateExplosions(dt);
      updateSparks(dt);
      updateStars(dt);

      // Alien movement
      moveCounter++;
      if(moveCounter % 30 === 0){
        let left = Infinity, right = -Infinity;
        for(const a of aliens){
          if(a.alive){
            a.x += alienDir * alienSpeed;
            left = Math.min(left, a.x - a.w/2);
            right = Math.max(right, a.x + a.w/2);
          }
        }
        if(left < 20 || right > canvas.width - 20){
          alienDir *= -1;
          for(const a of aliens){
            if(a.alive){
              a.y += 20;
            }
          }
        }
      }

      // Alien collision with shields
      for(const a of aliens){
        if(!a.alive) continue;
        for(const bricks of shields){
          for(const brick of bricks){
            if(brick.alive &&
               a.x + a.w/2 > brick.x - 5 &&
               a.x - a.w/2 < brick.x + 5 &&
               a.y + a.h/2 > brick.y - 5 &&
               a.y - a.h/2 < brick.y + 5){
              brick.alive = false;
            }
          }
        }
      }

      // Alien shooting
      if(Math.random() < 0.02){
        const shooters = aliens.filter(a => a.alive);
        if(shooters.length){
          const a = shooters[Math.floor(Math.random()*shooters.length)];
          bombs.push({x: a.x, y: a.y + a.h/2, r: 4});
        }
      }

      // Bullet collision with aliens
      if(bullet){
        for(const a of aliens){
          if(a.alive && bullet.x > a.x - a.w/2 && bullet.x < a.x + a.w/2 && bullet.y > a.y - a.h/2 && bullet.y < a.y + a.h/2){
            a.alive = false;
            bullet = null;
            score += 10;
            alienSpeed *= 1.04;
            updateInfo();
            createExplosion(a.x, a.y, 'rgba(0, 255, 198, 1)');
            break;
          }
        }
      }

      // Bullet collision with shields
      if(bullet){
        bulletLoop:
        for(const bricks of shields){
          for(const brick of bricks){
            if(brick.alive && Math.abs(bullet.x - brick.x) < 5 && Math.abs(bullet.y - brick.y) < 5){
              brick.alive = false;
              bullet = null;
              createExplosion(brick.x, brick.y, 'rgba(0, 174, 255, 1)');
              break bulletLoop;
            }
          }
        }
      }

      // Bomb collision with player or shields
      bombLoop:
      for(let i=bombs.length-1;i>=0;i--){
        const b = bombs[i];
        if(b.y > canvas.height){
          bombs.splice(i,1);
          continue;
        }
        if(Math.abs(b.x - player.x) < player.w/2 && Math.abs(b.y - player.y) < player.h/2){
          bombs.splice(i,1);
          createExplosion(player.x, player.y, 'rgba(255, 90, 90, 1)');
          lives--;
          updateInfo();
          if(lives <= 0){
            gameOver = true;
            nextLevel = false;
            createExplosion(player.x, player.y, 'rgba(255, 120, 120, 1)');
            document.getElementById('message').textContent = 'Game Over - Press Enter';
          }
          continue;
        }
        for(const bricks of shields){
          for(const brick of bricks){
            if(brick.alive && Math.abs(b.x - brick.x) < 5 && Math.abs(b.y - brick.y) < 5){
              brick.alive = false;
              bombs.splice(i,1);
              createExplosion(brick.x, brick.y, 'rgba(255, 196, 0, 1)');
              continue bombLoop;
            }
          }
        }
      }

      // Check aliens reaching bottom
      for(const a of aliens){
        if(a.alive && a.y + a.h/2 >= player.y - player.h){
          gameOver = true;
          nextLevel = false;
          createExplosion(player.x, player.y, 'rgba(255, 120, 120, 1)');
          document.getElementById('message').textContent = 'Game Over - Press Enter';
          break;
        }
      }

      // Check victory
      if(aliens.every(a => !a.alive)){
        gameOver = true;
        nextLevel = true;
        document.getElementById('message').textContent = 'Next Level - Press Enter';
      }
    }

    function draw(){
      drawBackground();
      drawPlayer();

      // draw bullet
      if(bullet){
        ctx.save();
        const gradient = ctx.createLinearGradient(bullet.x, bullet.y-12, bullet.x, bullet.y+4);
        gradient.addColorStop(0,'rgba(0,255,198,0.1)');
        gradient.addColorStop(0.4,'rgba(0,255,198,0.4)');
        gradient.addColorStop(1,'rgba(255,255,255,0.9)');
        ctx.fillStyle = gradient;
        ctx.fillRect(bullet.x-2, bullet.y-12, 4, 14);
        ctx.shadowBlur = 12;
        ctx.shadowColor = 'rgba(0,255,198,0.7)';
        ctx.fillRect(bullet.x-1, bullet.y-18, 2, 18);
        ctx.restore();
      }

      // draw aliens
      const time = performance.now();
      for(const a of aliens){
        if(a.alive){
          const wobble = Math.sin(time/540 + a.x*0.03 + a.wobble)*6;
          const breathe = 1 + Math.sin(time/820 + a.wobble)*0.08;
          const sprite = alienSprites[a.row % alienSprites.length];
          ctx.save();
          ctx.translate(a.x, a.y + wobble);
          ctx.shadowBlur = 20;
          ctx.shadowColor = `hsla(${180 + a.row*18}, 100%, 60%, 0.9)`;
          ctx.globalAlpha = 0.92;
          const drawW = a.w * breathe;
          const drawH = a.h * breathe;
          if(sprite && sprite.complete){
            ctx.drawImage(sprite, -drawW/2 - 12, -drawH/2 - 12, drawW + 24, drawH + 24);
          } else {
            const gradient = ctx.createLinearGradient(0, -drawH/2, 0, drawH/2);
            gradient.addColorStop(0,'rgba(0,255,198,0.8)');
            gradient.addColorStop(1,'rgba(0,157,255,0.8)');
            ctx.fillStyle = gradient;
            ctx.fillRect(-drawW/2, -drawH/2, drawW, drawH);
          }
          ctx.globalAlpha = 1;
          ctx.lineWidth = 1.5;
          ctx.strokeStyle = 'rgba(255,255,255,0.35)';
          ctx.beginPath();
          ctx.ellipse(0, drawH*0.38, drawW*0.46, drawH*0.2, 0, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }
      }

      // draw bombs
      for(const b of bombs){
        ctx.save();
        const g = ctx.createRadialGradient(b.x, b.y, 0, b.x, b.y, b.r*2.4);
        g.addColorStop(0,'rgba(255,255,255,1)');
        g.addColorStop(0.5,'rgba(255,196,0,0.9)');
        g.addColorStop(1,'rgba(255,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r*2.4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      // draw shields
      for(const bricks of shields){
        for(const brick of bricks){
          if(brick.alive){
            const gradient = ctx.createLinearGradient(brick.x-5, brick.y-5, brick.x+5, brick.y+5);
            gradient.addColorStop(0,'rgba(0, 174, 255, 0.9)');
            gradient.addColorStop(1,'rgba(0, 255, 198, 0.8)');
            ctx.fillStyle = gradient;
            ctx.fillRect(brick.x-5, brick.y-5, 10, 10);
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.strokeRect(brick.x-5, brick.y-5, 10, 10);
          }
        }
      }

      // draw explosions
      for(const ex of explosions){
        ctx.save();
        ctx.globalAlpha = ex.alpha;
        const g = ctx.createRadialGradient(ex.x, ex.y, ex.r*0.2, ex.x, ex.y, ex.r*2);
        g.addColorStop(0, ex.color);
        g.addColorStop(0.7, 'rgba(255,255,255,0.5)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(ex.x, ex.y, ex.r*2, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      drawSparks();
    }

    function drawBackground(){
      const gradient = ctx.createLinearGradient(0,0,0,canvas.height);
      gradient.addColorStop(0,'rgba(2, 8, 30, 1)');
      gradient.addColorStop(0.55,'rgba(4, 14, 44, 1)');
      gradient.addColorStop(1,'rgba(8, 10, 22, 1)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const horizon = ctx.createLinearGradient(0, canvas.height*0.55, 0, canvas.height);
      horizon.addColorStop(0, `rgba(0, 180, 255, ${horizonGlow.alpha})`);
      horizon.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = horizon;
      ctx.fillRect(0, canvas.height*0.45, canvas.width, canvas.height*0.55);

      ctx.save();
      ctx.translate(planet.x, planet.y);
      const planetGradient = ctx.createRadialGradient(-planet.r*0.25, -planet.r*0.3, planet.r*0.1, 0, 0, planet.r);
      planetGradient.addColorStop(0, 'rgba(120, 220, 255, 0.95)');
      planetGradient.addColorStop(0.45, 'rgba(36, 90, 180, 0.95)');
      planetGradient.addColorStop(1, 'rgba(8, 12, 28, 0.95)');
      ctx.fillStyle = planetGradient;
      ctx.beginPath();
      ctx.arc(0, 0, planet.r, 0, Math.PI*2);
      ctx.fill();
      ctx.rotate(planet.ringTilt);
      const ringGradient = ctx.createLinearGradient(-planet.r*1.7, 0, planet.r*1.7, 0);
      ringGradient.addColorStop(0,'rgba(0,0,0,0)');
      ringGradient.addColorStop(0.2,'rgba(0, 255, 198, 0.25)');
      ringGradient.addColorStop(0.5,'rgba(120, 200, 255, 0.45)');
      ringGradient.addColorStop(0.8,'rgba(0, 255, 198, 0.25)');
      ringGradient.addColorStop(1,'rgba(0,0,0,0)');
      ctx.strokeStyle = ringGradient;
      ctx.lineWidth = 18;
      ctx.beginPath();
      ctx.ellipse(0, 0, planet.r*1.4, planet.r*0.36, 0, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();

      for(const cloud of parallaxClouds){
        const g = ctx.createRadialGradient(cloud.x, cloud.y, cloud.r*0.2, cloud.x, cloud.y, cloud.r);
        g.addColorStop(0, `hsla(${cloud.hue}, 85%, 62%, ${cloud.alpha})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cloud.x, cloud.y, cloud.r, 0, Math.PI*2);
        ctx.fill();
      }

      for(const aurora of auroras){
        const g = ctx.createRadialGradient(aurora.x, aurora.y, aurora.r*0.2, aurora.x, aurora.y, aurora.r*1.2);
        g.addColorStop(0, `hsla(${aurora.hue % 360}, 90%, 65%, ${aurora.alpha})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(aurora.x, aurora.y, aurora.r, 0, Math.PI*2);
        ctx.fill();
      }

      ctx.lineWidth = 0.8;
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      for(const constellation of constellations){
        ctx.beginPath();
        constellation.points.forEach((p, idx) => {
          if(idx === 0){
            ctx.moveTo(p.x, p.y);
          } else {
            ctx.lineTo(p.x, p.y);
          }
        });
        ctx.stroke();
        for(const p of constellation.points){
          const glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, 6);
          glow.addColorStop(0, `rgba(255,255,255,${0.5 + constellation.glow*0.5})`);
          glow.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 6, 0, Math.PI*2);
          ctx.fill();
        }
      }

      for(const star of starfield){
        const sparkle = (Math.sin(star.twinkle) + 1)/2;
        ctx.fillStyle = `rgba(255,255,255,${0.25 + sparkle*0.75})`;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size + sparkle*0.7, 0, Math.PI*2);
        ctx.fill();
        if(star.trail){
          const tail = ctx.createLinearGradient(star.x, star.y-12, star.x, star.y+18);
          tail.addColorStop(0,'rgba(255,255,255,0)');
          tail.addColorStop(0.5,'rgba(0,255,198,0.5)');
          tail.addColorStop(1,'rgba(0,119,255,0)');
          ctx.fillStyle = tail;
          ctx.fillRect(star.x-1, star.y-12, 2, 24);
        }
      }
    }

    function drawPlayer(){
      const pulse = (Math.sin(player.pulse*1.4)+1)/2;
      ctx.save();
      ctx.translate(player.x, player.y - 6);
      const hover = Math.sin(player.pulse*1.2) * 4;
      ctx.translate(0, hover);
      ctx.shadowBlur = 24;
      ctx.shadowColor = 'rgba(0, 255, 198, 0.85)';

      // engine trail
      const flameLength = 26 + pulse*20;
      const flameGradient = ctx.createLinearGradient(0, player.h/2, 0, player.h/2 + flameLength);
      flameGradient.addColorStop(0,'rgba(0,255,198,0.0)');
      flameGradient.addColorStop(0.35,'rgba(0,255,198,0.45)');
      flameGradient.addColorStop(0.7,'rgba(255,180,0,0.65)');
      flameGradient.addColorStop(1,'rgba(255,64,0,0)');
      ctx.fillStyle = flameGradient;
      ctx.beginPath();
      ctx.moveTo(-6, player.h/2);
      ctx.lineTo(-2, player.h/2 + flameLength);
      ctx.lineTo(2, player.h/2 + flameLength);
      ctx.lineTo(6, player.h/2);
      ctx.closePath();
      ctx.fill();

      // ship body
      const shipGlow = ctx.createRadialGradient(0, -player.h*0.2, player.w*0.1, 0, 0, player.w*0.9);
      shipGlow.addColorStop(0,'rgba(255,255,255,0.6)');
      shipGlow.addColorStop(1,'rgba(0, 200, 255, 0.18)');
      ctx.fillStyle = shipGlow;
      ctx.beginPath();
      ctx.ellipse(0, 0, player.w*0.72, player.h*0.68, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.shadowBlur = 0;
      if(playerImg.complete){
        ctx.drawImage(playerImg, -player.w/2 - 16, -player.h/2 - 18, player.w + 32, player.h + 36);
      }

      ctx.restore();
    }

    function drawSparks(){
      for(const s of sparks){
        ctx.save();
        ctx.globalAlpha = Math.max(s.life,0);
        const g = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size*4);
        g.addColorStop(0, s.color);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size*4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    let last = performance.now();
    function loop(){
      const now = performance.now();
      const dt = Math.min(0.1, (now - last)/1000);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', (e) => {
      keys[e.key] = true;
      if(e.key === ' '){
        shoot();
      }
      if(e.key === 'Enter' && gameOver){
        if(nextLevel){
          startNextLevel();
        } else {
          startNewGame();
        }
      }
    });
    window.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    window.addEventListener('load', () => {
      startNewGame();
      loop();
    });
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if(placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
