<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Burger Builder</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #sidebar {
      width: 220px;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.2);
    }
    #sidebar ul { list-style:none; padding:0; margin:0; }
    #sidebar li { margin: 15px 0; }
    #sidebar a { color:#fff; text-decoration:none; }
    #game { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding:20px; }
    h1 { margin-top:0; font-size:2.5em; }
    canvas { background:#222; border:2px solid #fff; border-radius:8px; width:100%; height:auto; max-height:75vh; }
    #info { margin-top:10px; font-size:20px; }
    #message { margin-top:10px; font-size:24px; color:#ffeb3b; }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game">
    <h1>Burger Builder</h1>
    <canvas id="gameCanvas" width="640" height="480"></canvas>
    <div id="info"></div>
    <div id="message"></div>
  </div>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  // tile and level setup
  const COLS = 20;
  const ROWS = 15;
  const TILE = 32;
  canvas.width = COLS * TILE;
  canvas.height = ROWS * TILE;

  const floors = [3,7,11,15]; // grid rows for platforms (from top)
  const ladders = [
    {x:4, top:3, bottom:15},
    {x:10, top:3, bottom:15},
    {x:16, top:3, bottom:15}
  ];

  const burgerX = [6,10,14];
  const pieces = [];
  const types = ['top','lettuce','patty','bottom'];
  for(let col of burgerX){
    for(let i=0;i<types.length;i++){
      pieces.push({x:col, y:floors[i], type:types[i], falling:false});
    }
  }

  const player = {x:burgerX[0], y:floors[0], vx:0, vy:0, dir:1, pepper:3, width:1, height:1};
  let enemies = [ {x:18, y:floors[2], vx:-0.02, vy:0, width:1, height:1, stunned:0} ];

  let gameOver=false;
  let win=false;

  function isOnFloor(obj){
    return floors.includes(obj.y);
  }

  function pieceAt(x,y){
    return pieces.find(p=>p.x===x && p.y===y && !p.falling);
  }

  function update(){
    if(gameOver || win) return;
    // player movement
    if(keys.left) player.vx=-0.1; else if(keys.right) player.vx=0.1; else player.vx=0;
    player.x += player.vx;
    if(keys.up && ladderAt(Math.round(player.x), player.y)) player.y -=0.1;
    if(keys.down && ladderAt(Math.round(player.x), player.y)) player.y +=0.1;
    player.x = Math.max(0, Math.min(COLS-1, player.x));
    player.y = Math.max(1, Math.min(ROWS-1, player.y));

    const px=Math.round(player.x), py=Math.round(player.y);
    const piece = pieceAt(px, py);
    if(piece){
      piece.falling=true;
    }

    for(const p of pieces){
      if(p.falling){
        p.y+=0.1;
        const below = pieceAt(p.x, Math.round(p.y)+1);
        if(Math.round(p.y) >= ROWS || below){
          if(below){ below.falling=true; }
          p.falling=false;
          p.y = below ? below.y-1 : ROWS;
          if(p.y>=ROWS){
            // piece completed
            p.complete=true;
          }
        }
      }
    }

    // enemy movement
    for(const e of enemies){
      if(e.stunned>0){ e.stunned--; continue; }
      if(e.x < player.x) e.vx=0.05; else if(e.x>player.x) e.vx=-0.05; else e.vx=0;
      e.x += e.vx;
      e.x = Math.max(0, Math.min(COLS-1, e.x));
      // simple vertical chase
      if(Math.abs(e.x-player.x)<1 && ladderAt(Math.round(e.x), e.y)){
        if(e.y<player.y) e.y+=0.05; else if(e.y>player.y) e.y-=0.05;
      }
      const ex=Math.round(e.x), ey=Math.round(e.y);
      if(ex===px && ey===py){
        gameOver=true;
        document.getElementById('message').textContent='Game Over';
      }
    }

    if(pieces.every(p=>p.complete)){
      win=true;
      document.getElementById('message').textContent='You Win!';
    }

    document.getElementById('info').textContent=`Pepper: ${player.pepper}`;
  }

  function ladderAt(x,y){
    return ladders.some(l=>l.x===x && y>=l.top && y<=l.bottom);
  }

  function pepper(){
    if(player.pepper<=0) return;
    player.pepper--;
    for(const e of enemies){
      if(Math.abs(e.x-player.x)<=1 && Math.abs(e.y-player.y)<=1){
        e.stunned=100; // frames
      }
    }
  }

  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.scale(TILE, TILE);
    // floors
    ctx.fillStyle='#555';
    for(const f of floors){
      ctx.fillRect(0,f-0.1,COLS,0.1);
    }
    // ladders
    ctx.strokeStyle='#aaa';
    for(const l of ladders){
      ctx.beginPath();
      ctx.moveTo(l.x+0.5,l.top);
      ctx.lineTo(l.x+0.5,l.bottom);
      ctx.stroke();
    }
    // pieces
    for(const p of pieces){
      if(p.complete) continue;
      switch(p.type){
        case 'top': ctx.fillStyle='#d2691e'; break;
        case 'lettuce': ctx.fillStyle='#8fbc8f'; break;
        case 'patty': ctx.fillStyle='#8b4513'; break;
        case 'bottom': ctx.fillStyle='#cd853f'; break;
      }
      ctx.fillRect(p.x,p.y-1,2,1);
    }
    // player
    ctx.fillStyle='white';
    ctx.fillRect(player.x,player.y-1,1,1);
    // enemies
    ctx.fillStyle='red';
    for(const e of enemies){
      ctx.fillRect(e.x,e.y-1,1,1);
      if(e.stunned>0){
        ctx.fillStyle='blue';
        ctx.fillRect(e.x,e.y-1,1,1);
        ctx.fillStyle='red';
      }
    }
    ctx.restore();
  }

  const keys={};
  document.addEventListener('keydown',e=>{
    if(e.key==='ArrowLeft') keys.left=true;
    if(e.key==='ArrowRight') keys.right=true;
    if(e.key==='ArrowUp') keys.up=true;
    if(e.key==='ArrowDown') keys.down=true;
    if(e.key===' ') pepper();
  });
  document.addEventListener('keyup',e=>{
    if(e.key==='ArrowLeft') keys.left=false;
    if(e.key==='ArrowRight') keys.right=false;
    if(e.key==='ArrowUp') keys.up=false;
    if(e.key==='ArrowDown') keys.down=false;
  });

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r=>r.text())
      .then(html=>{const placeholder=document.getElementById('sidebar-placeholder'); if(placeholder) placeholder.outerHTML=html;});
  </script>
</body>
</html>

