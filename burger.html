<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Burger Builder</title>
  <style>
    :root {
      color-scheme: light;
      --glow-primary: #ff9d2f;
      --glow-secondary: #ffd65e;
      --panel: rgba(20, 12, 5, 0.75);
      --accent: #9cf6ff;
      --danger: #ff5f6d;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      overflow: hidden;
      background: radial-gradient(circle at 20% 20%, #ffecd8 0%, #ffbe5c 40%, #f9585d 120%);
      font-family: "Nunito", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff3d4;
      position: relative;
    }
    body::before,
    body::after {
      content: "";
      position: absolute;
      inset: -20vh;
      background: conic-gradient(from 120deg, rgba(255,255,255,0.08), rgba(0,0,0,0));
      animation: swirl 18s linear infinite;
      mix-blend-mode: screen;
      pointer-events: none;
    }
    body::after {
      animation-duration: 26s;
      animation-direction: reverse;
    }
    @keyframes swirl {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    #sidebar {
      width: 240px;
      background: var(--panel);
      padding: 24px 22px 32px;
      box-shadow: 0 0 24px rgba(0,0,0,0.45);
      backdrop-filter: blur(12px);
      z-index: 2;
    }
    #sidebar ul { list-style:none; padding:0; margin:0; }
    #sidebar li { margin: 18px 0; }
    #sidebar a {
      color:#ffe9c0;
      text-decoration:none;
      font-weight:600;
      letter-spacing:0.5px;
      transition: color 0.2s ease;
    }
    #sidebar a:hover {
      color: var(--accent);
    }
    #game {
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:28px 32px;
      position:relative;
      z-index:1;
    }
    h1 {
      margin: 0 0 12px;
      font-size: clamp(2.4rem, 3.8vw, 3.2rem);
      font-weight:800;
      letter-spacing: 1.5px;
      text-shadow: 0 6px 18px rgba(0,0,0,0.45);
    }
    h1 span {
      display:block;
      font-size:0.5em;
      font-weight:600;
      letter-spacing:3px;
      color: var(--accent);
    }
    #hud {
      display:flex;
      gap: 18px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:center;
      margin-bottom:16px;
    }
    .hud-chip {
      display:flex;
      align-items:center;
      gap:10px;
      background:rgba(14,8,4,0.75);
      padding:10px 16px;
      border-radius:999px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.08), 0 8px 16px rgba(0,0,0,0.35);
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:0.8px;
    }
    .hud-chip svg {
      width:20px;
      height:20px;
      fill:currentColor;
    }
    #gameCanvas-wrapper {
      position:relative;
      width:min(960px, 100%);
      aspect-ratio: 4 / 3;
      border-radius:24px;
      overflow:hidden;
      box-shadow: 0 40px 80px rgba(0,0,0,0.35);
      background: radial-gradient(circle at 50% 30%, rgba(255,255,255,0.35), rgba(0,0,0,0));
    }
    canvas {
      width:100%;
      height:100%;
      display:block;
    }
    #message {
      margin-top:18px;
      font-size: clamp(1.4rem, 2.8vw, 2rem);
      color:#fff6d9;
      text-shadow:0 0 12px rgba(255,248,210,0.6);
      min-height:1.5em;
      text-align:center;
    }
    #controls {
      margin-top:22px;
      background:rgba(16,9,3,0.72);
      padding:18px 24px;
      border-radius:18px;
      max-width:720px;
      line-height:1.6;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }
    #controls h2 {
      margin:0 0 8px;
      font-size:1.1rem;
      letter-spacing:1px;
      text-transform:uppercase;
      color:var(--accent);
    }
    #controls strong {
      color:#ffe9c0;
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game">
    <h1>Burger Blitz <span>Gourmet Showdown</span></h1>
    <div id="hud">
      <div class="hud-chip" id="hud-level"></div>
      <div class="hud-chip" id="hud-score"></div>
      <div class="hud-chip" id="hud-lives"></div>
      <div class="hud-chip" id="hud-pepper"></div>
    </div>
    <div id="gameCanvas-wrapper">
      <canvas id="gameCanvas" width="960" height="720"></canvas>
    </div>
    <div id="message"></div>
    <section id="controls">
      <h2>How to Play</h2>
      <p>
        Assemble towering gourmet burgers while dodging mischievous food foes. Use the
        <strong>Arrow Keys</strong> to move and climb, and tap <strong>Space</strong>
        to unleash a burst of pepper spray that stuns anything in front of you.
        Collect neon condiments for bonus points and keep the ingredients dropping to
        complete each level's mega stack!
      </p>
    </section>
  </div>
  <script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const TILE = 40;
const COLS = 24;
const ROWS = 18;
canvas.width = COLS * TILE;
canvas.height = ROWS * TILE;

const ASSET_PATHS = {
  cook: 'images/cook.svg',
  burger_top: 'images/burger_top.svg',
  burger_lettuce: 'images/burger_lettuce.svg',
  burger_patty: 'images/burger_patty.svg',
  burger_bottom: 'images/burger_bottom.svg',
  enemy_fries: 'images/enemy_fries.svg',
  enemy_hotdog: 'images/enemy_hotdog.svg',
  enemy_soda: 'images/enemy_soda.svg',
  condiment_ketchup: 'images/condiment_ketchup.svg',
  condiment_cheese: 'images/condiment_cheese.svg'
};

const assets = {};
function loadAssets(){
  const promises = Object.entries(ASSET_PATHS).map(([key, src]) => new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => { assets[key] = img; resolve(); };
    img.onerror = reject;
    img.src = src;
  }));
  return Promise.all(promises);
}

const burgerLayers = ['top','lettuce','patty','bottom'];

const levels = [
  {
    name: 'Sunset Kitchen',
    floors: [3,6,9,12,15,18],
    ladders: [
      {x:3, top:3, bottom:18},
      {x:7, top:3, bottom:18},
      {x:11, top:3, bottom:18},
      {x:15, top:3, bottom:18},
      {x:19, top:3, bottom:18},
      {x:22, top:6, bottom:18}
    ],
    burgerX: [4,9,14,19],
    condiments: [
      {x:6, floor:1, type:'condiment_ketchup', score:250},
      {x:13, floor:2, type:'condiment_cheese', score:350},
      {x:17, floor:0, type:'condiment_ketchup', score:250}
    ],
    enemyWaves: [
      {type:'fries', x:22, floor:2, delay:0},
      {type:'soda', x:2, floor:3, delay:180},
      {type:'hotdog', x:20, floor:0, delay:360}
    ]
  },
  {
    name: 'Neon Rooftop',
    floors: [2.5,5.5,8.5,11.5,14.5,17.8],
    ladders: [
      {x:2.5, top:2.5, bottom:17.8},
      {x:6.5, top:2.5, bottom:17.8},
      {x:10.5, top:2.5, bottom:17.8},
      {x:14.5, top:2.5, bottom:17.8},
      {x:18.5, top:2.5, bottom:17.8},
      {x:21.5, top:5.5, bottom:17.8}
    ],
    burgerX: [3.5,8.5,13.5,18.5],
    condiments: [
      {x:5.5, floor:1, type:'condiment_cheese', score:350},
      {x:16.5, floor:3, type:'condiment_ketchup', score:250},
      {x:10.5, floor:4, type:'condiment_cheese', score:400}
    ],
    enemyWaves: [
      {type:'soda', x:1.5, floor:2, delay:0},
      {type:'fries', x:22, floor:4, delay:120},
      {type:'hotdog', x:20, floor:1, delay:240},
      {type:'soda', x:2, floor:0, delay:420}
    ]
  }
];

const player = {
  x: 0,
  y: 0,
  vx: 0,
  vy: 0,
  width: 1,
  height: 1,
  dir: 1,
  pepper: 4,
  cooldown: 0,
  invulnerable: 0
};

const enemyTypes = {
  fries: { speed: 0.06, climbSpeed: 0.07, stunTime: 140 },
  hotdog: { speed: 0.08, climbSpeed: 0.06, dashSpeed: 0.17, dashCooldown: 210, stunTime: 170 },
  soda: { speed: 0.05, climbSpeed: 0.09, floatSpeed: 0.12, stunTime: 150 }
};

let levelIndex = 0;
let floors = [];
let ladders = [];
let burgerColumns = [];
const pieces = [];
let condiments = [];
const pepperBursts = [];
const particles = [];
const floatingText = [];
let enemies = [];
let pendingSpawns = [];
const completedStacks = new Map();

let score = 0;
let lives = 3;
let combo = 0;
let comboTimer = 0;
let gameOver = false;
let win = false;

const FRAME_TIME = 1000 / 60;
let accumulator = 0;
let lastTimestamp = performance.now();

const skylineShapes = Array.from({length: 10}, () => ({
  x: Math.random() * canvas.width,
  width: 80 + Math.random() * 120,
  height: 60 + Math.random() * 160
}));

const hudLevel = document.getElementById('hud-level');
const hudScore = document.getElementById('hud-score');
const hudLives = document.getElementById('hud-lives');
const hudPepper = document.getElementById('hud-pepper');

function updateHud(){
  hudLevel.innerHTML = `
    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 2l2.6 5.6 6.2.5-4.7 4.2 1.4 6-5.5-3.1-5.5 3.1 1.4-6-4.7-4.2 6.2-.5z"></path></svg>
    Level ${levelIndex + 1}`;
  hudScore.innerHTML = `
    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M4 4h16v4H4zm2 6h12v4H6zm-2 6h16v4H4z"></path></svg>
    Score ${score.toLocaleString()}`;
  hudLives.innerHTML = `
    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M12 21s-6.7-4.4-9.2-8.6C-0.4 8.7 1.8 3.5 6 3.1c2.2-.2 4 1 5.1 2.6 1.1-1.6 2.9-2.8 5.1-2.6 4.2.4 6.4 5.6 3.2 9.3C18.7 16.6 12 21 12 21z"></path></svg>
    Lives ${lives}`;
  const pepperGlow = player.pepper <= 1 ? 'style="color: var(--danger);"' : '';
  hudPepper.innerHTML = `
    <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M6 13c0-4 3.1-7 7-7 .9 0 1.7.2 2.5.5.8-1.5 2-2.5 3.5-2.5-.3 1.8-1.1 3.2-2.3 3.8.2.7.3 1.5.3 2.3 0 4.5-3.2 8.4-7.1 9.6C7.7 18.1 6 15.7 6 13z"></path></svg>
    <span ${pepperGlow}>Pepper ${player.pepper}</span>`;
}

function resetCombo(){
  combo = 0;
  comboTimer = 0;
}

function addScore(amount, x, y, color = '#ffe27a'){
  score += amount;
  floatingText.push({ x: x ?? player.x + 0.5, y: y ?? player.y - 0.2, text: `+${amount}`, life: 90, color });
  updateHud();
}

function spawnParticles(x, y, color, count = 12){
  for(let i = 0; i < count; i++){
    const angle = Math.random() * Math.PI * 2;
    const speed = 0.05 + Math.random() * 0.12;
    particles.push({
      x,
      y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 0.03,
      life: 60 + Math.random() * 30,
      color,
      size: 0.08 + Math.random() * 0.08
    });
  }
}

function loadLevel(index){
  levelIndex = index % levels.length;
  const level = levels[levelIndex];
  floors = level.floors.slice();
  ladders = level.ladders.map(l => ({...l}));
  burgerColumns = level.burgerX.slice();
  pieces.length = 0;
  completedStacks.clear();
  condiments = level.condiments.map(c => ({
    x: c.x,
    y: floors[c.floor] - 0.35,
    type: c.type,
    score: c.score,
    bob: Math.random() * Math.PI * 2,
    collected: false,
    fade: 0
  }));
  pendingSpawns = level.enemyWaves.map(w => ({...w}));
  enemies = [];
  player.pepper = 4;
  for(const column of burgerColumns){
    for(let i = 0; i < burgerLayers.length; i++){
      pieces.push({
        x: column,
        y: floors[i],
        type: burgerLayers[i],
        falling: false,
        floorIndex: i,
        remaining: 0,
        support: null,
        complete: false,
        scored: false
      });
    }
    completedStacks.set(column, []);
  }
  resetActors();
  resetCombo();
  gameOver = false;
  win = false;
  document.getElementById('message').textContent = `${level.name}`;
  setTimeout(() => {
    if(!win && !gameOver) document.getElementById('message').textContent = '';
  }, 1800);
  updateHud();
}

function resetActors(){
  player.x = burgerColumns[0] + 0.5;
  player.y = floors[0];
  player.vx = 0;
  player.vy = 0;
  player.dir = 1;
  player.cooldown = 0;
  player.invulnerable = 60;
}

function spawnEnemy(type, data = {}){
  const def = enemyTypes[type];
  if(!def) return;
  const floorIdx = Math.max(0, Math.min(floors.length - 1, data.floor ?? 0));
  const enemy = {
    type,
    x: data.x ?? burgerColumns[Math.floor(Math.random() * burgerColumns.length)],
    y: floors[floorIdx],
    vx: 0,
    vy: 0,
    width: 1,
    height: 1,
    dir: data.dir ?? -1,
    stunned: 0,
    timer: 0,
    floatPhase: Math.random() * Math.PI * 2
  };
  enemies.push(enemy);
}

function isOnFloor(obj){
  return floors.some(f => Math.abs(obj.y - f) < 0.1);
}

function isOnPiece(obj){
  return pieces.some(p => !p.complete && Math.abs(obj.y - (p.y - 1)) < 0.12 && obj.x >= p.x && obj.x <= p.x + 2);
}

function pieceUnder(obj){
  return pieces.find(p => !p.complete && Math.abs(obj.y - (p.y - 1)) < 0.12 && obj.x >= p.x && obj.x <= p.x + 2);
}

function enemiesOnPiece(piece){
  return enemies.filter(e => Math.abs(e.y - (piece.y - 1)) < 0.1 && e.x >= piece.x && e.x <= piece.x + 2).length;
}

function triggerFall(piece){
  if(piece.falling || piece.complete) return;
  piece.falling = true;
  piece.remaining = 1 + enemiesOnPiece(piece);
  piece.support = null;
  combo++;
  comboTimer = 240;
  floatingText.push({ x: piece.x + 1, y: piece.y - 1.4, text: `Combo x${combo}`, life: 70, color: '#9cf6ff' });
  spawnParticles(piece.x + 1, piece.y - 0.5, '#ffcf5d', 8);
}

function ladderAt(x, y){
  return ladders.some(l => Math.abs(l.x - x) < 0.35 && y >= l.top - 0.25 && y <= l.bottom);
}

function ridePieces(entity){
  for(const p of pieces){
    if(p.falling && entity.x >= p.x && entity.x <= p.x + 2 && Math.abs(entity.y - (p.y - 1)) < 0.12){
      entity.y += 0.1;
    }
  }
}

function climbOntoPiece(entity){
  for(const p of pieces){
    if(!p.falling && !p.complete && Math.abs(entity.y - p.y) < 0.12 && entity.x >= p.x && entity.x <= p.x + 2){
      entity.y = p.y - 1;
      break;
    }
  }
}

function applyGravity(entity){
  if(!isOnFloor(entity) && !isOnPiece(entity) && !ladderAt(entity.x, entity.y)){
    entity.y += 0.12;
  }
}

function finalizePiece(piece){
  if(piece.complete) return;
  piece.y = ROWS;
  piece.falling = false;
  piece.complete = true;
  const stack = completedStacks.get(piece.x) ?? [];
  stack.push(piece.type);
  completedStacks.set(piece.x, stack);
  const stackHeight = stack.length;
  const bonus = 400 + stackHeight * 120 + combo * 50;
  addScore(bonus, piece.x + 1, ROWS - stackHeight * 0.6, '#ffd65e');
  spawnParticles(piece.x + 1, ROWS - stackHeight * 0.6, '#ff9d2f', 18);
}

function updatePieces(){
  for(const p of pieces){
    if(!p.falling) continue;
    let safety = 0;
    while(p.falling && safety < floors.length + 2){
      safety++;
      if(p.support){
        p.y = p.support.y - 1;
        if(!p.support.falling){
          p.floorIndex = p.support.floorIndex;
          if(p.remaining > 0) p.remaining--;
          if(p.remaining <= 0){
            p.falling = false;
            if(p.y >= ROWS) finalizePiece(p);
          } else {
            p.support = null;
          }
        }
        continue;
      }

      p.y += 0.22;

      const belowPiece = pieces.find(o => o !== p && !o.complete && Math.abs(p.y - (o.y - 1)) < 0.05 && p.x + 2 > o.x && p.x < o.x + 2);
      if(belowPiece){
        p.y = belowPiece.y - 1;
        p.floorIndex = belowPiece.floorIndex;
        if(p.remaining > 0) p.remaining--;
        p.support = belowPiece;
        triggerFall(belowPiece);
        continue;
      }

      const nextFloor = floors[p.floorIndex + 1];
      if(nextFloor !== undefined && p.y >= nextFloor){
        p.y = nextFloor;
        p.floorIndex++;
        if(p.remaining > 0) p.remaining--;
        if(p.remaining <= 0){
          p.falling = false;
          if(p.y >= ROWS) finalizePiece(p);
        }
        continue;
      }

      if(p.floorIndex >= floors.length - 1 && p.y >= ROWS){
        finalizePiece(p);
      }
      break;
    }
  }
}

function playerHit(){
  if(player.invulnerable > 0 || gameOver || win) return;
  lives--;
  spawnParticles(player.x + 0.5, player.y - 0.5, '#ff5f6d', 24);
  document.getElementById('message').textContent = lives > 0 ? 'Ouch! Stay saucy!' : 'Game Over';
  if(lives > 0){
    resetActors();
    enemies.forEach(e => e.stunned = enemyTypes[e.type].stunTime / 2);
    setTimeout(() => {
      if(!win) document.getElementById('message').textContent = '';
    }, 1500);
  } else {
    gameOver = true;
  }
  updateHud();
  resetCombo();
}

function updatePepperBursts(){
  for(let i = pepperBursts.length - 1; i >= 0; i--){
    const burst = pepperBursts[i];
    burst.x += burst.dir * 0.45;
    burst.life--;
    spawnParticles(burst.x, burst.y, 'rgba(156,246,255,0.5)', 2);
    for(const enemy of enemies){
      if(enemy.stunned > 0) continue;
      if(Math.abs(enemy.x + 0.5 - burst.x) < 0.8 && Math.abs(enemy.y - burst.y) < 0.9){
        const def = enemyTypes[enemy.type];
        enemy.stunned = def.stunTime;
        enemy.vx = 0;
        addScore(150, enemy.x + 0.5, enemy.y - 0.6, '#9cf6ff');
        spawnParticles(enemy.x + 0.5, enemy.y - 0.5, '#9cf6ff', 16);
      }
    }
    if(burst.life <= 0 || burst.x < -1 || burst.x > COLS + 1){
      pepperBursts.splice(i, 1);
    }
  }
}

function updateParticles(){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.01;
    p.life--;
    if(p.life <= 0){
      particles.splice(i, 1);
    }
  }
}

function updateFloatingText(){
  for(let i = floatingText.length - 1; i >= 0; i--){
    const ft = floatingText[i];
    ft.y -= 0.02;
    ft.life--;
    if(ft.life <= 0){
      floatingText.splice(i, 1);
    }
  }
}

function updateCondiments(){
  for(let i = condiments.length - 1; i >= 0; i--){
    const c = condiments[i];
    if(c.collected){
      c.fade++;
      if(c.fade > 30){
        condiments.splice(i, 1);
      }
      continue;
    }
    c.bob += 0.12;
    if(Math.abs(player.x - c.x) < 0.6 && Math.abs(player.y - c.y) < 0.8){
      c.collected = true;
      player.pepper = Math.min(player.pepper + 1, 6);
      addScore(c.score, c.x + 0.4, c.y - 0.6, '#ff90e8');
      floatingText.push({ x: c.x + 0.4, y: c.y - 1, text: 'Pepper +1', life: 70, color: '#9cf6ff' });
      spawnParticles(c.x + 0.4, c.y - 0.5, '#ff90e8', 20);
      updateHud();
    }
  }
}

function handlePlayer(){
  if(player.cooldown > 0) player.cooldown--;
  if(player.invulnerable > 0) player.invulnerable--;

  const alignedLadder = ladderAt(player.x, player.y);
  const nearFloor = floors.some(f => Math.abs(player.y - f) < 0.18);
  if(isOnFloor(player) || isOnPiece(player) || (alignedLadder && nearFloor)){
    if(keys.left){
      player.vx = -0.14;
      player.dir = -1;
    } else if(keys.right){
      player.vx = 0.14;
      player.dir = 1;
    } else {
      player.vx = 0;
    }
  } else {
    player.vx *= 0.92;
  }

  player.x += player.vx;
  climbOntoPiece(player);

  const onLadder = ladderAt(player.x, player.y);
  const movingVertically = (keys.up && onLadder) || (keys.down && onLadder);

  if(keys.up && onLadder) player.y -= 0.12;
  if(keys.down && onLadder) player.y += 0.12;

  if(onLadder && !movingVertically){
    const snapFloor = floors.find(f => Math.abs(player.y - f) < 0.18);
    if(snapFloor !== undefined){
      player.y = snapFloor;
    }
  }

  player.x = Math.max(0.2, Math.min(COLS - 1.2, player.x));
  player.y = Math.max(0.8, Math.min(ROWS, player.y));

  const piece = pieceUnder(player);
  if(piece){
    triggerFall(piece);
  }

  ridePieces(player);
  applyGravity(player);
}

function handleEnemies(){
  for(const enemy of enemies){
    enemy.timer++;
    if(enemy.stunned > 0){
      enemy.stunned--;
      ridePieces(enemy);
      applyGravity(enemy);
      continue;
    }

    const def = enemyTypes[enemy.type];
    if(isOnFloor(enemy) || isOnPiece(enemy)){
      if(Math.abs(enemy.x - player.x) > 0.2){
        enemy.dir = enemy.x < player.x ? 1 : -1;
        enemy.vx = enemy.dir * def.speed;
      } else {
        enemy.vx = 0;
      }
    }

    if(enemy.type === 'hotdog' && enemy.timer % def.dashCooldown === 0){
      if(Math.abs(enemy.y - player.y) < 0.8){
        enemy.vx = (enemy.x < player.x ? 1 : -1) * def.dashSpeed;
        spawnParticles(enemy.x + 0.5, enemy.y - 0.5, '#ff5f6d', 12);
      }
    }

    if(enemy.type === 'soda'){
      enemy.floatPhase += def.floatSpeed;
      enemy.vx += Math.sin(enemy.floatPhase) * 0.005;
    }

    enemy.x += enemy.vx;
    climbOntoPiece(enemy);

    if(Math.abs(enemy.x - player.x) < 1 && ladderAt(enemy.x, enemy.y)){
      if(enemy.y < player.y) enemy.y += def.climbSpeed;
      else if(enemy.y > player.y) enemy.y -= def.climbSpeed * 0.85;
    }

    enemy.x = Math.max(0, Math.min(COLS - 1, enemy.x));
    enemy.y = Math.max(0.8, Math.min(ROWS, enemy.y));

    const piece = pieceUnder(enemy);
    if(piece){
      triggerFall(piece);
    }

    ridePieces(enemy);
    applyGravity(enemy);

    if(Math.abs(enemy.x - player.x) < 0.6 && Math.abs(enemy.y - player.y) < 0.7){
      playerHit();
    }
  }
}

function updateSpawns(){
  for(let i = pendingSpawns.length - 1; i >= 0; i--){
    const spawn = pendingSpawns[i];
    spawn.delay--;
    if(spawn.delay <= 0){
      spawnEnemy(spawn.type, spawn);
      pendingSpawns.splice(i, 1);
    }
  }
  if(enemies.length < 2 && pendingSpawns.length === 0 && Math.random() < 0.01){
    const types = Object.keys(enemyTypes);
    const type = types[Math.floor(Math.random() * types.length)];
    spawnEnemy(type, { floor: Math.floor(Math.random() * floors.length), x: Math.random() < 0.5 ? 1 : COLS - 2 });
  }
}

function stepGame(){
  updatePepperBursts();
  updateParticles();
  updateFloatingText();
  updateCondiments();

  if(gameOver || win) return;

  if(comboTimer > 0){
    comboTimer--;
    if(comboTimer <= 0) resetCombo();
  }

  updateSpawns();
  handlePlayer();
  updatePieces();
  handleEnemies();

  if(pieces.every(p => p.complete)){
    if(!win){
      win = true;
      addScore(1500, player.x + 0.5, player.y - 1, '#ffe27a');
      document.getElementById('message').textContent = 'Level Complete!';
      setTimeout(() => {
        document.getElementById('message').textContent = '';
        loadLevel(levelIndex + 1);
      }, 2400);
    }
  }
}

function drawBackground(){
  ctx.fillStyle = '#120805';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  const radial = ctx.createRadialGradient(canvas.width * 0.5, canvas.height * 0.22, 60, canvas.width * 0.5, canvas.height * 0.22, canvas.width * 0.9);
  radial.addColorStop(0, 'rgba(255, 214, 163, 0.35)');
  radial.addColorStop(1, 'rgba(18, 8, 5, 0)');
  ctx.fillStyle = radial;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
  const skylineHeight = canvas.height * 0.55;
  for(const building of skylineShapes){
    ctx.fillRect(building.x, skylineHeight - building.height, building.width, building.height);
  }
}

function drawPlates(){
  ctx.save();
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  ctx.fillStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 0.04;
  for(const column of burgerColumns){
    ctx.beginPath();
    ctx.ellipse(column + 1, ROWS - 0.15, 1.4, 0.35, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }
  ctx.restore();
}

function drawFloors(){
  for(const f of floors){
    const grad = ctx.createLinearGradient(0, f - 0.12, 0, f + 0.12);
    grad.addColorStop(0, 'rgba(255, 182, 108, 0.9)');
    grad.addColorStop(1, 'rgba(200, 120, 60, 0.9)');
    ctx.fillStyle = grad;
    ctx.fillRect(-1, f - 0.12, COLS + 2, 0.24);
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fillRect(-1, f - 0.14, COLS + 2, 0.02);
  }
}

function drawLadders(){
  ctx.save();
  ctx.lineWidth = 0.05;
  for(const l of ladders){
    const grad = ctx.createLinearGradient(l.x, l.top, l.x, l.bottom);
    grad.addColorStop(0, '#fffd9a');
    grad.addColorStop(1, '#ffb347');
    ctx.strokeStyle = grad;
    ctx.beginPath();
    ctx.moveTo(l.x + 0.25, l.top);
    ctx.lineTo(l.x + 0.25, l.bottom);
    ctx.moveTo(l.x + 0.75, l.top);
    ctx.lineTo(l.x + 0.75, l.bottom);
    for(let y = l.top + 0.5; y < l.bottom; y += 0.5){
      ctx.moveTo(l.x + 0.25, y);
      ctx.lineTo(l.x + 0.75, y);
    }
    ctx.stroke();
  }
  ctx.restore();
}

function drawCondiments(){
  for(const c of condiments){
    const img = assets[c.type];
    if(!img) continue;
    const bob = Math.sin(c.bob) * 0.15;
    const alpha = c.collected ? Math.max(0, 1 - c.fade / 30) : 1;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.drawImage(img, c.x - 0.4, c.y - 0.8 + bob, 0.8, 0.8);
    ctx.restore();
  }
}

function drawPieces(){
  for(const p of pieces){
    if(p.complete) continue;
    const img = assets[`burger_${p.type}`];
    if(!img) continue;
    ctx.drawImage(img, p.x, p.y - 1, 2, 1);
  }
}

function drawCompletedStacks(){
  for(const [column, stack] of completedStacks.entries()){
    for(let i = 0; i < stack.length; i++){
      const type = stack[i];
      const img = assets[`burger_${type}`];
      if(!img) continue;
      const y = ROWS - 0.6 - i * 0.75;
      ctx.drawImage(img, column, y - 0.4, 2, 1);
    }
  }
}

function drawPepperBursts(){
  ctx.save();
  ctx.fillStyle = 'rgba(156,246,255,0.9)';
  for(const burst of pepperBursts){
    ctx.beginPath();
    ctx.ellipse(burst.x, burst.y, 0.6, 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function drawPlayer(){
  const sprite = assets.cook;
  if(!sprite) return;
  ctx.save();
  if(player.dir < 0){
    ctx.translate(player.x + 0.6, player.y - 1);
    ctx.scale(-1, 1);
    ctx.drawImage(sprite, -0.6, 0, 1.2, 1.2);
    if(player.invulnerable > 0){
      ctx.globalAlpha = 0.4 + 0.6 * Math.sin(player.invulnerable * 0.3);
      ctx.drawImage(sprite, -0.6, 0, 1.2, 1.2);
    }
  } else {
    ctx.translate(player.x - 0.4, player.y - 1);
    ctx.drawImage(sprite, 0, 0, 1.2, 1.2);
    if(player.invulnerable > 0){
      ctx.globalAlpha = 0.4 + 0.6 * Math.sin(player.invulnerable * 0.3);
      ctx.drawImage(sprite, 0, 0, 1.2, 1.2);
    }
  }
  ctx.restore();
}

function drawEnemies(){
  for(const enemy of enemies){
    const sprite = assets[`enemy_${enemy.type}`];
    if(!sprite) continue;
    ctx.save();
    if(enemy.dir < 0){
      ctx.translate(enemy.x + 0.6, enemy.y - 1);
      ctx.scale(-1, 1);
      ctx.drawImage(sprite, -0.6, 0, 1.2, 1.2);
      if(enemy.stunned > 0){
        ctx.globalAlpha = 0.6;
        ctx.drawImage(sprite, -0.6, 0, 1.2, 1.2);
      }
    } else {
      ctx.translate(enemy.x - 0.4, enemy.y - 1);
      ctx.drawImage(sprite, 0, 0, 1.2, 1.2);
      if(enemy.stunned > 0){
        ctx.globalAlpha = 0.6;
        ctx.drawImage(sprite, 0, 0, 1.2, 1.2);
      }
    }
    ctx.restore();
  }
}

function drawParticles(){
  ctx.save();
  for(const p of particles){
    ctx.globalAlpha = Math.max(0, Math.min(1, p.life / 90));
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();
}

function drawFloatingText(){
  ctx.save();
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  for(const ft of floatingText){
    ctx.globalAlpha = Math.max(0, Math.min(1, ft.life / 90));
    ctx.fillStyle = ft.color;
    ctx.font = '0.6px "Nunito", sans-serif';
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.restore();
}

function draw(){
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  drawBackground();
  ctx.save();
  ctx.scale(TILE, TILE);
  drawPlates();
  drawFloors();
  drawLadders();
  drawCondiments();
  drawCompletedStacks();
  drawPieces();
  drawPepperBursts();
  drawPlayer();
  drawEnemies();
  drawParticles();
  drawFloatingText();
  ctx.restore();
}

const keys = {};
document.addEventListener('keydown', e => {
  if(e.key === 'ArrowLeft') keys.left = true;
  if(e.key === 'ArrowRight') keys.right = true;
  if(e.key === 'ArrowUp') keys.up = true;
  if(e.key === 'ArrowDown') keys.down = true;
  if(e.code === 'Space'){
    e.preventDefault();
    usePepper();
  }
  if(e.key === 'r' || e.key === 'R'){
    if(gameOver){
      lives = 3;
      score = 0;
    }
    loadLevel(levelIndex);
  }
});

document.addEventListener('keyup', e => {
  if(e.key === 'ArrowLeft') keys.left = false;
  if(e.key === 'ArrowRight') keys.right = false;
  if(e.key === 'ArrowUp') keys.up = false;
  if(e.key === 'ArrowDown') keys.down = false;
});

window.addEventListener('blur', () => {
  keys.left = keys.right = keys.up = keys.down = false;
});

function usePepper(){
  if(player.pepper <= 0 || player.cooldown > 0 || gameOver || win) return;
  player.pepper--;
  player.cooldown = 18;
  const burst = {
    x: player.x + (player.dir > 0 ? 1 : 0),
    y: player.y - 0.5,
    dir: player.dir > 0 ? 1 : -1,
    life: 16
  };
  pepperBursts.push(burst);
  spawnParticles(burst.x, burst.y, '#9cf6ff', 14);
  updateHud();
}

function gameLoop(timestamp){
  const delta = timestamp - lastTimestamp;
  lastTimestamp = timestamp;
  accumulator += delta;
  while(accumulator >= FRAME_TIME){
    stepGame();
    accumulator -= FRAME_TIME;
  }
  draw();
  requestAnimationFrame(gameLoop);
}

loadAssets().then(() => {
  updateHud();
  loadLevel(0);
  requestAnimationFrame(gameLoop);
});

  </script>
  <script>
    fetch('sidebar.html')
      .then(r=>r.text())
      .then(html=>{const placeholder=document.getElementById('sidebar-placeholder'); if(placeholder) placeholder.outerHTML=html;});
  </script>
</body>
</html>

