<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tanks</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg, #556270 0%, #4ecdc4 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul { list-style:none; padding:0; margin:0; }
    #sidebar li { margin:15px 0; }
    #sidebar a { color:#fff; text-decoration:none; transition:color 0.3s; }
    #sidebar a:hover { color:#ffea00; }
    #game-container {
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:flex-start;
      padding:20px;
    }
    canvas {
      background:#222;
      border:2px solid #fff;
      border-radius:8px;
      width:100%;
      height:auto;
      max-height:80vh;
    }
    #info { margin-top:10px; font-size:20px; }
    #message { margin-top:10px; font-size:24px; color:#ffeb3b; }
    html,
    body {
      height: 100%;
    }
    body {
      justify-content: center;
      overflow: hidden;
    }
    #sidebar-placeholder {
      display: none;
    }
    #game-container {
      position: relative;
      justify-content: center;
      width: min(1200px, 100%);
      max-width: calc(100vw - 32px);
      height: 100vh;
      padding: 24px;
      gap: 0;
    }
    h1 {
      display: none;
    }
    canvas {
      width: 100%;
      height: 100%;
      max-height: calc(100vh - 32px);
      border-radius: 18px;
      box-shadow: 0 0 30px rgba(0, 0, 0, 0.4);
    }
    #info {
      position: absolute;
      top: 16px;
      left: 16px;
      margin: 0;
      font-size: 18px;
      letter-spacing: 1px;
      text-transform: uppercase;
      padding: 10px 14px;
      border-radius: 16px;
      background: rgba(12, 18, 46, 0.65);
      box-shadow: 0 0 18px rgba(120, 190, 255, 0.35);
      z-index: 3;
    }
    #options {
      position: absolute;
      top: 64px;
      right: 16px;
      padding: 10px 14px;
      border-radius: 16px;
      background: rgba(12, 18, 46, 0.65);
      box-shadow: 0 0 18px rgba(120, 190, 255, 0.35);
      font-size: 14px;
      z-index: 3;
    }
    #options label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
    }
    #message {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 20px;
      background: rgba(0, 0, 0, 0.45);
      padding: 10px 18px;
      border-radius: 999px;
      min-height: 28px;
      z-index: 3;
    }
    #restartBtn {
      position: absolute;
      bottom: 18px;
      left: 16px;
      border: none;
      border-radius: 999px;
      background: rgba(0, 174, 255, 0.9);
      color: #021c33;
      font-weight: 700;
      letter-spacing: 1px;
      padding: 8px 16px;
      cursor: pointer;
      z-index: 3;
    }
    #touch-controls {
      position: absolute;
      inset: 0;
      display: none;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 22px 20px;
      pointer-events: none;
      z-index: 3;
    }
    .control-cluster {
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }
    .control-row {
      display: flex;
      gap: 12px;
      pointer-events: none;
    }
    .control-button {
      width: clamp(58px, 16vw, 86px);
      height: clamp(58px, 16vw, 86px);
      border-radius: 999px;
      border: 2px solid rgba(0, 174, 255, 0.5);
      background: rgba(4, 20, 68, 0.55);
      color: rgba(255, 255, 255, 0.9);
      font-size: clamp(1.2rem, 4.5vw, 1.8rem);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      touch-action: none;
      backdrop-filter: blur(6px);
      transition: background 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .control-button.pressed,
    .control-button:active {
      background: rgba(0, 174, 255, 0.25);
      border-color: rgba(140, 220, 255, 0.9);
      box-shadow: 0 0 24px rgba(0, 174, 255, 0.45);
    }
    body.touch-device #touch-controls {
      display: flex;
    }
    #help-button {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid rgba(0, 174, 255, 0.55);
      background: rgba(4, 20, 68, 0.45);
      color: rgba(255, 255, 255, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      z-index: 1001;
      backdrop-filter: blur(6px);
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    #help-button:hover,
    #help-button:focus-visible {
      border-color: rgba(140, 220, 255, 0.9);
      background: rgba(0, 174, 255, 0.25);
    }
    #instruction-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 23, 0.78);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
      padding: 24px;
      text-align: left;
    }
    #instruction-modal.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    #instruction-card {
      max-width: 540px;
      width: 100%;
      background: rgba(4, 20, 68, 0.95);
      border: 1px solid rgba(0, 174, 255, 0.35);
      border-radius: 18px;
      padding: 20px 22px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
    }
    #instruction-card h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #7ad9ff;
    }
    #instruction-card p {
      margin: 8px 0;
      color: #d2efff;
      line-height: 1.5;
    }
    #instruction-close {
      margin-top: 14px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: none;
      background: rgba(0, 174, 255, 0.9);
      color: #021c33;
      font-weight: 700;
      letter-spacing: 1px;
      cursor: pointer;
    }
    @media (pointer: fine) {
      #help-button {
        display: flex;
      }
    }
  </style>
  <link rel="stylesheet" href="../sidebar.css" />
  <link rel="stylesheet" href="../flyout.css" />
  <script src="../flyout.js" defer></script>
</head>
<body>
  <div id="flyout-nav" class="flyout-nav" aria-hidden="true">
    <button class="flyout-toggle" type="button" aria-label="Arcade menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div id="flyout-panel" class="flyout-panel"></div>
  </div>
  <button id="help-button" type="button" aria-label="How to play">?</button>
  <div id="instruction-modal" class="is-visible" role="dialog" aria-modal="true">
    <div id="instruction-card">
      <h2>How to Play</h2>
      <p>Rotate with Left/Right arrows. Move forward/back with Up/Down. Space fires. Press M to drop a mine.</p>
      <p>Eliminate all enemy tanks to advance to the next level.</p>
      <button id="instruction-close" type="button">Start</button>
    </div>
  </div>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Tanks</h1>
    <div id="info"></div>
    <div id="options">
      <label><input type="checkbox" id="bounceToggle"> Bouncing bullets</label>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="message"></div>
    <button id="restartBtn">Restart</button>
    <div id="touch-controls" aria-hidden="true">
      <div class="control-cluster">
        <div class="control-row">
          <button type="button" class="control-button" data-action="left" aria-label="Rotate Left">L</button>
          <button type="button" class="control-button" data-action="right" aria-label="Rotate Right">R</button>
        </div>
        <div class="control-row">
          <button type="button" class="control-button" data-action="up" aria-label="Move Forward">F</button>
          <button type="button" class="control-button" data-action="down" aria-label="Move Backward">B</button>
        </div>
      </div>
      <div class="control-cluster">
        <button type="button" class="control-button" data-action="fire" aria-label="Fire">Fire</button>
        <button type="button" class="control-button" data-action="mine" aria-label="Drop Mine">Mine</button>
      </div>
    </div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;
    const controlButtons = document.querySelectorAll('.control-button');
    if (isTouchDevice) {
      document.body.classList.add('touch-device');
    }

    function shadeColor(color, percent) {
      if (!color || color[0] !== '#') return color;
      let hex = color.slice(1);
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const num = parseInt(hex, 16);
      if (Number.isNaN(num)) return color;
      const amt = Math.round(2.55 * percent);
      const r = Math.min(255, Math.max(0, (num >> 16) + amt));
      const g = Math.min(255, Math.max(0, ((num >> 8) & 0xff) + amt));
      const b = Math.min(255, Math.max(0, (num & 0xff) + amt));
      return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    const keys = {};
    const bullets = [];
    const obstacles = [];
    let mine = null;

    const player = {x:0,y:0,angle:0,color:'#0f0',alive:true,explosion:0};
    let enemies = [];
    let level = 1;
    let lives = 3;
    let running = false;

    function obstacleCollision(x, y) {
      for (const o of obstacles) {
        if (x > o.x - 15 && x < o.x + o.w + 15 && y > o.y - 15 && y < o.y + o.h + 15) return true;
      }
      return false;
    }

    function respawnPlayer() {
      for (let i = 0; i < 100; i++) {
        const x = 30 + Math.random() * (canvas.width - 60);
        const y = 30 + Math.random() * (canvas.height - 60);
        if (!obstacleCollision(x, y) && enemies.every(e => !e.alive || Math.hypot(x - e.x, y - e.y) > 120)) {
          player.x = x; player.y = y; player.angle = 0; player.alive = true; player.explosion = 0;
          return;
        }
      }
      player.x = 100; player.y = canvas.height / 2; player.angle = 0; player.alive = true; player.explosion = 0;
    }

    function createObstacles() {
      obstacles.length = 0;
      for (let i = 0; i < 5; i++) {
        const w = 40 + Math.random() * 60;
        const h = 40 + Math.random() * 60;
        const x = 20 + Math.random() * (canvas.width - w - 40);
        const y = 20 + Math.random() * (canvas.height - h - 40);
        obstacles.push({ x, y, w, h });
      }
    }

    function startLevel() {
      bullets.length = 0;
      mine = null;
      createObstacles();
      enemies = [];
      for (let i = 0; i < level + 1; i++) {
        let x = 30 + Math.random() * (canvas.width - 60);
        let y = 30 + Math.random() * (canvas.height - 60);
        let tries = 0;
        while ((obstacleCollision(x, y) || (Math.hypot(x - player.x, y - player.y) < 120)) && tries < 50) {
          x = 30 + Math.random() * (canvas.width - 60);
          y = 30 + Math.random() * (canvas.height - 60);
          tries++;
        }
        enemies.push({ x, y, angle: Math.PI, shootTimer: 80, color: '#f00', alive: true, explosion: 0 });
      }
      respawnPlayer();
      document.getElementById('message').textContent = '';
      running = true;
      updateInfo();
    }

    function shoot(tank) {
      if (bullets.filter(b => b.owner === tank).length >= 2) return;
      bullets.push({ x: tank.x + Math.cos(tank.angle) * 20,
                    y: tank.y + Math.sin(tank.angle) * 20,
                    angle: tank.angle,
                    owner: tank,
                    bounces: 0 });
    }

    function updateInfo() {
      const remaining = enemies.filter(e => e.alive).length;
      document.getElementById('info').textContent = `Level: ${level} | Lives: ${lives} | Enemies Left: ${remaining}`;
    }

    function placeMine() {
      if (!running || !player.alive || mine || gamePaused) return;
      const offset = 16; // place mine just behind the tank with 1px gap
      mine = {
        x: player.x - Math.cos(player.angle) * offset,
        y: player.y - Math.sin(player.angle) * offset,
        timer: 180,
        explosion: 0
      };
    }

    function update() {
      if (!running) return;
      const bounce = document.getElementById('bounceToggle').checked;

      if (player.alive) {
        let nx = player.x, ny = player.y, na = player.angle;
        if (keys['ArrowLeft']) na -= 0.05;
        if (keys['ArrowRight']) na += 0.05;
        if (keys['ArrowUp']) { nx += Math.cos(na) * 2; ny += Math.sin(na) * 2; }
        if (keys['ArrowDown']) { nx -= Math.cos(na) * 2; ny -= Math.sin(na) * 2; }
        nx = Math.max(15, Math.min(canvas.width - 15, nx));
        ny = Math.max(15, Math.min(canvas.height - 15, ny));
        if (!obstacleCollision(nx, ny)) { player.x = nx; player.y = ny; }
        player.angle = na;
      } else if (player.explosion > 0) {
        player.explosion--;
        if (player.explosion === 0 && running) respawnPlayer();
      }

      for (const e of enemies) {
        if (!e.alive) { if (e.explosion > 0) e.explosion--; continue; }
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const desired = Math.atan2(dy, dx);
        let diff = ((desired - e.angle + Math.PI * 3) % (Math.PI * 2)) - Math.PI;
        if (Math.abs(diff) > 0.02) e.angle += Math.sign(diff) * 0.02;
        let ex = e.x + Math.cos(e.angle) * 1.5;
        let ey = e.y + Math.sin(e.angle) * 1.5;
        ex = Math.max(15, Math.min(canvas.width - 15, ex));
        ey = Math.max(15, Math.min(canvas.height - 15, ey));
        if (!obstacleCollision(ex, ey)) { e.x = ex; e.y = ey; }
        e.shootTimer--;
        if (e.shootTimer <= 0 && player.alive) { shoot(e); e.shootTimer = 80; }
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.x += Math.cos(b.angle) * 4;
        b.y += Math.sin(b.angle) * 4;

        let bounced = false;
        let removed = false;
        if (bounce) {
          if (b.x <= 0 || b.x >= canvas.width) {
            b.angle = Math.PI - b.angle;
            b.x = Math.max(0, Math.min(canvas.width, b.x));
            b.bounces++;
            bounced = true;
          }
          if (b.y <= 0 || b.y >= canvas.height) {
            b.angle = -b.angle;
            b.y = Math.max(0, Math.min(canvas.height, b.y));
            b.bounces++;
            bounced = true;
          }
        } else {
          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) { bullets.splice(i, 1); continue; }
        }

        if (bounce) {
          for (const o of obstacles) {
            if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) {
              const left = Math.abs(b.x - o.x);
              const right = Math.abs(o.x + o.w - b.x);
              const top = Math.abs(b.y - o.y);
              const bottom = Math.abs(o.y + o.h - b.y);
              const min = Math.min(left, right, top, bottom);
              if (min === left || min === right) {
                b.angle = Math.PI - b.angle;
                b.x += min === left ? -2 : 2;
              } else {
                b.angle = -b.angle;
                b.y += min === top ? -2 : 2;
              }
              b.bounces++;
              bounced = true;
              break;
            }
          }
        } else {
          for (const o of obstacles) {
            if (b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) { bullets.splice(i, 1); removed = true; break; }
          }
          if (removed) continue;
        }

        if (bounced && b.bounces >= 3) { bullets.splice(i, 1); continue; }
        if (player.alive && b.owner !== player && Math.hypot(b.x - player.x, b.y - player.y) < 15) {
          player.alive = false; player.explosion = 30; lives--; updateInfo();
          if (lives <= 0) {
            running = false;
            document.getElementById('message').textContent = 'Game Over';
          }
          if (!bounce) { bullets.splice(i, 1); } else { b.angle = Math.atan2(b.y - player.y, b.x - player.x); }
          continue;
        }
        for (const e of enemies) {
          if (e.alive && b.owner !== e && Math.hypot(b.x - e.x, b.y - e.y) < 15) {
            e.alive = false; e.explosion = 30;
            if (!bounce) { bullets.splice(i, 1); }
            else { b.angle = Math.atan2(b.y - e.y, b.x - e.x); }
            removed = true; break;
          }
        }
        if (removed && !bounce) continue;
      }

      if (mine) {
        if (mine.explosion > 0) {
          mine.explosion--;
          if (mine.explosion === 0) mine = null;
        } else {
          mine.timer--;
          let triggered = false;
          const inRange = t => Math.hypot(t.x - mine.x, t.y - mine.y) < 15;
          if (player.alive && inRange(player)) {
            player.alive = false; player.explosion = 30; lives--; updateInfo();
            triggered = true;
          }
          for (const e of enemies) {
            if (e.alive && inRange(e)) { e.alive = false; e.explosion = 30; triggered = true; }
          }
          if (mine.timer <= 0) triggered = true;
          if (triggered) mine.explosion = 30;
        }
      }

      updateInfo();

      if (enemies.every(e => !e.alive && e.explosion === 0)) {
        running = false;
        document.getElementById('message').textContent = 'Next Level';
        setTimeout(() => {
          level++;
          if (level === 4) { lives++; }
          startLevel();
        }, 1000);
      }
    }

    function drawTank(t) {
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.rotate(t.angle);

      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(4, 12, 22, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      const baseColor = t.color;

      const trackGradient = ctx.createLinearGradient(-20, 0, 20, 0);
      trackGradient.addColorStop(0, '#101010');
      trackGradient.addColorStop(0.5, '#252525');
      trackGradient.addColorStop(1, '#101010');
      ctx.fillStyle = trackGradient;
      ctx.fillRect(-22, -13, 44, 6);
      ctx.fillRect(-22, 7, 44, 6);

      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      for (let i = -16; i <= 16; i += 8) {
        ctx.beginPath();
        ctx.arc(i, -10, 1.5, 0, Math.PI * 2);
        ctx.arc(i, 10, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }

      const bodyGradient = ctx.createLinearGradient(-18, -10, 18, 10);
      bodyGradient.addColorStop(0, shadeColor(baseColor, -25));
      bodyGradient.addColorStop(0.5, shadeColor(baseColor, 12));
      bodyGradient.addColorStop(1, shadeColor(baseColor, -15));
      ctx.fillStyle = bodyGradient;
      ctx.beginPath();
      ctx.moveTo(-18, -7);
      ctx.lineTo(18, -7);
      ctx.quadraticCurveTo(21, -7, 21, -4);
      ctx.lineTo(21, 4);
      ctx.quadraticCurveTo(21, 7, 18, 7);
      ctx.lineTo(-18, 7);
      ctx.quadraticCurveTo(-21, 7, -21, 4);
      ctx.lineTo(-21, -4);
      ctx.quadraticCurveTo(-21, -7, -18, -7);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = shadeColor(baseColor, 25);
      ctx.beginPath();
      ctx.moveTo(-12, -5);
      ctx.lineTo(12, -5);
      ctx.quadraticCurveTo(14, -5, 14, -3);
      ctx.lineTo(14, 3);
      ctx.quadraticCurveTo(14, 5, 12, 5);
      ctx.lineTo(-12, 5);
      ctx.quadraticCurveTo(-14, 5, -14, 3);
      ctx.lineTo(-14, -3);
      ctx.quadraticCurveTo(-14, -5, -12, -5);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.beginPath();
      ctx.arc(0, 0, 9, 0, Math.PI * 2);
      ctx.fill();

      const turretGradient = ctx.createLinearGradient(-8, -8, 8, 8);
      turretGradient.addColorStop(0, shadeColor(baseColor, 25));
      turretGradient.addColorStop(1, shadeColor(baseColor, -20));
      ctx.fillStyle = turretGradient;
      ctx.beginPath();
      ctx.arc(0, 0, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = shadeColor(baseColor, -35);
      ctx.beginPath();
      ctx.arc(0, 0, 3, 0, Math.PI * 2);
      ctx.fill();

      const barrelGradient = ctx.createLinearGradient(4, 0, 28, 0);
      barrelGradient.addColorStop(0, shadeColor(baseColor, 30));
      barrelGradient.addColorStop(1, shadeColor(baseColor, -30));
      ctx.fillStyle = barrelGradient;
      ctx.beginPath();
      ctx.moveTo(4, -3);
      ctx.lineTo(26, -3);
      ctx.quadraticCurveTo(28, -3, 28, -1.5);
      ctx.lineTo(28, 1.5);
      ctx.quadraticCurveTo(28, 3, 26, 3);
      ctx.lineTo(4, 3);
      ctx.quadraticCurveTo(2.5, 3, 2, 1.5);
      ctx.lineTo(2, -1.5);
      ctx.quadraticCurveTo(2, -3, 4, -3);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = '#dcdcdc';
      ctx.beginPath();
      ctx.moveTo(26, -2);
      ctx.lineTo(30, -2);
      ctx.lineTo(30, 2);
      ctx.lineTo(26, 2);
      ctx.quadraticCurveTo(25, 2, 25, 0);
      ctx.quadraticCurveTo(25, -2, 26, -2);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawExplosion(t) {
      const r = 30 - t.explosion;
      ctx.fillStyle = 'orange';
      ctx.beginPath();
      ctx.arc(t.x, t.y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#666';
      for (const o of obstacles) ctx.fillRect(o.x, o.y, o.w, o.h);
      if (player.alive) drawTank(player); else if (player.explosion > 0) drawExplosion(player);
      for (const e of enemies) {
        if (e.alive) drawTank(e); else if (e.explosion > 0) drawExplosion(e);
      }
      if (mine) {
        if (mine.explosion > 0) {
          drawExplosion(mine);
        } else {
          ctx.fillStyle = '#ff0';
          ctx.beginPath();
          ctx.arc(mine.x, mine.y, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.fillStyle = '#fff';
      for (const b of bullets) {
        ctx.beginPath();
        ctx.arc(b.x, b.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    const FRAME_TIME = 1000/60;
    let lastFrame = 0;
    let gamePaused = true;
    let gameStarted = false;
    function loop(time = 0) {
      if (gamePaused) {
        requestAnimationFrame(loop);
        return;
      }
      if (time - lastFrame >= FRAME_TIME) {
        update();
        draw();
        lastFrame = time;
      }
      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => {
      if (gamePaused) return;
      keys[e.key] = true;
      if (e.key === ' ' && running && player.alive) { shoot(player); }
      if ((e.key === 'm' || e.key === 'M')) {
        placeMine();
      }
    });
    window.addEventListener('keyup', e => { keys[e.key] = false; });

    function resizeCanvas() {
      const padding = 24;
      const maxWidth = Math.max(320, window.innerWidth - padding * 2);
      const maxHeight = Math.max(320, window.innerHeight - padding * 2);
      const oldWidth = canvas.width;
      const oldHeight = canvas.height;
      const nextWidth = Math.floor(maxWidth);
      const nextHeight = Math.floor(maxHeight);
      if (nextWidth === oldWidth && nextHeight === oldHeight) return;
      canvas.width = nextWidth;
      canvas.height = nextHeight;
      if (oldWidth && oldHeight) {
        const scaleX = canvas.width / oldWidth;
        const scaleY = canvas.height / oldHeight;
        player.x *= scaleX;
        player.y *= scaleY;
        enemies.forEach(e => {
          e.x *= scaleX;
          e.y *= scaleY;
        });
        bullets.forEach(b => {
          b.x *= scaleX;
          b.y *= scaleY;
        });
        obstacles.forEach(o => {
          o.x *= scaleX;
          o.y *= scaleY;
          o.w *= scaleX;
          o.h *= scaleY;
        });
        if (mine) {
          mine.x *= scaleX;
          mine.y *= scaleY;
        }
      }
    }

    const instructionModal = document.getElementById('instruction-modal');
    const instructionClose = document.getElementById('instruction-close');
    const helpButton = document.getElementById('help-button');
    const instructionKey = 'vibecade-instructions-tanks';
    const hasSeenInstructions = sessionStorage.getItem(instructionKey) === '1';

    function startGame() {
      if (gameStarted) return;
      gameStarted = true;
      gamePaused = false;
      resizeCanvas();
      startLevel();
      lastFrame = performance.now();
      requestAnimationFrame(loop);
    }

    function showInstructions() {
      gamePaused = true;
      if (instructionModal) instructionModal.classList.add('is-visible');
    }

    function hideInstructions() {
      if (instructionModal) instructionModal.classList.remove('is-visible');
      if (!gameStarted) {
        startGame();
      } else {
        gamePaused = false;
      }
      sessionStorage.setItem(instructionKey, '1');
    }

    if (instructionClose) {
      instructionClose.addEventListener('click', hideInstructions);
    }
    if (instructionModal) {
      instructionModal.addEventListener('click', (event) => {
        if (event.target === instructionModal) {
          hideInstructions();
        }
      });
    }
    if (helpButton) {
      helpButton.addEventListener('click', showInstructions);
    }

    if (controlButtons.length && isTouchDevice) {
      controlButtons.forEach((button) => {
        const action = button.dataset.action;
        const press = () => {
          button.classList.add('pressed');
          if (action === 'left') keys['ArrowLeft'] = true;
          if (action === 'right') keys['ArrowRight'] = true;
          if (action === 'up') keys['ArrowUp'] = true;
          if (action === 'down') keys['ArrowDown'] = true;
          if (action === 'fire') shoot(player);
          if (action === 'mine') placeMine();
        };
        const release = () => {
          button.classList.remove('pressed');
          if (action === 'left') keys['ArrowLeft'] = false;
          if (action === 'right') keys['ArrowRight'] = false;
          if (action === 'up') keys['ArrowUp'] = false;
          if (action === 'down') keys['ArrowDown'] = false;
        };
        button.addEventListener('touchstart', (event) => {
          event.preventDefault();
          press();
        }, { passive: false });
        button.addEventListener('touchend', (event) => {
          event.preventDefault();
          release();
        }, { passive: false });
        button.addEventListener('touchcancel', release);
        button.addEventListener('mousedown', press);
        button.addEventListener('mouseup', release);
        button.addEventListener('mouseleave', release);
      });
    }

    window.addEventListener('resize', () => {
      window.requestAnimationFrame(resizeCanvas);
    });

    window.addEventListener('load', () => {
      document.getElementById('restartBtn').addEventListener('click', () => {
        level = 1;
        lives = 3;
        startLevel();
      });
    });

    if (hasSeenInstructions) {
      if (instructionModal) instructionModal.classList.remove('is-visible');
      startGame();
    }
  </script>
</body>
</html>


