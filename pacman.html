<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pac-Man Deluxe</title>
  <style>
    :root {
      --wall-primary: #1423ff;
      --wall-highlight: #6fa4ff;
      --bg-top: #03041a;
      --bg-bottom: #01010a;
      --panel-bg: rgba(0, 0, 0, 0.55);
      --text-glow: #ffe066;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: radial-gradient(circle at center, rgba(18,22,63,0.6), #02020e 65%);
      color: #fff;
      font-family: "Orbitron", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      letter-spacing: 0.04em;
    }
    #sidebar { width: 220px; }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 32px;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: clamp(2.6rem, 4vw, 3.6rem);
      text-shadow: 0 0 10px rgba(255, 240, 0, 0.7);
    }
    canvas {
      border-radius: 18px;
      background: linear-gradient(var(--bg-top), var(--bg-bottom));
      box-shadow: 0 28px 60px rgba(0, 0, 0, 0.45), inset 0 0 18px rgba(0, 0, 0, 0.9);
    }
    #info-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: center;
      padding: 16px 22px;
      background: var(--panel-bg);
      border-radius: 14px;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
    }
    #info-panel span { min-width: 140px; text-align: center; }
    #message {
      min-height: 26px;
      font-size: 1.2rem;
      color: var(--text-glow);
      text-shadow: 0 0 8px rgba(255, 224, 102, 0.75);
    }
    #legend {
      width: min(780px, 90vw);
      background: var(--panel-bg);
      border-radius: 14px;
      padding: 18px 22px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      font-size: 0.9rem;
    }
    #legend strong { color: #ffd166; }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Pac-Man Deluxe</h1>
    <canvas id="gameCanvas" width="640" height="544"></canvas>
    <div id="info-panel">
      <span id="score">Score: 0</span>
      <span id="lives">Lives: 3</span>
      <span id="level">Level: 1</span>
    </div>
    <div id="message"></div>
    <div id="legend">
      <div><strong>Blinky</strong> – Relentless pursuit, locking onto your current tile with surgical precision.</div>
      <div><strong>Pinky</strong> – Plots ambushes by aiming four tiles ahead of your movement.</div>
      <div><strong>Inky</strong> – Calculates a flanking vector using Blinky and your trajectory.</div>
      <div><strong>Clyde</strong> – Shy: chases from afar but flees to his corner when he gets too close.</div>
    </div>
  </div>
  <script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const TILE = 32;
const FPS = 60;
const FRAME_TIME = 1000 / FPS;

const baseMap = [
  '####################',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o##.###.##.###.##o#',
  '#..................#',
  '#.##.#.######.#.##.#',
  '#....#....##....#..#',
  '####.### #### ###.##',
  '####.#      # #.####',
  '####.# ###--# #.####',
  '     . #GGGG# .     ',
  '####.# #----# #.####',
  '####.# ###### #.####',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o.. ....P..... ..o#',
  '####################'
];

let map = [];
let pellets = 0;
let score = 0;
let lives = 3;
let level = 1;
let frightTimer = 0;
let frightChain = 0;
let globalModeIndex = 0;
let globalModeTimer = 0;
let message = '';
let startDelay = 90; // frames

const DIRECTIONS = [
  { x: 1, y: 0, name: 'right' },
  { x: -1, y: 0, name: 'left' },
  { x: 0, y: -1, name: 'up' },
  { x: 0, y: 1, name: 'down' }
];

const MODE_SEQUENCE = [
  { mode: 'scatter', duration: 7 * FPS },
  { mode: 'chase', duration: 20 * FPS },
  { mode: 'scatter', duration: 7 * FPS },
  { mode: 'chase', duration: 20 * FPS },
  { mode: 'scatter', duration: 5 * FPS },
  { mode: 'chase', duration: Infinity }
];

const TURN_THRESHOLD = 0.2;
const SNAP_THRESHOLD = 0.24;
const TURN_BUFFER = 0.28;

const pacman = {
  x: 9,
  y: 15,
  dir: { x: 0, y: 0 },
  nextDir: { x: 0, y: 0 },
  speed: 0.128
};

const GHOST_TEMPLATES = [
  {
    name: 'Blinky',
    color: '#ff2b2b',
    scatter: { x: 18, y: 1 },
    x: 9,
    y: 8,
    dir: { x: 1, y: 0 },
    speed: 0.12,
    state: 'chase'
  },
  {
    name: 'Pinky',
    color: '#ff8ed1',
    scatter: { x: 1, y: 1 },
    x: 9,
    y: 10,
    dir: { x: -1, y: 0 },
    speed: 0.116,
    state: 'in-house',
    releaseDelay: 120
  },
  {
    name: 'Inky',
    color: '#4de0ff',
    scatter: { x: 18, y: 15 },
    x: 10,
    y: 10,
    dir: { x: 1, y: 0 },
    speed: 0.116,
    state: 'in-house',
    releaseDelay: 240
  },
  {
    name: 'Clyde',
    color: '#ffb347',
    scatter: { x: 1, y: 15 },
    x: 8,
    y: 10,
    dir: { x: -1, y: 0 },
    speed: 0.112,
    state: 'in-house',
    releaseDelay: 360
  }
];


const ghosts = GHOST_TEMPLATES.map(t => ({
  name: t.name,
  color: t.color,
  scatter: { ...t.scatter },
  x: t.x,
  y: t.y,
  dir: { ...t.dir },
  speed: t.speed,
  state: t.state,
  releaseDelay: t.releaseDelay
}));

function cloneMap() {
  map = baseMap.map(row => row.split('').map(ch => (ch === 'P' ? ' ' : ch)));
}

function countPellets() {
  pellets = 0;
  map.forEach(row => row.forEach(ch => { if (ch === '.' || ch === 'o') pellets++; }));
}

function tileAt(x, y) {
  const tx = Math.floor(x);
  const ty = Math.floor(y);
  if (ty < 0 || ty >= map.length || tx < 0 || tx >= map[0].length) return '#';
  return map[ty][tx];
}

function isWallTile(ch) {
  return ch === '#';
}

function isWall(x, y) {
  return isWallTile(tileAt(x, y));
}

function isIntersection(entity) {
  return Math.abs(entity.x - Math.round(entity.x)) < TURN_THRESHOLD &&
         Math.abs(entity.y - Math.round(entity.y)) < TURN_THRESHOLD;
}

function snapToGrid(entity) {
  if (Math.abs(entity.x - Math.round(entity.x)) < SNAP_THRESHOLD) entity.x = Math.round(entity.x);
  if (Math.abs(entity.y - Math.round(entity.y)) < SNAP_THRESHOLD) entity.y = Math.round(entity.y);
}

function move(entity, dir) {
  const speed = entity.speed;
  const nx = entity.x + dir.x * speed;
  const ny = entity.y + dir.y * speed;
  const futureTile = tileAt(nx, ny);
  if (isWallTile(futureTile)) {
    return false;
  }
  entity.x = nx;
  entity.y = ny;
  return true;
}

function updatePacman() {
  const wantsTurn = pacman.nextDir;
  const reversing = pacman.dir.x === -wantsTurn.x && pacman.dir.y === -wantsTurn.y;

  if (reversing) {
    pacman.dir = { ...wantsTurn };
  }

  const turning = wantsTurn.x !== pacman.dir.x || wantsTurn.y !== pacman.dir.y;
  if (turning) {
    const axis = wantsTurn.x !== 0 ? 'y' : 'x';
    const distanceToCenter = Math.abs(pacman[axis] - Math.round(pacman[axis]));
    if (reversing || distanceToCenter <= TURN_BUFFER) {
      const alignedX = wantsTurn.y !== 0 ? Math.round(pacman.x) : pacman.x;
      const alignedY = wantsTurn.x !== 0 ? Math.round(pacman.y) : pacman.y;
      if (!isWall(alignedX + wantsTurn.x * 0.6, alignedY + wantsTurn.y * 0.6)) {
        if (wantsTurn.y !== 0) pacman.x = alignedX;
        if (wantsTurn.x !== 0) pacman.y = alignedY;
        pacman.dir = { ...wantsTurn };
      }
    }
  }

  if (!move(pacman, pacman.dir)) {
    pacman.dir = { x: 0, y: 0 };
    snapToGrid(pacman);
  }

  snapToGrid(pacman);

  const tx = Math.floor(pacman.x);
  const ty = Math.floor(pacman.y);
  const ch = tileAt(tx, ty);
  if (ch === '.' || ch === 'o') {
    map[ty][tx] = ' ';
    pellets--;
    score += (ch === 'o') ? 50 : 10;
    if (ch === 'o') {
      frightTimer = 7 * FPS;
      frightChain++;
      ghosts.forEach(g => {
        if (g.state !== 'eaten') {
          g.state = 'frightened';
          g.speed = 0.08;
          g.dir = { x: -g.dir.x, y: -g.dir.y };
        }
      });
    }
  }
}

function getTemplate(name) {
  return GHOST_TEMPLATES.find(t => t.name === name);
}

function resetGhost(g) {
  const template = getTemplate(g.name);
  g.x = template.x;
  g.y = template.y;
  g.dir = { ...template.dir };
  g.speed = template.speed;
  g.state = template.state;
  g.scatter = { ...template.scatter };
  g.releaseDelay = template.releaseDelay;
}

function resetPositions() {
  pacman.x = 9;
  pacman.y = 15;
  pacman.dir = { x: 0, y: 0 };
  pacman.nextDir = { x: 0, y: 0 };
  pacman.speed = 0.128;
  ghosts.forEach(resetGhost);
  frightTimer = 0;
  frightChain = 0;
  globalModeIndex = 0;
  globalModeTimer = MODE_SEQUENCE[0].duration;
  startDelay = 90;
}

function startLevel() {
  cloneMap();
  countPellets();
  resetPositions();
}

function resetGame() {
  score = 0;
  lives = 3;
  level = 1;
  message = '';
  startLevel();
}

function availableDirections(entity, allowReverse = false) {
  const currentDir = entity.dir;
  const options = [];
  for (const dir of DIRECTIONS) {
    if (!allowReverse && dir.x === -currentDir.x && dir.y === -currentDir.y) continue;
    const nx = entity.x + dir.x * 0.6;
    const ny = entity.y + dir.y * 0.6;
    if (!isWall(nx, ny)) {
      options.push(dir);
    }
  }
  if (options.length === 0 && !allowReverse) {
    return availableDirections(entity, true);
  }
  return options;
}

function bfsDistance(start, goal) {
  const sx = Math.floor(start.x);
  const sy = Math.floor(start.y);
  const gx = Math.floor(goal.x);
  const gy = Math.floor(goal.y);
  if (sx === gx && sy === gy) return 0;
  const queue = [[sx, sy, 0]];
  const visited = new Set([`${sx},${sy}`]);
  while (queue.length) {
    const [x, y, d] = queue.shift();
    for (const dir of DIRECTIONS) {
      const nx = x + dir.x;
      const ny = y + dir.y;
      const key = `${nx},${ny}`;
      if (visited.has(key)) continue;
      if (isWall(nx + 0.1, ny + 0.1)) continue;
      if (nx === gx && ny === gy) return d + 1;
      visited.add(key);
      queue.push([nx, ny, d + 1]);
    }
  }
  return Infinity;
}

function clampTarget(target) {
  target.x = Math.max(0, Math.min(map[0].length - 1, target.x));
  target.y = Math.max(0, Math.min(map.length - 1, target.y));
  return target;
}

function ghostTarget(g) {
  if (g.state === 'eaten') {
    return { x: 9, y: 8 };
  }
  if (g.state === 'frightened') {
    return { x: Math.random() * map[0].length, y: Math.random() * map.length };
  }

  const mode = MODE_SEQUENCE[globalModeIndex].mode;
  if (mode === 'scatter') {
    return { ...g.scatter };
  }

  if (g.name === 'Blinky') {
    return clampTarget({ x: pacman.x, y: pacman.y });
  }
  if (g.name === 'Pinky') {
    const ahead = {
      x: pacman.x + pacman.dir.x * 4,
      y: pacman.y + pacman.dir.y * 4
    };
    return clampTarget(ahead);
  }
  if (g.name === 'Inky') {
    const blinky = ghosts.find(ghost => ghost.name === 'Blinky');
    const pivot = {
      x: pacman.x + pacman.dir.x * 2,
      y: pacman.y + pacman.dir.y * 2
    };
    const vector = {
      x: (pivot.x - blinky.x) * 2 + blinky.x,
      y: (pivot.y - blinky.y) * 2 + blinky.y
    };
    return clampTarget(vector);
  }
  if (g.name === 'Clyde') {
    const dx = g.x - pacman.x;
    const dy = g.y - pacman.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist <= 4) {
      return clampTarget({ ...g.scatter });
    }
    return clampTarget({ x: pacman.x, y: pacman.y });
  }
  return clampTarget({ x: pacman.x, y: pacman.y });
}

function updateGhostState(g) {
  if (startDelay > 0) {
    g.state = 'in-house';
    return;
  }
  if (g.state === 'in-house') {
    if (g.releaseDelay && g.releaseDelay > 0) {
      g.releaseDelay--;
      return;
    }
    if (Math.abs(g.x - 9.5) > 0.05) {
      const delta = g.x < 9.5 ? 0.12 : -0.12;
      g.x += delta;
      g.dir = { x: Math.sign(delta), y: 0 };
      return;
    }
    if (g.y > 8) {
      g.y -= 0.12;
      g.dir = { x: 0, y: -1 };
      return;
    }
    g.state = MODE_SEQUENCE[globalModeIndex].mode;
    g.dir = { x: 0, y: -1 };
    g.speed = getTemplate(g.name).speed;
  }
  if (g.state !== 'frightened' && g.state !== 'eaten') {
    g.state = MODE_SEQUENCE[globalModeIndex].mode;
    g.speed = getTemplate(g.name).speed;
  }
  if (g.state === 'eaten') {
    g.speed = 0.22;
    if (Math.abs(g.x - 9) < 0.2 && Math.abs(g.y - 9) < 0.2) {
      g.state = 'in-house';
      g.releaseDelay = 60;
      g.x = 9;
      g.y = 9;
      g.dir = { x: 0, y: 0 };
    }
  }
}

function updateGhost(g) {
  updateGhostState(g);

  if (!isIntersection(g) && g.state !== 'in-house') {
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  if (g.state === 'in-house') {
    const bounceDirs = [{ x: 1, y: 0 }, { x: -1, y: 0 }];
    if (g.x <= 8.5) g.dir = bounceDirs[0];
    if (g.x >= 10.5) g.dir = bounceDirs[1];
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  const options = availableDirections(g);
  if (options.length === 0) {
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  if (g.state === 'frightened') {
    g.dir = options[Math.floor(Math.random() * options.length)];
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  const target = ghostTarget(g);
  let bestDir = options[0];
  let bestDist = Infinity;
  for (const dir of options) {
    const nextPos = { x: g.x + dir.x, y: g.y + dir.y };
    const dist = bfsDistance(nextPos, target);
    if (dist < bestDist || (dist === bestDist && dir.name === 'up')) {
      bestDist = dist;
      bestDir = dir;
    }
  }
  g.dir = bestDir;
  move(g, g.dir);
  snapToGrid(g);
}

function updateModes() {
  if (frightTimer > 0) {
    frightTimer--;
    if (frightTimer === 0) {
      ghosts.forEach(g => {
        if (g.state === 'frightened') {
          g.state = MODE_SEQUENCE[globalModeIndex].mode;
          g.speed = getTemplate(g.name).speed;
        }
      });
      frightChain = 0;
    }
    return;
  }
  if (MODE_SEQUENCE[globalModeIndex].duration === Infinity) return;
  globalModeTimer--;
  if (globalModeTimer <= 0) {
    globalModeIndex = Math.min(globalModeIndex + 1, MODE_SEQUENCE.length - 1);
    globalModeTimer = MODE_SEQUENCE[globalModeIndex].duration;
  }
}

function checkCollisions() {
  for (const g of ghosts) {
    if (Math.floor(g.x) === Math.floor(pacman.x) && Math.floor(g.y) === Math.floor(pacman.y)) {
      if (g.state === 'frightened') {
        score += 200 * Math.pow(2, frightChain - 1);
        g.state = 'eaten';
        g.dir = { x: 0, y: -1 };
      } else if (g.state !== 'eaten') {
        lives--;
        message = 'Ouch! Blinky is pleased...';
        if (lives <= 0) {
          message = 'Game Over – press Space to restart';
          pacman.dir = { x: 0, y: 0 };
          return;
        }
        resetPositions();
        return;
      }
    }
  }
  if (pellets === 0) {
    level++;
    score += 500;
    message = `Level ${level} – the ghosts grow wiser.`;
    startLevel();
  }
}

function drawBackground() {
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, 'rgba(5, 7, 33, 0.9)');
  gradient.addColorStop(1, 'rgba(1, 1, 12, 0.95)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawRoundedRectPath(x, y, w, h, r) {
  ctx.beginPath();
  if (typeof ctx.roundRect === 'function') {
    ctx.roundRect(x, y, w, h, r);
  } else {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }
}

function drawMap() {
  drawBackground();
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      const tile = map[y][x];
      const px = x * TILE;
      const py = y * TILE;
      if (tile === '#') {
        const grad = ctx.createLinearGradient(px, py, px, py + TILE);
        grad.addColorStop(0, '#0a0b3d');
        grad.addColorStop(0.4, '#1423ff');
        grad.addColorStop(1, '#040527');
        ctx.fillStyle = grad;
        drawRoundedRectPath(px + 3, py + 3, TILE - 6, TILE - 6, 10);
        ctx.fill();
        ctx.strokeStyle = 'rgba(111, 164, 255, 0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(px, py, TILE, TILE);
      }
      if (tile === '.') {
        ctx.fillStyle = '#fffcf2';
        ctx.beginPath();
        ctx.arc(px + TILE / 2, py + TILE / 2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      if (tile === 'o') {
        const pulse = 6 + Math.sin(Date.now() / 120) * 2;
        const grad = ctx.createRadialGradient(px + TILE / 2, py + TILE / 2, 0, px + TILE / 2, py + TILE / 2, pulse + 4);
        grad.addColorStop(0, '#ffe066');
        grad.addColorStop(1, 'rgba(255, 224, 102, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(px + TILE / 2, py + TILE / 2, pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function drawPacman() {
  const centerX = pacman.x * TILE + TILE / 2;
  const centerY = pacman.y * TILE + TILE / 2;
  let angleOffset = 0;
  if (pacman.dir.x === 1) angleOffset = 0;
  else if (pacman.dir.x === -1) angleOffset = Math.PI;
  else if (pacman.dir.y === -1) angleOffset = -Math.PI / 2;
  else if (pacman.dir.y === 1) angleOffset = Math.PI / 2;
  const mouth = (Math.sin(Date.now() / 90) * 0.25 + 0.35) * Math.PI;
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(angleOffset);
  ctx.fillStyle = '#ffe066';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.arc(0, 0, TILE / 2 - 2, mouth / 2, Math.PI * 2 - mouth / 2, false);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawGhost(g) {
  const x = g.x * TILE + TILE / 2;
  const y = g.y * TILE + TILE / 2;
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = (g.state === 'frightened') ? '#3a57ff' : g.color;
  ctx.beginPath();
  const bodyWidth = TILE - 6;
  const bodyHeight = TILE - 4;
  ctx.moveTo(-bodyWidth / 2, bodyHeight / 2);
  ctx.lineTo(-bodyWidth / 2, 0);
  ctx.quadraticCurveTo(-bodyWidth / 2, -bodyHeight / 2, 0, -bodyHeight / 2);
  ctx.quadraticCurveTo(bodyWidth / 2, -bodyHeight / 2, bodyWidth / 2, 0);
  ctx.lineTo(bodyWidth / 2, bodyHeight / 2);
  const waveCount = 4;
  for (let i = 0; i <= waveCount; i++) {
    const dx = bodyWidth / 2 - (i * bodyWidth) / waveCount;
    const direction = i % 2 === 0 ? 1 : -1;
    ctx.quadraticCurveTo(dx - bodyWidth / waveCount / 2, bodyHeight / 2 + 4 * direction, dx - bodyWidth / waveCount, bodyHeight / 2);
  }
  ctx.closePath();
  ctx.fill();

  const eyeColor = (g.state === 'frightened') ? '#fff' : '#fff';
  const pupilColor = (g.state === 'frightened') ? '#222' : '#1a1a1a';
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.ellipse(-6, -4, 5, 7, 0, 0, Math.PI * 2);
  ctx.ellipse(6, -4, 5, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = pupilColor;
  const pupilOffset = { x: g.dir.x * 3, y: g.dir.y * 3 };
  ctx.beginPath();
  ctx.arc(-6 + pupilOffset.x, -4 + pupilOffset.y, 2.5, 0, Math.PI * 2);
  ctx.arc(6 + pupilOffset.x, -4 + pupilOffset.y, 2.5, 0, Math.PI * 2);
  ctx.fill();

  if (g.state === 'frightened') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-6, 5);
    ctx.lineTo(-2, 7);
    ctx.lineTo(2, 5);
    ctx.lineTo(6, 7);
    ctx.stroke();
  }
  ctx.restore();
}

function draw() {
  drawMap();
  drawPacman();
  ghosts.forEach(drawGhost);

  document.getElementById('score').textContent = `Score: ${score}`;
  document.getElementById('lives').textContent = `Lives: ${lives}`;
  document.getElementById('level').textContent = `Level: ${level}`;
  document.getElementById('message').textContent = message;
}

function gameLoop() {
  if (lives <= 0) {
    draw();
    return;
  }
  if (startDelay > 0) {
    startDelay--;
  }
  updatePacman();
  ghosts.forEach(updateGhost);
  updateModes();
  checkCollisions();
  draw();
}

function handleKeyDown(e) {
  const key = e.key;
  if (key.startsWith('Arrow')) {
    e.preventDefault();
  }
  if (key === 'ArrowLeft' || key === 'a' || key === 'A') pacman.nextDir = { x: -1, y: 0 };
  if (key === 'ArrowRight' || key === 'd' || key === 'D') pacman.nextDir = { x: 1, y: 0 };
  if (key === 'ArrowUp' || key === 'w' || key === 'W') pacman.nextDir = { x: 0, y: -1 };
  if (key === 'ArrowDown' || key === 's' || key === 'S') pacman.nextDir = { x: 0, y: 1 };
  if (key === ' ' && lives <= 0) {
    resetGame();
  }
}

document.addEventListener('keydown', handleKeyDown);

resetGame();
setInterval(gameLoop, FRAME_TIME);
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
