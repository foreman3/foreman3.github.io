<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pac-Man Deluxe</title>
  <style>
    :root {
      --wall-primary: #1423ff;
      --wall-highlight: #6fa4ff;
      --bg-top: #03041a;
      --bg-bottom: #01010a;
      --panel-bg: rgba(0, 0, 0, 0.55);
      --text-glow: #ffe066;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: radial-gradient(circle at center, rgba(18,22,63,0.6), #02020e 65%);
      color: #fff;
      font-family: "Orbitron", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      letter-spacing: 0.04em;
    }
    #sidebar { width: 220px; }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 32px;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: clamp(2.6rem, 4vw, 3.6rem);
      text-shadow: 0 0 10px rgba(255, 240, 0, 0.7);
    }
    canvas {
      border-radius: 18px;
      background: linear-gradient(var(--bg-top), var(--bg-bottom));
      box-shadow: 0 28px 60px rgba(0, 0, 0, 0.45), inset 0 0 18px rgba(0, 0, 0, 0.9);
    }
    #info-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      justify-content: center;
      padding: 16px 22px;
      background: var(--panel-bg);
      border-radius: 14px;
      backdrop-filter: blur(6px);
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
    }
    #info-panel span { min-width: 140px; text-align: center; }
    #message {
      min-height: 26px;
      font-size: 1.2rem;
      color: var(--text-glow);
      text-shadow: 0 0 8px rgba(255, 224, 102, 0.75);
    }
    #legend {
      width: min(780px, 90vw);
      background: var(--panel-bg);
      border-radius: 14px;
      padding: 18px 22px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.45);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      font-size: 0.9rem;
    }
    #legend strong { color: #ffd166; }
    html,
    body {
      height: 100%;
    }
    body {
      justify-content: center;
      overflow: hidden;
    }
    #sidebar-placeholder {
      display: none;
    }
    #game-container {
      position: relative;
      width: min(1200px, 100%);
      max-width: calc(100vw - 32px);
      height: 100vh;
      padding: 24px;
      gap: 0;
    }
    h1 {
      display: none;
    }
    canvas {
      width: 100%;
      height: 100%;
      max-height: calc(100vh - 32px);
    }
    #info-panel {
      position: absolute;
      top: 16px;
      left: 16px;
      margin: 0;
      padding: 10px 14px;
      z-index: 3;
    }
    #message {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 1rem;
      background: rgba(0, 0, 0, 0.45);
      padding: 10px 18px;
      border-radius: 999px;
      min-height: 28px;
      z-index: 3;
    }
    #legend {
      display: none;
    }
    #touch-controls {
      position: absolute;
      inset: 0;
      display: none;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 22px 20px;
      pointer-events: none;
      z-index: 3;
    }
    .control-cluster {
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }
    .control-row {
      display: flex;
      gap: 12px;
      pointer-events: none;
    }
    .control-button {
      width: clamp(58px, 16vw, 86px);
      height: clamp(58px, 16vw, 86px);
      border-radius: 999px;
      border: 2px solid rgba(255, 224, 102, 0.5);
      background: rgba(10, 10, 10, 0.55);
      color: rgba(255, 255, 255, 0.9);
      font-size: clamp(1.2rem, 4.5vw, 1.8rem);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      touch-action: none;
      backdrop-filter: blur(6px);
      transition: background 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .control-button.pressed,
    .control-button:active {
      background: rgba(255, 224, 102, 0.25);
      border-color: rgba(255, 240, 160, 0.9);
      box-shadow: 0 0 24px rgba(255, 224, 102, 0.35);
    }
    body.touch-device #touch-controls {
      display: flex;
    }
    #help-button {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid rgba(255, 224, 102, 0.55);
      background: rgba(10, 10, 10, 0.45);
      color: rgba(255, 255, 255, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      z-index: 1001;
      backdrop-filter: blur(6px);
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    #help-button:hover,
    #help-button:focus-visible {
      border-color: rgba(255, 240, 160, 0.9);
      background: rgba(255, 224, 102, 0.25);
    }
    #instruction-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.78);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
      padding: 24px;
      text-align: left;
    }
    #instruction-modal.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    #instruction-card {
      max-width: 520px;
      width: 100%;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 224, 102, 0.35);
      border-radius: 18px;
      padding: 20px 22px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
      color: #fff;
    }
    #instruction-card h2 {
      margin: 0 0 12px;
      font-size: 1rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: var(--text-glow);
    }
    #instruction-card p {
      margin: 8px 0;
      color: #f2f6ff;
      line-height: 1.5;
    }
    #instruction-close {
      margin-top: 14px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: none;
      background: rgba(255, 224, 102, 0.9);
      color: #111;
      font-weight: 700;
      letter-spacing: 1px;
      cursor: pointer;
    }
    @media (pointer: fine) {
      #help-button {
        display: flex;
      }
    }
  </style>
  <link rel="stylesheet" href="../sidebar.css" />
  <link rel="stylesheet" href="../flyout.css" />
  <script src="../flyout.js" defer></script>
</head>
<body>
  <div id="flyout-nav" class="flyout-nav" aria-hidden="true">
    <button class="flyout-toggle" type="button" aria-label="Arcade menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div id="flyout-panel" class="flyout-panel"></div>
  </div>
  <button id="help-button" type="button" aria-label="How to play">?</button>
  <div id="instruction-modal" class="is-visible" role="dialog" aria-modal="true">
    <div id="instruction-card">
      <h2>How to Play</h2>
      <p>Move with Arrow keys. Eat all pellets and avoid ghosts.</p>
      <p>Power pellets let you chase ghosts for bonus points.</p>
      <button id="instruction-close" type="button">Start</button>
    </div>
  </div>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Pac-Man Deluxe</h1>
    <canvas id="gameCanvas" width="640" height="544"></canvas>
    <div id="touch-controls" aria-hidden="true">
      <div class="control-cluster">
        <div class="control-row">
          <button type="button" class="control-button" data-key="ArrowLeft" data-code="ArrowLeft" aria-label="Move Left">L</button>
          <button type="button" class="control-button" data-key="ArrowRight" data-code="ArrowRight" aria-label="Move Right">R</button>
        </div>
        <div class="control-row">
          <button type="button" class="control-button" data-key="ArrowUp" data-code="ArrowUp" aria-label="Move Up">U</button>
          <button type="button" class="control-button" data-key="ArrowDown" data-code="ArrowDown" aria-label="Move Down">D</button>
        </div>
      </div>
    </div>
    <div id="info-panel">
      <span id="score">Score: 0</span>
      <span id="lives">Lives: 3</span>
      <span id="level">Level: 1</span>
    </div>
    <div id="message"></div>
    <div id="legend">
      <div><strong>Blinky</strong> – Relentless pursuit, locking onto your current tile with surgical precision.</div>
      <div><strong>Pinky</strong> – Plots ambushes by aiming four tiles ahead of your movement.</div>
      <div><strong>Inky</strong> – Calculates a flanking vector using Blinky and your trajectory.</div>
      <div><strong>Clyde</strong> – Shy: chases from afar but flees to his corner when he gets too close.</div>
    </div>
  </div>
  <script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const TILE = 32;
const FPS = 60;
const FRAME_TIME = 1000 / FPS;

const baseMap = [
  '####################',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o##.###.##.###.##o#',
  '#..................#',
  '#.##.#.######.#.##.#',
  '#....#..........#..#',
  '###..### #### ##..##',
  '###..#      # #..###',
  '####.# ###--# #.####',
  '     . #GGGG# .     ',
  '####.# #----# #.####',
  '####.# ###### #.####',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o.. ....P..... ..o#',
  '####################'
];

const altMapOne = [
  '####################',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o##.###.##.###.##o#',
  '#..................#',
  '#.##.#.##..##.#.##.#',
  '#....#.....#....#..#',
  '#.##.##. ###. ###..#',
  '#.##..      # ..##.#',
  '#.##.# ###--# #.##.#',
  '     . #GGGG# .     ',
  '####.# #----# #.####',
  '####.# ###### #.####',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o.. ....P..... ..o#',
  '####################'
];

const altMapTwo = [
  '####################',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o##.###.##.###.##o#',
  '#..................#',
  '#.##.#.######.#.##.#',
  '#....#..........#..#',
  '#..#.### #### ###..#',
  '####..      # ..####',
  '####.# ###--# #.####',
  '     . #GGGG# .     ',
  '####.# #----# #.####',
  '####.# ###### #.####',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o.. ....P..... ..o#',
  '####################'
];

const altMapThree = [
  '####################',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o##.###.##.###.##o#',
  '#..................#',
  '#.##.#..####..#.##.#',
  '#....#.............#',
  '###..### #### ##..##',
  '####..      # ..####',
  '####.# ###--# #.####',
  '     . #GGGG# .     ',
  '####.# #----# #.####',
  '####.# ###### #.####',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o.. ....P..... ..o#',
  '####################'
];

const altMapFour = [
  '####################',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o##.###.##.###.##o#',
  '#..................#',
  '#.##.#..####..#.##.#',
  '#....#....##....#..#',
  '#..#.### ..## #.#..#',
  '#..#.#      # #.#..#',
  '####.# ###--# #.####',
  '     . #GGGG# .     ',
  '####.# #----# #.####',
  '####.# ###### #.####',
  '#........##........#',
  '#.##.###.##.###.##.#',
  '#o.. ....P..... ..o#',
  '####################'
];

const MAPS = [baseMap, altMapOne, altMapTwo, altMapThree, altMapFour];
let mapRotation = [];

let map = [];
let pellets = 0;
let score = 0;
let lives = 3;
let level = 1;
let frightTimer = 0;
let frightChain = 0;
let globalModeIndex = 0;
let globalModeTimer = 0;
let message = '';
let startDelay = 90; // frames
let gamePaused = true;
let gameStarted = false;

const DIRECTIONS = [
  { x: 1, y: 0, name: 'right' },
  { x: -1, y: 0, name: 'left' },
  { x: 0, y: -1, name: 'up' },
  { x: 0, y: 1, name: 'down' }
];

const MODE_SEQUENCE = [
  { mode: 'scatter', duration: 7 * FPS },
  { mode: 'chase', duration: 20 * FPS },
  { mode: 'scatter', duration: 7 * FPS },
  { mode: 'chase', duration: 20 * FPS },
  { mode: 'scatter', duration: 5 * FPS },
  { mode: 'chase', duration: Infinity }
];

const TURN_THRESHOLD = 0.1;
const SNAP_THRESHOLD = 0.1;
const TURN_BUFFER = 0.2;
const TURN_BUFFER_FRAMES = Math.floor(0.2 * FPS);

function tileCenter(value) {
  return Math.floor(value) + 0.5;
}

function tileIndex(value) {
  return Math.floor(value);
}

function dynamicTurnThreshold(entity) {
  return Math.min(TURN_THRESHOLD, Math.max(0.04, entity.speed * 0.9));
}

function dynamicSnapThreshold(entity) {
  return Math.min(SNAP_THRESHOLD, Math.max(0.04, entity.speed * 1.1));
}

function dynamicTurnBuffer(entity) {
  return Math.min(TURN_BUFFER, Math.max(0.1, entity.speed * 2.2));
}

const PACMAN_BASE_SPEED = 0.14;
const GHOST_FRIGHT_MULT = 0.7;
const FRIGHT_BLINK_SECONDS = 3;
const PACMAN_DEATH_FRAMES = 36;

const pacman = {
  x: 9.5,
  y: 15.5,
  dir: { x: 0, y: 0 },
  nextDir: { x: 0, y: 0 },
  speed: PACMAN_BASE_SPEED,
  bufferTimer: 0,
  deathTimer: 0
};

const GHOST_TEMPLATES = [
  {
    name: 'Blinky',
    color: '#ff2b2b',
    scatter: { x: 18, y: 1 },
    x: 9.5,
    y: 8.5,
    dir: { x: 1, y: 0 },
    speed: 0.125,
    state: 'chase',
    releasePath: []
  },
  {
    name: 'Pinky',
    color: '#ff8ed1',
    scatter: { x: 1, y: 1 },
    x: 9.5,
    y: 10.5,
    dir: { x: -1, y: 0 },
    speed: 0.12,
    state: 'in-house',
    releaseDelay: 60,
    releasePath: [
      { x: 9.5, y: 10.5 },
      { x: 10.5, y: 10.5 },
      { x: 10.5, y: 9.5 },
      { x: 10.5, y: 8.5 }
    ]
  },
  {
    name: 'Inky',
    color: '#4de0ff',
    scatter: { x: 18, y: 15 },
    x: 10.5,
    y: 10.5,
    dir: { x: 1, y: 0 },
    speed: 0.12,
    state: 'in-house',
    releaseDelay: 120,
    releasePath: [
      { x: 10.5, y: 10.5 },
      { x: 10.5, y: 9.5 },
      { x: 10.5, y: 8.5 }
    ]
  },
  {
    name: 'Clyde',
    color: '#ffb347',
    scatter: { x: 1, y: 15 },
    x: 8.5,
    y: 10.5,
    dir: { x: -1, y: 0 },
    speed: 0.115,
    state: 'in-house',
    releaseDelay: 180,
    releasePath: [
      { x: 8.5, y: 10.5 },
      { x: 9.5, y: 10.5 },
      { x: 10.5, y: 10.5 },
      { x: 10.5, y: 9.5 },
      { x: 10.5, y: 8.5 }
    ]
  }
];


const ghosts = GHOST_TEMPLATES.map(t => ({
  name: t.name,
  color: t.color,
  scatter: { ...t.scatter },
  x: t.x,
  y: t.y,
  dir: { ...t.dir },
  speed: t.speed,
  state: t.state,
  releaseDelay: t.releaseDelay,
  releasePath: t.releasePath ? t.releasePath.map(step => ({ ...step })) : [],
  releaseIndex: 0,
  respawnTimer: 0
}));

function cloneMap(sourceMap) {
  map = sourceMap.map(row => row.split('').map(ch => (ch === 'P' ? ' ' : ch)));
}

function levelSpeedMultiplier() {
  return 0.5 * Math.pow(1.2, Math.max(0, level - 1));
}

function countPellets() {
  pellets = 0;
  map.forEach(row => row.forEach(ch => { if (ch === '.' || ch === 'o') pellets++; }));
}

function tileAt(x, y) {
  const tx = tileIndex(x);
  const ty = tileIndex(y);
  if (ty < 0 || ty >= map.length || tx < 0 || tx >= map[0].length) return '#';
  return map[ty][tx];
}

function isWallTile(ch) {
  return ch === '#';
}

function isWall(x, y) {
  return isWallTile(tileAt(x, y));
}

function wrapHorizontal(x) {
  const width = map[0].length;
  while (x < 0) x += width;
  while (x >= width) x -= width;
  return x;
}

function isIntersection(entity) {
  const threshold = dynamicTurnThreshold(entity);
  return Math.abs(entity.x - tileCenter(entity.x)) < threshold &&
         Math.abs(entity.y - tileCenter(entity.y)) < threshold;
}

function isOppositeDir(a, b) {
  return a && b && a.x === -b.x && a.y === -b.y;
}

function canTurnNow(entity, dir) {
  if (!dir) return false;
  const buffer = dynamicTurnBuffer(entity);
  if (dir.x !== 0) {
    return Math.abs(entity.y - tileCenter(entity.y)) < buffer;
  }
  if (dir.y !== 0) {
    return Math.abs(entity.x - tileCenter(entity.x)) < buffer;
  }
  return false;
}

function queueDirection(dir) {
  pacman.nextDir = { ...dir };
  pacman.bufferTimer = TURN_BUFFER_FRAMES;
}

function snapToGrid(entity) {
  const dir = entity.dir || { x: 0, y: 0 };
  const threshold = dynamicSnapThreshold(entity);

  if (dir.x === 0) {
    const targetX = tileCenter(entity.x);
    if (Math.abs(entity.x - targetX) < threshold && !isWall(targetX, entity.y)) {
      entity.x = targetX;
    }
  }

  if (dir.y === 0) {
    const targetY = tileCenter(entity.y);
    if (Math.abs(entity.y - targetY) < threshold && !isWall(entity.x, targetY)) {
      entity.y = targetY;
    }
  }
}

function move(entity, dir) {
  const speed = entity.speed;
  if (dir.x === 0 && dir.y === 0) return true;

  const nextX = entity.x + dir.x * speed;
  const nextY = entity.y + dir.y * speed;

  if (dir.x !== 0) {
    const frontX = wrapHorizontal(nextX + dir.x * 0.5);
    const upperY = nextY - 0.45;
    const lowerY = nextY + 0.45;
    if (isWall(frontX, upperY) || isWall(frontX, lowerY)) {
      return false;
    }
  }

  if (dir.y !== 0) {
    const frontY = nextY + dir.y * 0.5;
    const leftX = wrapHorizontal(nextX - 0.45);
    const rightX = wrapHorizontal(nextX + 0.45);
    if (isWall(leftX, frontY) || isWall(rightX, frontY)) {
      return false;
    }
  }

  entity.x = nextX;
  entity.y = nextY;
  entity.x = wrapHorizontal(entity.x);
  return true;
}

function canMoveDirection(entity, dir) {
  if (!dir || (dir.x === 0 && dir.y === 0)) return true;
  const width = map[0].length;
  const height = map.length;
  let tx = tileIndex(entity.x) + dir.x;
  let ty = tileIndex(entity.y) + dir.y;
  if (ty < 0 || ty >= height) return false;
  tx = ((tx % width) + width) % width;
  return !isWallTile(map[ty][tx]);
}

function updatePacman() {
  if (startDelay > 0) {
    return;
  }
  if (pacman.deathTimer > 0) {
    return;
  }
  if (pacman.bufferTimer > 0) {
    pacman.bufferTimer--;
  }

  if (isOppositeDir(pacman.dir, pacman.nextDir) && canMoveDirection(pacman, pacman.nextDir)) {
    pacman.dir = { ...pacman.nextDir };
  }

  const wantsDir = pacman.nextDir;
  const atCenter = isIntersection(pacman) || (pacman.dir.x === 0 && pacman.dir.y === 0);

  if (atCenter) {
    pacman.x = tileCenter(pacman.x);
    pacman.y = tileCenter(pacman.y);

    if (canMoveDirection(pacman, wantsDir)) {
      pacman.dir = { ...wantsDir };
      pacman.bufferTimer = 0;
    }

    if (!canMoveDirection(pacman, pacman.dir)) {
      pacman.dir = { x: 0, y: 0 };
    }
  } else if (pacman.bufferTimer > 0 && canMoveDirection(pacman, wantsDir) && canTurnNow(pacman, wantsDir)) {
    if (wantsDir.x !== 0) {
      pacman.y = tileCenter(pacman.y);
    } else {
      pacman.x = tileCenter(pacman.x);
    }
    pacman.dir = { ...wantsDir };
    pacman.bufferTimer = 0;
  }

  if (!move(pacman, pacman.dir)) {
    pacman.dir = { x: 0, y: 0 };
  }

  snapToGrid(pacman);

  const tx = tileIndex(pacman.x);
  const ty = tileIndex(pacman.y);
  const ch = tileAt(tx, ty);
  if (ch === '.' || ch === 'o') {
    map[ty][tx] = ' ';
    pellets--;
    score += (ch === 'o') ? 50 : 10;
    if (ch === 'o') {
      frightTimer = 7 * FPS;
      frightChain = 0;
      ghosts.forEach(g => {
        if (g.state !== 'respawn') {
          g.state = 'frightened';
          g.speed = getTemplate(g.name).speed * levelSpeedMultiplier() * GHOST_FRIGHT_MULT;
          g.dir = { x: -g.dir.x, y: -g.dir.y };
        }
      });
    }
  }
}

function getTemplate(name) {
  return GHOST_TEMPLATES.find(t => t.name === name);
}

function resetGhost(g) {
  const template = getTemplate(g.name);
  g.x = template.x;
  g.y = template.y;
  g.dir = { ...template.dir };
  g.speed = template.speed * levelSpeedMultiplier();
  g.state = template.state;
  g.scatter = { ...template.scatter };
  g.releaseDelay = template.releaseDelay;
  g.releasePath = template.releasePath ? template.releasePath.map(step => ({ ...step })) : [];
  g.releaseIndex = 0;
  g.respawnTimer = 0;
}

function resetPositions() {
  pacman.x = 9.5;
  pacman.y = 15.5;
  pacman.dir = { x: 0, y: 0 };
  pacman.nextDir = { x: 0, y: 0 };
  pacman.speed = PACMAN_BASE_SPEED * levelSpeedMultiplier();
  pacman.bufferTimer = 0;
  pacman.deathTimer = 0;
  ghosts.forEach(resetGhost);
  frightTimer = 0;
  frightChain = 0;
  globalModeIndex = 0;
  globalModeTimer = MODE_SEQUENCE[0].duration;
  startDelay = 90;
}

function startLevel() {
  if (mapRotation.length === 0) {
    mapRotation = MAPS.map((_, index) => index);
    for (let i = mapRotation.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [mapRotation[i], mapRotation[j]] = [mapRotation[j], mapRotation[i]];
    }
  }
  const mapIndex = mapRotation.shift();
  cloneMap(MAPS[mapIndex]);
  countPellets();
  resetPositions();
}

function resetGame() {
  score = 0;
  lives = 3;
  level = 1;
  message = '';
  startLevel();
}

function availableDirections(entity, allowReverse = false) {
  const currentDir = entity.dir;
  const options = [];
  for (const dir of DIRECTIONS) {
    if (!allowReverse && dir.x === -currentDir.x && dir.y === -currentDir.y) continue;
    const nx = entity.x + dir.x * 0.6;
    const ny = entity.y + dir.y * 0.6;
    if (!isWall(nx, ny)) {
      options.push(dir);
    }
  }
  if (options.length === 0 && !allowReverse) {
    return availableDirections(entity, true);
  }
  return options;
}

function bfsDistance(start, goal) {
  const sx = tileIndex(start.x);
  const sy = tileIndex(start.y);
  const gx = tileIndex(goal.x);
  const gy = tileIndex(goal.y);
  if (sx === gx && sy === gy) return 0;
  const queue = [[sx, sy, 0]];
  const visited = new Set([`${sx},${sy}`]);
  while (queue.length) {
    const [x, y, d] = queue.shift();
    for (const dir of DIRECTIONS) {
      const nx = x + dir.x;
      const ny = y + dir.y;
      const key = `${nx},${ny}`;
      if (visited.has(key)) continue;
      if (isWall(nx + 0.1, ny + 0.1)) continue;
      if (nx === gx && ny === gy) return d + 1;
      visited.add(key);
      queue.push([nx, ny, d + 1]);
    }
  }
  return Infinity;
}

function clampTarget(target) {
  target.x = Math.max(0, Math.min(map[0].length - 1, target.x));
  target.y = Math.max(0, Math.min(map.length - 1, target.y));
  return target;
}

function normalizeTarget(target) {
  const width = map[0].length;
  const height = map.length;
  const tx = Math.max(0, Math.min(width - 1, tileIndex(target.x)));
  const ty = Math.max(0, Math.min(height - 1, tileIndex(target.y)));
  if (!isWallTile(map[ty][tx])) {
    return { x: tx + 0.5, y: ty + 0.5 };
  }
  const queue = [[tx, ty]];
  const visited = new Set([`${tx},${ty}`]);
  while (queue.length) {
    const [x, y] = queue.shift();
    for (const dir of DIRECTIONS) {
      const nx = x + dir.x;
      const ny = y + dir.y;
      const key = `${nx},${ny}`;
      if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
      if (visited.has(key)) continue;
      if (!isWallTile(map[ny][nx])) {
        return { x: nx + 0.5, y: ny + 0.5 };
      }
      visited.add(key);
      queue.push([nx, ny]);
    }
  }
  return { x: tx + 0.5, y: ty + 0.5 };
}

function ghostTarget(g) {
  if (g.state === 'frightened') {
    return normalizeTarget({ x: Math.random() * map[0].length, y: Math.random() * map.length });
  }

  const mode = MODE_SEQUENCE[globalModeIndex].mode;
  if (mode === 'scatter') {
    return normalizeTarget(g.scatter);
  }

  if (g.name === 'Blinky') {
    const lead = (pacman.dir.x !== 0 || pacman.dir.y !== 0) ? 2 : 0;
    return normalizeTarget({
      x: pacman.x + pacman.dir.x * lead,
      y: pacman.y + pacman.dir.y * lead
    });
  }
  if (g.name === 'Pinky') {
    const ahead = {
      x: pacman.x + pacman.dir.x * 4,
      y: pacman.y + pacman.dir.y * 4
    };
    return normalizeTarget(ahead);
  }
  if (g.name === 'Inky') {
    const blinky = ghosts.find(ghost => ghost.name === 'Blinky');
    const pivot = {
      x: pacman.x + pacman.dir.x * 2,
      y: pacman.y + pacman.dir.y * 2
    };
    const vector = {
      x: (pivot.x - blinky.x) * 2 + blinky.x,
      y: (pivot.y - blinky.y) * 2 + blinky.y
    };
    return normalizeTarget(vector);
  }
  if (g.name === 'Clyde') {
    const dx = g.x - pacman.x;
    const dy = g.y - pacman.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist <= 6) {
      return normalizeTarget(g.scatter);
    }
    return normalizeTarget({
      x: pacman.x + pacman.dir.x * 1,
      y: pacman.y + pacman.dir.y * 1
    });
  }
  return normalizeTarget({ x: pacman.x, y: pacman.y });
}

function updateGhostState(g) {
  if (startDelay > 0) {
    g.state = 'in-house';
    return;
  }
  if (g.state === 'respawn') {
    g.respawnTimer--;
    if (g.respawnTimer <= 0) {
      resetGhost(g);
      g.state = 'in-house';
      g.releaseDelay = 60;
    }
    return;
  }
  if (g.state === 'in-house') {
    if (g.releaseDelay && g.releaseDelay > 0) {
      g.releaseDelay--;
      return;
    }
    g.state = 'exiting';
    g.releaseIndex = 0;
    g.speed = getTemplate(g.name).speed * levelSpeedMultiplier();
    return;
  }
  if (g.state !== 'frightened' && g.state !== 'in-house' && g.state !== 'exiting') {
    g.state = MODE_SEQUENCE[globalModeIndex].mode;
    g.speed = getTemplate(g.name).speed * levelSpeedMultiplier();
  }
}

function updateGhost(g) {
  updateGhostState(g);

  if (g.state === 'respawn') {
    return;
  }

  if (g.state === 'exiting') {
    const step = g.releasePath[g.releaseIndex];
    if (step) {
      const dx = step.x - g.x;
      const dy = step.y - g.y;
      if (Math.abs(dx) < 0.12 && Math.abs(dy) < 0.12) {
        g.x = step.x;
        g.y = step.y;
        g.releaseIndex += 1;
      } else {
        if (Math.abs(dx) > Math.abs(dy)) {
          g.dir = { x: Math.sign(dx), y: 0 };
        } else {
          g.dir = { x: 0, y: Math.sign(dy) };
        }
        move(g, g.dir);
        snapToGrid(g);
      }
      return;
    }
    g.state = MODE_SEQUENCE[globalModeIndex].mode;
    g.dir = { x: 0, y: -1 };
  }

  if (!isIntersection(g) && g.state !== 'in-house') {
    if (!move(g, g.dir)) {
      const fallback = availableDirections(g, true);
      if (fallback.length) {
        g.dir = fallback[Math.floor(Math.random() * fallback.length)];
        move(g, g.dir);
      } else {
        g.dir = { x: -g.dir.x, y: -g.dir.y };
        move(g, g.dir);
      }
    }
    snapToGrid(g);
    return;
  }

  if (g.state === 'in-house') {
    const bounceDirs = [{ x: 1, y: 0 }, { x: -1, y: 0 }];
    if (g.x <= 8.5) g.dir = bounceDirs[0];
    if (g.x >= 10.5) g.dir = bounceDirs[1];
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  const options = availableDirections(g);
  if (options.length === 0) {
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  if (g.state === 'frightened') {
    g.dir = options[Math.floor(Math.random() * options.length)];
    move(g, g.dir);
    snapToGrid(g);
    return;
  }

  const target = ghostTarget(g);
  let bestDir = options[0];
  let bestDist = Infinity;
  for (const dir of options) {
    const nextPos = { x: g.x + dir.x, y: g.y + dir.y };
    const dist = bfsDistance(nextPos, target);
    if (dist < bestDist || (dist === bestDist && dir.name === 'up')) {
      bestDist = dist;
      bestDir = dir;
    }
  }
  g.dir = bestDir;
  if (!move(g, g.dir)) {
    const fallback = availableDirections(g, true);
    if (fallback.length) {
      g.dir = fallback[Math.floor(Math.random() * fallback.length)];
      move(g, g.dir);
    }
  }
  snapToGrid(g);
}

function updateModes() {
  if (frightTimer > 0) {
    frightTimer--;
    if (frightTimer === 0) {
      ghosts.forEach(g => {
        if (g.state === 'frightened') {
          g.state = MODE_SEQUENCE[globalModeIndex].mode;
          g.speed = getTemplate(g.name).speed * levelSpeedMultiplier();
        }
      });
      frightChain = 0;
    }
    return;
  }
  if (MODE_SEQUENCE[globalModeIndex].duration === Infinity) return;
  globalModeTimer--;
  if (globalModeTimer <= 0) {
    const previousMode = MODE_SEQUENCE[globalModeIndex].mode;
    globalModeIndex = Math.min(globalModeIndex + 1, MODE_SEQUENCE.length - 1);
    globalModeTimer = MODE_SEQUENCE[globalModeIndex].duration;
    const nextMode = MODE_SEQUENCE[globalModeIndex].mode;
    if (previousMode !== nextMode) {
      ghosts.forEach(g => {
        if (g.state !== 'frightened' && g.state !== 'in-house' && g.state !== 'exiting' && g.state !== 'respawn') {
          g.dir = { x: -g.dir.x, y: -g.dir.y };
        }
      });
    }
  }
}

function checkCollisions() {
  for (const g of ghosts) {
    if (Math.hypot(g.x - pacman.x, g.y - pacman.y) < 0.55) {
      if (g.state === 'frightened') {
        frightChain += 1;
        score += 200 * Math.pow(2, frightChain - 1);
        g.state = 'respawn';
        g.respawnTimer = 60;
        g.dir = { x: 0, y: 0 };
        g.x = -10;
        g.y = -10;
      } else if (g.state !== 'respawn') {
        if (pacman.deathTimer > 0) {
          return;
        }
        lives--;
        pacman.deathTimer = PACMAN_DEATH_FRAMES;
        message = 'Ouch! Blinky is pleased...';
        if (lives <= 0) {
          message = 'Game Over - press Space to restart';
          pacman.dir = { x: 0, y: 0 };
          return;
        }
        return;
      }
    }
  }
  if (pellets === 0) {
    level++;
    score += 500;
    message = `Level ${level} - the ghosts grow wiser.`;
    startLevel();
  }
}

function drawBackground() {
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, 'rgba(5, 7, 33, 0.9)');
  gradient.addColorStop(1, 'rgba(1, 1, 12, 0.95)');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawRoundedRectPath(x, y, w, h, r) {
  ctx.beginPath();
  if (typeof ctx.roundRect === 'function') {
    ctx.roundRect(x, y, w, h, r);
  } else {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
  }
}

function drawMap() {
  drawBackground();
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      const tile = map[y][x];
      const px = x * TILE;
      const py = y * TILE;
      if (tile === '#') {
        const grad = ctx.createLinearGradient(px, py, px, py + TILE);
        grad.addColorStop(0, '#0a0b3d');
        grad.addColorStop(0.4, '#1423ff');
        grad.addColorStop(1, '#040527');
        ctx.fillStyle = grad;
        drawRoundedRectPath(px + 3, py + 3, TILE - 6, TILE - 6, 10);
        ctx.fill();
        ctx.strokeStyle = 'rgba(111, 164, 255, 0.35)';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(px, py, TILE, TILE);
      }
      if (tile === '.') {
        ctx.fillStyle = '#fffcf2';
        ctx.beginPath();
        ctx.arc(px + TILE / 2, py + TILE / 2, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      if (tile === 'o') {
        const pulse = 6 + Math.sin(Date.now() / 120) * 2;
        const grad = ctx.createRadialGradient(px + TILE / 2, py + TILE / 2, 0, px + TILE / 2, py + TILE / 2, pulse + 4);
        grad.addColorStop(0, '#ffe066');
        grad.addColorStop(1, 'rgba(255, 224, 102, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(px + TILE / 2, py + TILE / 2, pulse, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function drawPacman() {
  const centerX = pacman.x * TILE;
  const centerY = pacman.y * TILE;
  if (pacman.deathTimer > 0) {
    const progress = 1 - pacman.deathTimer / PACMAN_DEATH_FRAMES;
    const radius = Math.max(0, (TILE / 2 - 2) * (1 - progress));
    if (radius <= 0.5) {
      return;
    }
    const mouth = (1 - progress) * Math.PI;
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.fillStyle = '#ffe066';
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.arc(0, 0, radius, mouth / 2, Math.PI * 2 - mouth / 2, false);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    return;
  }
  let angleOffset = 0;
  if (pacman.dir.x === 1) angleOffset = 0;
  else if (pacman.dir.x === -1) angleOffset = Math.PI;
  else if (pacman.dir.y === -1) angleOffset = -Math.PI / 2;
  else if (pacman.dir.y === 1) angleOffset = Math.PI / 2;
  const mouth = (Math.sin(Date.now() / 90) * 0.25 + 0.35) * Math.PI;
  ctx.save();
  ctx.translate(centerX, centerY);
  ctx.rotate(angleOffset);
  ctx.fillStyle = '#ffe066';
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.arc(0, 0, TILE / 2 - 2, mouth / 2, Math.PI * 2 - mouth / 2, false);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
}

function drawGhost(g) {
  if (g.state === 'respawn') {
    return;
  }
  const x = g.x * TILE;
  const y = g.y * TILE;
  const blinkActive = g.state === 'frightened' && frightTimer > 0 && frightTimer <= FRIGHT_BLINK_SECONDS * FPS;
  const blinkOn = blinkActive && Math.floor(frightTimer / 6) % 2 === 0;
  const bodyColor = (g.state === 'frightened')
    ? (blinkOn ? '#ffffff' : '#3a57ff')
    : g.color;
  ctx.save();
  ctx.translate(x, y);
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  const bodyWidth = TILE - 6;
  const bodyHeight = TILE - 4;
  ctx.moveTo(-bodyWidth / 2, bodyHeight / 2);
  ctx.lineTo(-bodyWidth / 2, 0);
  ctx.quadraticCurveTo(-bodyWidth / 2, -bodyHeight / 2, 0, -bodyHeight / 2);
  ctx.quadraticCurveTo(bodyWidth / 2, -bodyHeight / 2, bodyWidth / 2, 0);
  ctx.lineTo(bodyWidth / 2, bodyHeight / 2);
  const waveCount = 4;
  for (let i = 0; i <= waveCount; i++) {
    const dx = bodyWidth / 2 - (i * bodyWidth) / waveCount;
    const direction = i % 2 === 0 ? 1 : -1;
    ctx.quadraticCurveTo(dx - bodyWidth / waveCount / 2, bodyHeight / 2 + 4 * direction, dx - bodyWidth / waveCount, bodyHeight / 2);
  }
  ctx.closePath();
  ctx.fill();

  const eyeColor = (g.state === 'frightened') ? '#fff' : '#fff';
  const pupilColor = (g.state === 'frightened') ? '#222' : '#1a1a1a';
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.ellipse(-6, -4, 5, 7, 0, 0, Math.PI * 2);
  ctx.ellipse(6, -4, 5, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = pupilColor;
  const pupilOffset = { x: g.dir.x * 3, y: g.dir.y * 3 };
  ctx.beginPath();
  ctx.arc(-6 + pupilOffset.x, -4 + pupilOffset.y, 2.5, 0, Math.PI * 2);
  ctx.arc(6 + pupilOffset.x, -4 + pupilOffset.y, 2.5, 0, Math.PI * 2);
  ctx.fill();

  if (g.state === 'frightened') {
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-6, 5);
    ctx.lineTo(-2, 7);
    ctx.lineTo(2, 5);
    ctx.lineTo(6, 7);
    ctx.stroke();
  }
  ctx.restore();
}

function draw() {
  drawMap();
  drawPacman();
  ghosts.forEach(drawGhost);

  document.getElementById('score').textContent = `Score: ${score}`;
  document.getElementById('lives').textContent = `Lives: ${lives}`;
  document.getElementById('level').textContent = `Level: ${level}`;
  document.getElementById('message').textContent = message;
}

function gameLoop() {
  if (gamePaused) {
    draw();
    return;
  }
  if (pacman.deathTimer > 0) {
    pacman.deathTimer--;
    draw();
    if (pacman.deathTimer === 0) {
      if (lives <= 0) {
        return;
      }
      resetPositions();
    }
    return;
  }
  if (lives <= 0) {
    draw();
    return;
  }
  if (startDelay > 0) {
    startDelay--;
    message = 'Ready!';
    draw();
    if (startDelay === 0) {
      message = '';
    }
    return;
  }
  updatePacman();
  ghosts.forEach(updateGhost);
  updateModes();
  checkCollisions();
  draw();
}

function handleKeyDown(e) {
  if (gamePaused) return;
  const key = e.key;
  if (key.startsWith('Arrow')) {
    e.preventDefault();
  }
  if (key === 'ArrowLeft' || key === 'a' || key === 'A') queueDirection({ x: -1, y: 0 });
  if (key === 'ArrowRight' || key === 'd' || key === 'D') queueDirection({ x: 1, y: 0 });
  if (key === 'ArrowUp' || key === 'w' || key === 'W') queueDirection({ x: 0, y: -1 });
  if (key === 'ArrowDown' || key === 's' || key === 'S') queueDirection({ x: 0, y: 1 });
  if (key === ' ' && lives <= 0) {
    resetGame();
  }
}

document.addEventListener('keydown', handleKeyDown);

setInterval(gameLoop, FRAME_TIME);

const instructionModal = document.getElementById('instruction-modal');
const instructionClose = document.getElementById('instruction-close');
const helpButton = document.getElementById('help-button');
const instructionKey = 'vibecade-instructions-pacman';
const hasSeenInstructions = sessionStorage.getItem(instructionKey) === '1';
const controlButtons = document.querySelectorAll('.control-button');
const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;
if (isTouchDevice) {
  document.body.classList.add('touch-device');
}

function startGame() {
  if (gameStarted) return;
  gameStarted = true;
  gamePaused = false;
  resetGame();
}

function showInstructions() {
  gamePaused = true;
  if (instructionModal) instructionModal.classList.add('is-visible');
}

function hideInstructions() {
  if (instructionModal) instructionModal.classList.remove('is-visible');
  if (!gameStarted) {
    startGame();
  } else {
    gamePaused = false;
  }
  sessionStorage.setItem(instructionKey, '1');
}

if (instructionClose) {
  instructionClose.addEventListener('click', hideInstructions);
}
if (instructionModal) {
  instructionModal.addEventListener('click', (event) => {
    if (event.target === instructionModal) {
      hideInstructions();
    }
  });
}
if (helpButton) {
  helpButton.addEventListener('click', showInstructions);
}

function dispatchKeyEvent(key, code, type) {
  const event = new KeyboardEvent(type, { key, code, bubbles: true });
  window.dispatchEvent(event);
}

if (controlButtons.length && isTouchDevice) {
  controlButtons.forEach((button) => {
    const key = button.dataset.key;
    const code = button.dataset.code || button.dataset.key;
    const press = () => {
      if (gamePaused) return;
      button.classList.add('pressed');
      dispatchKeyEvent(key, code, 'keydown');
    };
    const release = () => {
      button.classList.remove('pressed');
      dispatchKeyEvent(key, code, 'keyup');
    };
    button.addEventListener('touchstart', (event) => {
      event.preventDefault();
      press();
    }, { passive: false });
    button.addEventListener('touchend', (event) => {
      event.preventDefault();
      release();
    }, { passive: false });
    button.addEventListener('touchcancel', release);
    button.addEventListener('mousedown', press);
    button.addEventListener('mouseup', release);
    button.addEventListener('mouseleave', release);
  });
}

if (hasSeenInstructions) {
  if (instructionModal) instructionModal.classList.remove('is-visible');
  startGame();
}
  </script>
</body>
</html>


