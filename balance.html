<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Block Balance</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: #222;
      color: #fff;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    #sidebar li {
      margin: 15px 0;
    }
    #sidebar a {
      color: #fff;
      text-decoration: none;
      transition: color 0.3s;
    }
    #sidebar a:hover {
      color: #ffea00;
    }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    h1 {
      margin-top: 0;
      font-size: 3em;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }
    canvas {
      background: #000;
      border: 2px solid #fff;
      border-radius: 8px;
    }
    #score {
      margin-top: 10px;
      font-size: 20px;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 5px;
    }
    #message {
      margin-top: 10px;
      font-size: 24px;
      color: #ff3333;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Block Balance</h1>
    <canvas id="world" width="800" height="600"></canvas>
    <div id="score">Blocks: 0</div>
    <div id="message"></div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script>
    const { Engine, Render, Runner, Bodies, World, Body, Events } = Matter;
    const engine = Engine.create();
    const world = engine.world;
    world.gravity.y = 0.125;
    const canvas = document.getElementById('world');
    const render = Render.create({
      canvas: canvas,
      engine: engine,
      options: {
        width: 800,
        height: 600,
        wireframes: false,
        background: '#000'
      }
    });
    Render.run(render);
    const runner = Runner.create();
    Runner.run(runner, engine);

    const platformWidth = 180;
    const platformHeight = 20;
    const platform = Bodies.rectangle(400, 560, platformWidth, platformHeight, {
      isStatic: true,
      friction: 0.8,
      render: { fillStyle: '#fff' }
    });
    World.add(world, platform);

    // Track platform movement for friction
    let lastPlatformX = platform.position.x;
    let lastDx = 0;
    let followFactor = 1;
    const blocksOnPlatform = new Set();
    const blockContacts = new Map();

    function addBlockContact(a, b) {
      if (!blockContacts.has(a)) blockContacts.set(a, new Set());
      blockContacts.get(a).add(b);
    }
    function removeBlockContact(a, b) {
      if (!blockContacts.has(a)) return;
      const set = blockContacts.get(a);
      set.delete(b);
      if (set.size === 0) blockContacts.delete(a);
    }

    let moveLeft = false;
    let moveRight = false;
    const moveSpeed = 7;
    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = true;
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight = true;
    });
    document.addEventListener('keyup', e => {
      if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft = false;
      if (e.key === 'ArrowRight' || e.key === 'd') moveRight = false;
    });

    Events.on(engine, 'collisionStart', event => {
      for (const pair of event.pairs) {
        if (pair.bodyA === platform && pair.bodyB.label === 'block') {
          blocksOnPlatform.add(pair.bodyB);
        } else if (pair.bodyB === platform && pair.bodyA.label === 'block') {
          blocksOnPlatform.add(pair.bodyA);
        } else if (pair.bodyA.label === 'block' && pair.bodyB.label === 'block') {
          addBlockContact(pair.bodyA, pair.bodyB);
          addBlockContact(pair.bodyB, pair.bodyA);
        }
      }
    });

    Events.on(engine, 'collisionEnd', event => {
      for (const pair of event.pairs) {
        if (pair.bodyA === platform && pair.bodyB.label === 'block') {
          blocksOnPlatform.delete(pair.bodyB);
        } else if (pair.bodyB === platform && pair.bodyA.label === 'block') {
          blocksOnPlatform.delete(pair.bodyA);
        } else if (pair.bodyA.label === 'block' && pair.bodyB.label === 'block') {
          removeBlockContact(pair.bodyA, pair.bodyB);
          removeBlockContact(pair.bodyB, pair.bodyA);
        }
      }
    });

    Events.on(engine, 'beforeUpdate', () => {
      if (moveLeft && platform.position.x - platformWidth / 2 > 0) {
        Body.translate(platform, { x: -moveSpeed, y: 0 });
      }
      if (moveRight && platform.position.x + platformWidth / 2 < 800) {
        Body.translate(platform, { x: moveSpeed, y: 0 });
      }

      // Apply friction so blocks initially slide then catch up to the platform
      const dx = platform.position.x - lastPlatformX;
      if (dx !== 0) {
        if (lastDx === 0 || Math.sign(dx) !== Math.sign(lastDx)) {
          followFactor = 0.9;
        } else {
          followFactor += (1 - followFactor) * 0.2;
        }
      } else {
        followFactor = 1;
      }
      const carry = dx * followFactor;

      const visited = new Set();
      const queue = Array.from(blocksOnPlatform);
      while (queue.length) {
        const block = queue.shift();
        if (visited.has(block)) continue;
        visited.add(block);
        Body.translate(block, { x: carry, y: 0 });
        const neighbors = blockContacts.get(block);
        if (neighbors) {
          neighbors.forEach(n => {
            if (!visited.has(n)) queue.push(n);
          });
        }
      }
      lastPlatformX = platform.position.x;
      lastDx = dx;
    });

    const blocks = [];
    const blockColors = ['#e74c3c', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#e67e22'];
    let score = 0;
    function spawnBlock() {
      const size = 40;
      const x = Math.random() * (800 - size) + size/2;
      const color = blockColors[Math.floor(Math.random() * blockColors.length)];
      const block = Bodies.rectangle(x, -size, size, size, {
        label: 'block',
        friction: 0.6,
        restitution: 0.1,
        render: { fillStyle: color }
      });
      blocks.push(block);
      World.add(world, block);
      score++;
      document.getElementById('score').textContent = 'Blocks: ' + score;
    }

    const spawnInterval = setInterval(() => {
      if (!gameOver) spawnBlock();
    }, 2000);

    let gameOver = false;
    Events.on(engine, 'afterUpdate', () => {
      if (gameOver) return;
      for (const block of blocks) {
        const { x, y } = block.position;
        if (y > 650 || x < -60 || x > 860) {
          gameOver = true;
          document.getElementById('message').textContent = 'Game Over!';
          clearInterval(spawnInterval);
          Runner.stop(runner);
          break;
        }
      }
    });
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
