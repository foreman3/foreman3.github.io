<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trap the Mouse</title>
  <style>
    :root {
      color-scheme: light;
    }
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: radial-gradient(circle at top, #f9f2ff 0%, #f1e0f7 45%, #e5d0f0 100%);
      color: #42314b;
    }
    #sidebar-placeholder {
      flex: 0 0 240px;
    }
    #game-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 24px;
      box-sizing: border-box;
      gap: 16px;
    }
    h1 {
      margin: 0;
      font-size: clamp(2.4rem, 3vw, 3.2rem);
      letter-spacing: 1px;
      text-shadow: 0 6px 16px rgba(70, 41, 87, 0.28);
    }
    #info-panel {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 12px 20px;
      padding: 14px 18px;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.72);
      box-shadow: 0 16px 45px rgba(72, 43, 92, 0.18);
      backdrop-filter: blur(6px);
    }
    .stat {
      font-weight: 600;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 6px;
      color: #50305f;
    }
    .stat span {
      font-weight: 700;
      color: #7a4ca1;
    }
    #reset-button {
      border: none;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 0.95rem;
      font-weight: 600;
      color: #fff;
      background: linear-gradient(135deg, #ff8db5, #ff73a5);
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s, filter 0.2s;
      box-shadow: 0 10px 25px rgba(255, 115, 165, 0.3);
    }
    #reset-button:hover {
      transform: translateY(-1px) scale(1.02);
      box-shadow: 0 14px 32px rgba(255, 115, 165, 0.35);
      filter: brightness(1.05);
    }
    #board {
      width: min(80vw, 640px);
      height: auto;
      max-height: 80vh;
      border-radius: 24px;
      box-shadow: 0 25px 45px rgba(73, 38, 94, 0.24);
      background: radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.95), rgba(238, 220, 252, 0.9));
      cursor: pointer;
      touch-action: manipulation;
    }
    #status {
      margin: 0;
      font-size: 1.05rem;
      padding: 10px 18px;
      border-radius: 18px;
      background: rgba(255, 255, 255, 0.65);
      box-shadow: inset 0 2px 8px rgba(122, 88, 148, 0.15);
    }
    #tip {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(66, 49, 75, 0.75);
    }
    @media (max-width: 900px) {
      body {
        flex-direction: column;
      }
      #sidebar-placeholder {
        width: 100%;
      }
      #game-area {
        padding: 16px 16px 40px;
      }
      #info-panel {
        width: 100%;
        justify-content: center;
      }
    }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <main id="game-area">
    <h1>Trap the Mouse</h1>
    <section id="info-panel">
      <div class="stat">Level <span id="level">1</span></div>
      <div class="stat">Grid <span id="grid-size">21 × 21</span></div>
      <div class="stat">Starting obstacles <span id="starting-obstacles">20</span></div>
      <button id="reset-button" type="button">Restart Level</button>
    </section>
    <canvas id="board" width="640" height="640"></canvas>
    <p id="status">Place an obstacle to keep the mouse from reaching the edge.</p>
    <p id="tip">Tip: Build gentle rings to nudge the mouse toward the center.</p>
  </main>
  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const levelEl = document.getElementById('level');
    const gridSizeEl = document.getElementById('grid-size');
    const startingObstaclesEl = document.getElementById('starting-obstacles');
    const statusEl = document.getElementById('status');
    const resetButton = document.getElementById('reset-button');

    const baseGridSize = 21;
    const minGridSize = 11;
    const baseObstacles = 20;
    let level = 1;
    let gridSize = baseGridSize;
    let grid = [];
    let mouse = { x: 0, y: 0 };
    let playerTurn = true;
    let waitingForReset = false;
    let startingObstacleCount = baseObstacles;
    let hexRadius = 0;
    let hexHeight = 0;
    let horizontalSpacing = 0;
    let verticalSpacing = 0;
    let boardOffsetX = 0;
    let boardOffsetY = 0;

    function computeHexGeometry() {
      const widthRadius = canvas.width / (1.5 * (gridSize - 1) + 2);
      const heightRadius = canvas.height / (Math.sqrt(3) * (gridSize + 0.5));
      hexRadius = Math.min(widthRadius, heightRadius);
      hexHeight = Math.sqrt(3) * hexRadius;
      horizontalSpacing = hexRadius * 1.5;
      verticalSpacing = hexHeight;
      const boardWidth = hexRadius * (1.5 * (gridSize - 1) + 2);
      const boardHeight = hexHeight * (gridSize + 0.5);
      boardOffsetX = (canvas.width - boardWidth) / 2;
      boardOffsetY = (canvas.height - boardHeight) / 2;
    }

    function getHexCenter(x, y) {
      const cx = boardOffsetX + hexRadius + x * horizontalSpacing;
      const cy = boardOffsetY + hexHeight / 2 + y * verticalSpacing + (x % 2 ? hexHeight / 2 : 0);
      return { cx, cy };
    }

    function beginHexPath(cx, cy, radius) {
      ctx.beginPath();
      for (let side = 0; side < 6; side++) {
        const angle = Math.PI / 180 * (60 * side - 30);
        const px = cx + radius * Math.cos(angle);
        const py = cy + radius * Math.sin(angle);
        if (side === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
      ctx.closePath();
    }

    function oddQToCube(x, y) {
      const cubeX = x;
      const cubeZ = y - (x - (x & 1)) / 2;
      const cubeY = -cubeX - cubeZ;
      return { x: cubeX, y: cubeY, z: cubeZ };
    }

    function hexDistance(a, b) {
      const ac = oddQToCube(a.x, a.y);
      const bc = oddQToCube(b.x, b.y);
      return Math.max(Math.abs(ac.x - bc.x), Math.abs(ac.y - bc.y), Math.abs(ac.z - bc.z));
    }

    function getNeighbors(x, y) {
      const parity = x & 1;
      if (parity === 0) {
        return [
          { x: x + 1, y },
          { x: x - 1, y },
          { x, y: y + 1 },
          { x, y: y - 1 },
          { x: x + 1, y: y - 1 },
          { x: x - 1, y: y - 1 }
        ];
      }
      return [
        { x: x + 1, y },
        { x: x - 1, y },
        { x, y: y + 1 },
        { x, y: y - 1 },
        { x: x + 1, y: y + 1 },
        { x: x - 1, y: y + 1 }
      ];
    }

    function isEdge(x, y) {
      return x === 0 || y === 0 || x === gridSize - 1 || y === gridSize - 1;
    }

    function resetGrid() {
      grid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
    }

    function placeRandomObstacles(count) {
      resetGrid();
      let placed = 0;
      const centerX = Math.floor(gridSize / 2);
      const centerY = Math.floor(gridSize / 2);
      while (placed < count) {
        const x = Math.floor(Math.random() * gridSize);
        const y = Math.floor(Math.random() * gridSize);
        if ((x === centerX && y === centerY) || grid[y][x] === 1) continue;
        grid[y][x] = 1;
        placed++;
      }
    }

    function findPathToEdge(start) {
      const queue = [{ x: start.x, y: start.y, path: [{ x: start.x, y: start.y }] }];
      const visited = Array.from({ length: gridSize }, () => Array(gridSize).fill(false));
      visited[start.y][start.x] = true;
      while (queue.length) {
        const current = queue.shift();
        if (isEdge(current.x, current.y)) {
          return current.path;
        }
        for (const neighbor of getNeighbors(current.x, current.y)) {
          const nx = neighbor.x;
          const ny = neighbor.y;
          if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) continue;
          if (grid[ny][nx] === 1 || visited[ny][nx]) continue;
          visited[ny][nx] = true;
          queue.push({
            x: nx,
            y: ny,
            path: current.path.concat({ x: nx, y: ny })
          });
        }
      }
      return null;
    }

    function isMouseTrapped() {
      return !findPathToEdge(mouse);
    }

    function ensurePlayableLayout() {
      let attempts = 0;
      while (attempts < 60) {
        placeRandomObstacles(startingObstacleCount);
        if (!isMouseTrapped()) return;
        attempts++;
      }
      // As a fallback, softly thin out obstacles around the mouse
      const removable = [];
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          if (grid[y][x] === 1) removable.push({ x, y, d: hexDistance({ x, y }, mouse) });
        }
      }
      removable.sort((a, b) => a.d - b.d);
      while (isMouseTrapped() && removable.length) {
        const { x, y } = removable.shift();
        grid[y][x] = 0;
      }
    }

    function resizeCanvas() {
      const sidebarAllowance = window.innerWidth <= 900 ? 60 : 260;
      const availableWidth = Math.max(220, window.innerWidth - sidebarAllowance);
      const availableHeight = Math.max(220, window.innerHeight - 220);
      const size = Math.max(260, Math.min(640, Math.min(availableWidth, availableHeight)));
      canvas.width = size;
      canvas.height = size;
      canvas.style.width = `${size}px`;
      canvas.style.height = `${size}px`;
      computeHexGeometry();
      drawBoard();
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff7fd';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.lineWidth = Math.max(1, hexRadius * 0.12);
      ctx.strokeStyle = 'rgba(90, 64, 113, 0.22)';
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const { cx, cy } = getHexCenter(x, y);
          beginHexPath(cx, cy, hexRadius * 0.96);
          ctx.stroke();
        }
      }
      ctx.restore();

      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          if (grid[y][x] === 1) drawObstacle(x, y);
        }
      }

      drawMouse();
    }

    function drawObstacle(x, y) {
      const { cx, cy } = getHexCenter(x, y);
      const radius = hexRadius * 0.72;
      const gradient = ctx.createLinearGradient(cx - radius, cy - radius, cx + radius, cy + radius);
      gradient.addColorStop(0, '#87c7a3');
      gradient.addColorStop(1, '#58a483');
      ctx.save();
      ctx.shadowColor = 'rgba(88, 164, 131, 0.4)';
      ctx.shadowBlur = hexRadius * 0.6;
      beginHexPath(cx, cy, radius);
      ctx.fillStyle = gradient;
      ctx.fill();
      ctx.restore();
    }

    function drawMouse() {
      const { cx: centerX, cy: centerY } = getHexCenter(mouse.x, mouse.y);
      const bodyRadius = hexRadius * 0.65;
      const earRadius = bodyRadius * 0.7;

      ctx.save();
      ctx.shadowColor = 'rgba(70, 45, 90, 0.25)';
      ctx.shadowBlur = bodyRadius * 1.2;

      // tail
      ctx.strokeStyle = '#f0a4c4';
      ctx.lineWidth = Math.max(2, hexRadius * 0.16);
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(centerX - bodyRadius * 0.6, centerY + bodyRadius * 0.7);
      ctx.quadraticCurveTo(centerX - bodyRadius * 1.6, centerY + bodyRadius * 1.3, centerX - bodyRadius * 2.1, centerY + bodyRadius * 0.4);
      ctx.stroke();

      // ears
      ctx.fillStyle = '#fbd9eb';
      ctx.beginPath();
      ctx.arc(centerX - bodyRadius * 0.7, centerY - bodyRadius * 0.9, earRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX + bodyRadius * 0.7, centerY - bodyRadius * 0.9, earRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#f4a9c7';
      ctx.beginPath();
      ctx.arc(centerX - bodyRadius * 0.7, centerY - bodyRadius * 0.9, earRadius * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX + bodyRadius * 0.7, centerY - bodyRadius * 0.9, earRadius * 0.6, 0, Math.PI * 2);
      ctx.fill();

      // body
      ctx.fillStyle = '#fbe9f5';
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, bodyRadius * 1.1, bodyRadius, 0, 0, Math.PI * 2);
      ctx.fill();

      // face
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(centerX, centerY, bodyRadius * 0.9, bodyRadius * 0.75, 0, 0, Math.PI * 2);
      ctx.fill();

      // eyes
      ctx.fillStyle = '#51355a';
      const eyeOffsetX = bodyRadius * 0.35;
      const eyeOffsetY = bodyRadius * 0.25;
      ctx.beginPath();
      ctx.arc(centerX - eyeOffsetX, centerY - eyeOffsetY, bodyRadius * 0.18, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX + eyeOffsetX, centerY - eyeOffsetY, bodyRadius * 0.18, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(centerX - eyeOffsetX + bodyRadius * 0.06, centerY - eyeOffsetY - bodyRadius * 0.05, bodyRadius * 0.07, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(centerX + eyeOffsetX + bodyRadius * 0.06, centerY - eyeOffsetY - bodyRadius * 0.05, bodyRadius * 0.07, 0, Math.PI * 2);
      ctx.fill();

      // nose
      ctx.fillStyle = '#ff8fb7';
      ctx.beginPath();
      ctx.arc(centerX, centerY + bodyRadius * 0.05, bodyRadius * 0.14, 0, Math.PI * 2);
      ctx.fill();

      // whiskers
      ctx.strokeStyle = 'rgba(121, 99, 138, 0.7)';
      ctx.lineWidth = Math.max(1.5, hexRadius * 0.1);
      ctx.beginPath();
      ctx.moveTo(centerX - bodyRadius * 0.2, centerY + bodyRadius * 0.05);
      ctx.lineTo(centerX - bodyRadius * 1.1, centerY - bodyRadius * 0.2);
      ctx.moveTo(centerX - bodyRadius * 0.2, centerY + bodyRadius * 0.12);
      ctx.lineTo(centerX - bodyRadius * 1.1, centerY + bodyRadius * 0.15);
      ctx.moveTo(centerX + bodyRadius * 0.2, centerY + bodyRadius * 0.05);
      ctx.lineTo(centerX + bodyRadius * 1.1, centerY - bodyRadius * 0.2);
      ctx.moveTo(centerX + bodyRadius * 0.2, centerY + bodyRadius * 0.12);
      ctx.lineTo(centerX + bodyRadius * 1.1, centerY + bodyRadius * 0.15);
      ctx.stroke();

      ctx.restore();
    }

    function startLevel() {
      gridSize = Math.max(minGridSize, baseGridSize - (level - 1));
      startingObstacleCount = Math.max(0, baseObstacles - (level - 1) * 2);
      const center = Math.floor(gridSize / 2);
      mouse = { x: center, y: center };
      ensurePlayableLayout();
      resizeCanvas();
      playerTurn = true;
      waitingForReset = false;
      levelEl.textContent = level;
      gridSizeEl.textContent = `${gridSize} × ${gridSize}`;
      startingObstaclesEl.textContent = startingObstacleCount;
      statusEl.textContent = 'Your turn! Place an obstacle to block the mouse.';
    }

    function handlePlayerTurn(event) {
      if (!playerTurn || waitingForReset) return;
      const rect = canvas.getBoundingClientRect();
      const clientX = event.clientX ?? event.touches?.[0]?.clientX;
      const clientY = event.clientY ?? event.touches?.[0]?.clientY;
      if (clientX === undefined || clientY === undefined) return;
      const point = {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
      const cell = pickCell(point.x, point.y);
      if (!cell) return;
      const { x, y } = cell;
      if (grid[y][x] === 1) {
        statusEl.textContent = 'That space already has a hedge. Try another spot!';
        return;
      }
      if (x === mouse.x && y === mouse.y) {
        statusEl.textContent = 'The mouse is sitting there! Pick an empty tile nearby.';
        return;
      }

      grid[y][x] = 1;
      drawBoard();
      if (isMouseTrapped()) {
        statusEl.textContent = `You trapped the mouse! Level ${level + 1} incoming...`;
        waitingForReset = true;
        setTimeout(() => {
          level++;
          startLevel();
        }, 1400);
        return;
      }
      playerTurn = false;
      statusEl.textContent = 'The mouse is scampering...';
      setTimeout(mouseMove, 400);
    }

    function pickCell(px, py) {
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const { cx, cy } = getHexCenter(x, y);
          const dx = Math.abs(px - cx);
          const dy = Math.abs(py - cy);
          if (dx > hexRadius || dy > hexHeight / 2) continue;
          if (Math.sqrt(3) * dx + dy <= hexHeight) {
            return { x, y };
          }
        }
      }
      return null;
    }

    function mouseMove() {
      const path = findPathToEdge(mouse);
      if (!path || path.length < 2) {
        if (isMouseTrapped()) {
          statusEl.textContent = `You trapped the mouse! Level ${level + 1} incoming...`;
          waitingForReset = true;
          setTimeout(() => {
            level++;
            startLevel();
          }, 1400);
          return;
        }
        playerTurn = true;
        statusEl.textContent = 'The mouse hesitates. Place another obstacle!';
        return;
      }
      const nextStep = path[1];
      mouse = { x: nextStep.x, y: nextStep.y };
      drawBoard();
      if (isEdge(mouse.x, mouse.y)) {
        statusEl.textContent = 'Oh no! The mouse escaped. Try again.';
        waitingForReset = true;
        setTimeout(() => {
          startLevel();
        }, 1400);
        return;
      }
      playerTurn = true;
      statusEl.textContent = 'Your turn! Place another obstacle.';
    }

    canvas.addEventListener('click', handlePlayerTurn);
    canvas.addEventListener('touchstart', event => {
      handlePlayerTurn(event);
      event.preventDefault();
    }, { passive: false });
    resetButton.addEventListener('click', () => {
      waitingForReset = false;
      statusEl.textContent = 'Level restarted. Give it another go!';
      startLevel();
    });

    window.addEventListener('resize', () => {
      window.requestAnimationFrame(resizeCanvas);
    });

    startLevel();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) {
          placeholder.outerHTML = html;
          const activeLink = document.querySelector('#sidebar a[href="trap-the-mouse.html"]');
          if (activeLink) {
            activeLink.classList.add('active');
            activeLink.style.fontWeight = '700';
          }
        }
      });
  </script>
</body>
</html>
