<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Qbert Clone</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg,#222 0%,#444 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul { list-style:none; padding:0; }
    #sidebar li { margin:15px 0; }
    #sidebar a { color:#fff; text-decoration:none; }
    #sidebar a:hover{ color:#ffea00; }
    #game-container {
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:20px;
    }
    canvas {
      background:#000;
      border:2px solid #fff;
      border-radius:8px;
    }
    #info { margin-top:10px; font-size:20px; }
    #message { margin-top:10px; font-size:24px; color:#ffeb3b; }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Qbert Clone</h1>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div id="info"></div>
    <div id="message"></div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ROWS = 7;
    const TILE = 50;
    const START_X = canvas.width/2;
    const START_Y = 60;
    const COLORS = ['#2196f3','#ff9800','#4caf50','#e91e63','#9c27b0','#00bcd4','#ffc107'];

    const qbertImg = new Image();
    qbertImg.src = 'images/qbert.svg';
    const enemyImg = new Image();
    enemyImg.src = 'images/qbert_enemy.svg';
    const platformImg = new Image();
    platformImg.src = 'images/qbert_platform.svg';

    let level = 1;
    let lives = 3;
    let tiles;
    let visited;
    const qbert = {row:0,col:0};
    const enemy = {row:ROWS-1,col:ROWS-1};
    const leftPlatform = {used:false};
    const rightPlatform = {used:false};
    let enemyTimer;
    let errorRate = 0.3;
    let falling = false;
    let fallPos = {x:0, y:0};
    let fallTimer;

    const infoEl = document.getElementById('info');
    const messageEl = document.getElementById('message');

    function tilePos(r,c){
      const x = START_X - (r*TILE)/2 + c*TILE;
      const y = START_Y + r*(TILE*0.75);
      return {x,y};
    }

    function platformPos(side){
      const base = tilePos(ROWS-2, side==='left'?0:ROWS-2);
      return {x: base.x + (side==='left'? -TILE : TILE), y: base.y};
    }

    function visitTile(r,c){
      if(tiles[r][c] < level){
        tiles[r][c]++;
        if(tiles[r][c] === level) visited++;
      }
    }

    function drawTile(r,c){
      const {x,y} = tilePos(r,c);
      ctx.beginPath();
      ctx.moveTo(x+TILE/2,y);
      ctx.lineTo(x+TILE,y+TILE/2);
      ctx.lineTo(x+TILE/2,y+TILE);
      ctx.lineTo(x,y+TILE/2);
      ctx.closePath();
      const idx = Math.min(tiles[r][c], level);
      ctx.fillStyle = COLORS[idx];
      ctx.fill();
      ctx.strokeStyle = '#555';
      ctx.stroke();
    }

    function drawPlatforms(){
      if(!leftPlatform.used){
        const p = platformPos('left');
        ctx.drawImage(platformImg,p.x,p.y,TILE,TILE*0.6);
      }
      if(!rightPlatform.used){
        const p = platformPos('right');
        ctx.drawImage(platformImg,p.x,p.y,TILE,TILE*0.6);
      }
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let r=ROWS-1;r>=0;r--){
        for(let c=0;c<=r;c++){
          drawTile(r,c);
        }
      }
      drawPlatforms();
      const q = tilePos(qbert.row,qbert.col);
      if(!falling){
        ctx.drawImage(qbertImg,q.x+TILE/2-16,q.y+TILE/2-16,32,32);
      } else {
        ctx.drawImage(qbertImg,fallPos.x,fallPos.y,32,32);
      }
      const e = tilePos(enemy.row,enemy.col);
      ctx.drawImage(enemyImg,e.x+TILE/2-16,e.y+TILE/2-16,32,32);
      infoEl.textContent = `Level: ${level} Lives: ${lives} - ${visited}/${ROWS*(ROWS+1)/2}`;
    }

    function checkWin(){
      if(visited === ROWS*(ROWS+1)/2){
        messageEl.textContent = `Level ${level} complete!`;
        level++;
        setTimeout(startLevel, 1000);
      }
    }

    function loseLife(){
      lives--;
      if(lives <= 0){
        messageEl.textContent = 'Game Over';
      } else {
        qbert.row=0; qbert.col=0;
        enemy.row=ROWS-1; enemy.col=ROWS-1;
      }
      draw();
    }

   function enemyMove(){
      if(falling) return;
      let bestR = enemy.row;
      let bestC = enemy.col;
      let bestDist = Infinity;
      const target = tilePos(qbert.row,qbert.col);
      let options = [
        [enemy.row+1, enemy.col],
        [enemy.row+1, enemy.col+1],
        [enemy.row-1, enemy.col],
        [enemy.row-1, enemy.col-1]
      ];
      options = options.filter(([nr,nc]) => nr>=0 && nr<ROWS && nc>=0 && nc<=nr);
      if(options.length === 0) return;
      if(Math.random() < errorRate){
        const [nr,nc] = options[Math.floor(Math.random()*options.length)];
        enemy.row = nr;
        enemy.col = nc;
        return;
      }
      for(const [nr,nc] of options){
        const pos = tilePos(nr,nc);
        const d = (pos.x-target.x)**2 + (pos.y-target.y)**2;
        if(d < bestDist){ bestDist=d; bestR=nr; bestC=nc; }
      }
      enemy.row = bestR;
      enemy.col = bestC;
    }

    function usePlatform(p){
      p.used = true;
      qbert.row = 0; qbert.col = 0;
    }

    function fallOff(dr,dc){
      falling = true;
      const target = tilePos(qbert.row + dr, qbert.col + dc);
      fallPos.x = target.x + TILE/2 - 16;
      fallPos.y = target.y + TILE/2 - 16;
      if(fallTimer) clearInterval(fallTimer);
      draw();
      fallTimer = setInterval(() => {
        fallPos.y += 8;
        draw();
        if(fallPos.y > canvas.height){
          clearInterval(fallTimer);
          falling = false;
          loseLife();
        }
      }, 30);
    }

    function move(dr,dc){
      if(lives <= 0 || falling) return;
      let nr = qbert.row + dr;
      let nc = qbert.col + dc;
      if(qbert.row === ROWS-2 && dr === 1){
        if(dc === 0 && qbert.col === 0 && !leftPlatform.used){
          usePlatform(leftPlatform);
          draw();
          return;
        }
        if(dc === 1 && qbert.col === ROWS-2 && !rightPlatform.used){
          usePlatform(rightPlatform);
          draw();
          return;
        }
      }
      if(nr<0 || nr>=ROWS || nc<0 || nc>nr){
        fallOff(dr,dc);
        return;
      }
      qbert.row = nr; qbert.col = nc;
      visitTile(nr,nc);
      draw();
      if(enemy.row === qbert.row && enemy.col === qbert.col){
        loseLife();
      }
      checkWin();
    }

    function startLevel(){
      tiles = [];
      for(let r=0;r<ROWS;r++){
        tiles[r]=[];
        for(let c=0;c<=r;c++) tiles[r][c]=0;
      }
      visited = 0;
      leftPlatform.used = false;
      rightPlatform.used = false;
      qbert.row = 0; qbert.col = 0;
      enemy.row = ROWS-1; enemy.col = ROWS-1;
      falling = false;
      if(fallTimer) clearInterval(fallTimer);
      visitTile(0,0);
      messageEl.textContent = '';
      const interval = Math.max(300, 1000 - (level-1)*100);
      errorRate = Math.max(0, 0.30 - 0.05*(level-1));
      if(enemyTimer) clearInterval(enemyTimer);
      enemyTimer = setInterval(() => {
        if(lives > 0){
          enemyMove();
          draw();
          if(!falling && enemy.row === qbert.row && enemy.col === qbert.col){
            loseLife();
          }
        }
      }, interval);
      draw();
    }

    document.addEventListener('keydown', e => {
      switch(e.key){
        case 'ArrowUp': move(-1,-1); break;
        case 'ArrowRight': move(-1,0); break;
        case 'ArrowLeft': move(1,0); break;
        case 'ArrowDown': move(1,1); break;
      }
    });

    startLevel();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if(placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
