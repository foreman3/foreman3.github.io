<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Qbert Clone</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      overflow: hidden;
      background: linear-gradient(135deg,#222 0%,#444 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul { list-style:none; padding:0; }
    #sidebar li { margin:15px 0; }
    #sidebar a { color:#fff; text-decoration:none; }
    #sidebar a:hover{ color:#ffea00; }
    #game-container {
      flex:1;
      display:flex;
      flex-direction:column;
      align-items:center;
      padding:20px;
    }
    canvas {
      background:#000;
      border:2px solid #fff;
      border-radius:8px;
    }
    #info { margin-top:10px; font-size:20px; }
    #message { margin-top:10px; font-size:24px; color:#ffeb3b; }
  </style>
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Qbert Clone</h1>
    <canvas id="gameCanvas" width="600" height="600"></canvas>
    <div id="info"></div>
    <div id="message"></div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ROWS = 7;
    const TILE = 50;
    const START_X = canvas.width/2;
    const START_Y = 60;
    const COLORS = ['#2196f3','#ff9800','#4caf50','#e91e63','#9c27b0','#00bcd4','#ffc107'];

    const qbertImg = new Image();
    qbertImg.src = 'images/qbert.svg';
    const enemyImg = new Image();
    enemyImg.src = 'images/qbert_enemy.svg';
    const platformImg = new Image();
    platformImg.src = 'images/qbert_platform.svg';

    let level = 1;
    let lives = 3;
    let tiles;
    let visited;
    const qbert = {row:0,col:0, moving:false};
    const enemy = {row:ROWS-1,col:ROWS-1, moving:false};
    const leftPlatform = {used:false};
    const rightPlatform = {used:false};
    let enemyTimer;
    let errorRate = 0.3;

    const infoEl = document.getElementById('info');
    const messageEl = document.getElementById('message');

    function tilePos(r,c){
      const x = START_X - (r*TILE)/2 + c*TILE;
      const y = START_Y + r*(TILE*0.75);
      return {x,y};
    }

    function platformPos(side){
      const base = tilePos(ROWS-2, side==='left'?0:ROWS-2);
      return {x: base.x + (side==='left'? -TILE : TILE), y: base.y};
    }

    function visitTile(r,c){
      if(tiles[r][c] < level){
        tiles[r][c]++;
        if(tiles[r][c] === level) visited++;
      }
    }

    function drawTile(r,c){
      const {x,y} = tilePos(r,c);
      ctx.beginPath();
      ctx.moveTo(x+TILE/2,y);
      ctx.lineTo(x+TILE,y+TILE/2);
      ctx.lineTo(x+TILE/2,y+TILE);
      ctx.lineTo(x,y+TILE/2);
      ctx.closePath();
      const idx = Math.min(tiles[r][c], level);
      ctx.fillStyle = COLORS[idx];
      ctx.fill();
      ctx.strokeStyle = '#555';
      ctx.stroke();
    }

    function drawPlatforms(){
      if(!leftPlatform.used || leftPlatform.flyX !== undefined){
        const p = leftPlatform.flyX !== undefined ? {x:leftPlatform.flyX,y:leftPlatform.flyY} : platformPos('left');
        ctx.drawImage(platformImg,p.x,p.y,TILE,TILE*0.6);
      }
      if(!rightPlatform.used || rightPlatform.flyX !== undefined){
        const p = rightPlatform.flyX !== undefined ? {x:rightPlatform.flyX,y:rightPlatform.flyY} : platformPos('right');
        ctx.drawImage(platformImg,p.x,p.y,TILE,TILE*0.6);
      }
    }

    function animateJump(entity, sr, sc, er, ec, cb){
      entity.moving = true;
      const start = tilePos(sr,sc);
      const end = tilePos(er,ec);
      const startTime = performance.now();
      const duration = 200;
      function step(t){
        const p = Math.min((t-startTime)/duration,1);
        const h = Math.sin(p*Math.PI)*20;
        entity.drawX = start.x + (end.x-start.x)*p;
        entity.drawY = start.y + (end.y-start.y)*p - h;
        draw();
        if(p<1){
          requestAnimationFrame(step);
        }else{
          entity.drawX = undefined;
          entity.drawY = undefined;
          entity.moving = false;
          cb && cb();
        }
      }
      requestAnimationFrame(step);
    }

    function animatePlatform(p, side, cb){
      const start = platformPos(side);
      const end = tilePos(0,0);
      const startTime = performance.now();
      const duration = 600;
      qbert.moving = true;
      function step(t){
        const prog = Math.min((t-startTime)/duration,1);
        p.flyX = start.x + (end.x-start.x)*prog;
        p.flyY = start.y + (end.y-start.y)*prog;
        qbert.drawX = p.flyX;
        qbert.drawY = p.flyY - 10;
        draw();
        if(prog<1){
          requestAnimationFrame(step);
        } else {
          p.flyX = undefined; p.flyY = undefined; p.used = true;
          qbert.drawX = undefined; qbert.drawY = undefined;
          qbert.moving = false;
          cb && cb();
        }
      }
      requestAnimationFrame(step);
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      for(let r=ROWS-1;r>=0;r--){
        for(let c=0;c<=r;c++){
          drawTile(r,c);
        }
      }
      drawPlatforms();
      const qpos = (qbert.drawX !== undefined) ? {x:qbert.drawX,y:qbert.drawY} : tilePos(qbert.row,qbert.col);
      ctx.drawImage(qbertImg,qpos.x+TILE/2-16,qpos.y+TILE/2-16,32,32);
      const epos = (enemy.drawX !== undefined) ? {x:enemy.drawX,y:enemy.drawY} : tilePos(enemy.row,enemy.col);
      ctx.drawImage(enemyImg,epos.x+TILE/2-16,epos.y+TILE/2-16,32,32);
      infoEl.textContent = `Level: ${level} Lives: ${lives} - ${visited}/${ROWS*(ROWS+1)/2}`;
    }

    function checkWin(){
      if(visited === ROWS*(ROWS+1)/2){
        messageEl.textContent = `Level ${level} complete!`;
        level++;
        setTimeout(startLevel, 1000);
      }
    }

    function loseLife(){
      lives--;
      if(lives <= 0){
        messageEl.textContent = 'Game Over';
      } else {
        qbert.row=0; qbert.col=0; qbert.moving=false; qbert.drawX=undefined; qbert.drawY=undefined;
        enemy.row=ROWS-1; enemy.col=ROWS-1; enemy.moving=false; enemy.drawX=undefined; enemy.drawY=undefined;
      }
      draw();
    }

    function enemyMove(){
      if(enemy.moving) return;
      let bestR = enemy.row;
      let bestC = enemy.col;
      let bestDist = Infinity;
      const target = tilePos(qbert.row,qbert.col);
      let options = [
        [enemy.row+1, enemy.col],
        [enemy.row+1, enemy.col+1],
        [enemy.row-1, enemy.col],
        [enemy.row-1, enemy.col-1]
      ];
      options = options.filter(([nr,nc]) => nr>=0 && nr<ROWS && nc>=0 && nc<=nr);
      if(options.length === 0) return;
      if(Math.random() < errorRate){
        const [nr,nc] = options[Math.floor(Math.random()*options.length)];
        const sr = enemy.row, sc = enemy.col;
        enemy.row = nr; enemy.col = nc;
        animateJump(enemy, sr, sc, nr, nc, () => {
          if(enemy.row === qbert.row && enemy.col === qbert.col && !qbert.moving){
            loseLife();
          }
        });
        return;
      }
      for(const [nr,nc] of options){
        const pos = tilePos(nr,nc);
        const d = (pos.x-target.x)**2 + (pos.y-target.y)**2;
        if(d < bestDist){ bestDist=d; bestR=nr; bestC=nc; }
      }
      const sr = enemy.row, sc = enemy.col;
      enemy.row = bestR;
      enemy.col = bestC;
      animateJump(enemy, sr, sc, bestR, bestC, () => {
        if(enemy.row === qbert.row && enemy.col === qbert.col && !qbert.moving){
          loseLife();
        }
      });
    }

    function usePlatform(p, side){
      if(qbert.moving) return;
      animatePlatform(p, side, () => {
        qbert.row = 0; qbert.col = 0;
        visitTile(0,0);
        checkWin();
      });
    }

    function move(dr,dc){
      if(lives <= 0 || qbert.moving) return;
      let nr = qbert.row + dr;
      let nc = qbert.col + dc;
      if(qbert.row === ROWS-2 && dr === 1){
        if(dc === 0 && qbert.col === 0 && !leftPlatform.used){
          usePlatform(leftPlatform,'left');
          return;
        }
        if(dc === 1 && qbert.col === ROWS-2 && !rightPlatform.used){
          usePlatform(rightPlatform,'right');
          return;
        }
      }
      if(nr<0 || nr>=ROWS || nc<0 || nc>nr){
        loseLife();
        return;
      }
      const sr = qbert.row, sc = qbert.col;
      qbert.row = nr; qbert.col = nc;
      visitTile(nr,nc);
      animateJump(qbert, sr, sc, nr, nc, () => {
        if(enemy.row === qbert.row && enemy.col === qbert.col){
          loseLife();
        }
        checkWin();
      });
    }

    function startLevel(){
      tiles = [];
      for(let r=0;r<ROWS;r++){
        tiles[r]=[];
        for(let c=0;c<=r;c++) tiles[r][c]=0;
      }
      visited = 0;
      leftPlatform.used = false; leftPlatform.flyX = undefined; leftPlatform.flyY = undefined;
      rightPlatform.used = false; rightPlatform.flyX = undefined; rightPlatform.flyY = undefined;
      qbert.row = 0; qbert.col = 0; qbert.moving = false; qbert.drawX = undefined; qbert.drawY = undefined;
      enemy.row = ROWS-1; enemy.col = ROWS-1; enemy.moving = false; enemy.drawX = undefined; enemy.drawY = undefined;
      visitTile(0,0);
      messageEl.textContent = '';
      const interval = Math.max(300, 1000 - (level-1)*100);
      errorRate = Math.max(0, 0.30 - 0.05*(level-1));
      if(enemyTimer) clearInterval(enemyTimer);
      enemyTimer = setInterval(() => {
        if(lives > 0){
          enemyMove();
        }
      }, interval);
      draw();
    }

    document.addEventListener('keydown', e => {
      switch(e.key){
        case 'ArrowUp': move(-1,-1); break;
        case 'ArrowRight': move(-1,0); break;
        case 'ArrowLeft': move(1,0); break;
        case 'ArrowDown': move(1,1); break;
      }
    });

    startLevel();
  </script>
  <script>
    fetch('sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if(placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>
