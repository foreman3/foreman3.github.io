<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Excitebike</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: radial-gradient(circle at top, #2f3a4c 0%, #151515 55%, #0d0d0d 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #f4f4f4;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul { list-style: none; padding: 0; margin: 0; }
    #sidebar li { margin: 15px 0; }
    #sidebar a { color: #fff; text-decoration: none; transition: color 0.3s; }
    #sidebar a:hover { color: #ffea00; }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
    }
    canvas {
      background: #1b1b1b;
      border: 2px solid #f0f0f0;
      margin-top: 20px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.45);
    }
    #message {
      margin-top: 10px;
      font-size: 24px;
      color: #ffeb3b;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
    html,
    body {
      height: 100%;
    }
    body {
      justify-content: center;
      overflow: hidden;
    }
    #sidebar-placeholder {
      display: none;
    }
    #game-container {
      position: relative;
      width: min(1200px, 100%);
      max-width: calc(100vw - 32px);
      height: 100vh;
      padding: 24px;
      gap: 0;
    }
    h1 {
      display: none;
    }
    canvas {
      width: 100%;
      height: 100%;
      max-height: calc(100vh - 32px);
      margin-top: 0;
      border-radius: 18px;
    }
    #message {
      position: absolute;
      bottom: 18px;
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
      font-size: 20px;
      background: rgba(0, 0, 0, 0.45);
      padding: 10px 18px;
      border-radius: 999px;
      min-height: 28px;
      z-index: 3;
    }
    #touch-controls {
      position: absolute;
      inset: 0;
      display: none;
      align-items: flex-end;
      justify-content: space-between;
      padding: 0 22px 20px;
      pointer-events: none;
      z-index: 3;
    }
    .control-cluster {
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: none;
    }
    .control-row {
      display: flex;
      gap: 12px;
      pointer-events: none;
    }
    .control-button {
      width: clamp(58px, 16vw, 86px);
      height: clamp(58px, 16vw, 86px);
      border-radius: 999px;
      border: 2px solid rgba(255, 235, 59, 0.5);
      background: rgba(10, 10, 10, 0.55);
      color: rgba(255, 255, 255, 0.9);
      font-size: clamp(1.2rem, 4.5vw, 1.8rem);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      touch-action: none;
      backdrop-filter: blur(6px);
      transition: background 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .control-button.pressed,
    .control-button:active {
      background: rgba(255, 235, 59, 0.25);
      border-color: rgba(255, 244, 140, 0.9);
      box-shadow: 0 0 24px rgba(255, 235, 59, 0.35);
    }
    body.touch-device #touch-controls {
      display: flex;
    }
    #help-button {
      position: fixed;
      top: 16px;
      right: 16px;
      width: 36px;
      height: 36px;
      border-radius: 999px;
      border: 1px solid rgba(255, 235, 59, 0.55);
      background: rgba(10, 10, 10, 0.45);
      color: rgba(255, 255, 255, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      z-index: 1001;
      backdrop-filter: blur(6px);
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    #help-button:hover,
    #help-button:focus-visible {
      border-color: rgba(255, 244, 140, 0.9);
      background: rgba(255, 235, 59, 0.25);
    }
    #instruction-modal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 23, 0.78);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
      padding: 24px;
      text-align: left;
    }
    #instruction-modal.is-visible {
      opacity: 1;
      pointer-events: auto;
    }
    #instruction-card {
      max-width: 540px;
      width: 100%;
      background: rgba(8, 12, 20, 0.95);
      border: 1px solid rgba(255, 235, 59, 0.35);
      border-radius: 18px;
      padding: 20px 22px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
    }
    #instruction-card h2 {
      margin: 0 0 12px;
      font-size: 1.1rem;
      letter-spacing: 2px;
      text-transform: uppercase;
      color: #ffe884;
    }
    #instruction-card p {
      margin: 8px 0;
      color: #fff6c7;
      line-height: 1.5;
    }
    #instruction-close {
      margin-top: 14px;
      width: 100%;
      padding: 10px 12px;
      border-radius: 999px;
      border: none;
      background: rgba(255, 235, 59, 0.9);
      color: #2a2000;
      font-weight: 700;
      letter-spacing: 1px;
      cursor: pointer;
    }
    @media (pointer: fine) {
      #help-button {
        display: flex;
      }
    }
  </style>
  <link rel="stylesheet" href="../sidebar.css" />
  <link rel="stylesheet" href="../flyout.css" />
  <script src="../flyout.js" defer></script>
</head>
<body>
  <div id="flyout-nav" class="flyout-nav" aria-hidden="true">
    <button class="flyout-toggle" type="button" aria-label="Arcade menu">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div id="flyout-panel" class="flyout-panel"></div>
  </div>
  <button id="help-button" type="button" aria-label="How to play">?</button>
  <div id="instruction-modal" class="is-visible" role="dialog" aria-modal="true">
    <div id="instruction-card">
      <h2>How to Play</h2>
      <p>Arrow Up/Down to change speed. Space to jump.</p>
      <p>Time jumps, absorb landings, and keep your momentum.</p>
      <button id="instruction-close" type="button">Start</button>
    </div>
  </div>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Excitebike</h1>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="touch-controls" aria-hidden="true">
      <div class="control-cluster">
        <button type="button" class="control-button" data-key="ArrowUp" data-code="ArrowUp" aria-label="Throttle Up">Up</button>
        <button type="button" class="control-button" data-key="ArrowDown" data-code="ArrowDown" aria-label="Throttle Down">Down</button>
      </div>
      <div class="control-cluster">
        <button type="button" class="control-button" data-key=" " data-code="Space" aria-label="Jump">Jump</button>
      </div>
    </div>
    <div id="message"></div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const groundY = canvas.height - 60;

    const player = {
      x: 120,
      y: groundY - 28,
      w: 48,
      h: 24,
      vy: 0,
      jumping: false,
      angle: 0,
      suspension: 0
    };
    const keys = {};
    let speed = 4;
    let targetSpeed = 4;
    let distance = 0;
    let gameOver = false;
    const obstacles = [];
    const dust = [];
    const scenery = [];
    let trackOffset = 0;
    let airtime = 0;
    let hardLandingTimer = 0;
    let gamePaused = true;
    let gameStarted = false;

    const gravity = 0.6;
    const maxSpeed = 11;

    function initScenery() {
      scenery.length = 0;
      for (let i = 0; i < 12; i++) {
        scenery.push({
          x: i * 160 + Math.random() * 40,
          baseY: groundY - 140 - Math.random() * 40,
          scale: 0.6 + Math.random() * 0.4,
          type: Math.random() < 0.5 ? 'tree' : 'crowd'
        });
      }
    }

    function createObstacle() {
      const roll = Math.random();
      let type = 'block';
      if (roll < 0.4) type = 'ramp';
      else if (roll < 0.7) type = 'log';
      else if (roll < 0.85) type = 'whoops';
      else type = 'ditch';

      const height = 24 + Math.random() * 32;
      let width = 36 + Math.random() * 40;
      if (type === 'whoops') width = 90;
      if (type === 'ditch') width = 60 + Math.random() * 40;

      const obstacle = {
        x: canvas.width + Math.random() * 240,
        y: groundY - height,
        w: width,
        h: height,
        type
      };

      obstacles.push(obstacle);
    }

    function update() {
      if (gamePaused || gameOver) return;

      if (obstacles.length < 6 && Math.random() < 0.03) createObstacle();
      obstacles.forEach(o => { o.x -= speed; });
      if (obstacles.length && obstacles[0].x + obstacles[0].w < 0) obstacles.shift();
      trackOffset = (trackOffset - speed) % 50;

      if (keys['ArrowUp']) targetSpeed = Math.min(targetSpeed + 0.12, maxSpeed);
      if (keys['ArrowDown']) targetSpeed = Math.max(targetSpeed - 0.18, 2.8);

      speed += (targetSpeed - speed) * 0.05;

      if (!player.jumping) {
        player.suspension += (0 - player.suspension) * 0.2;
      }

      if (player.jumping) {
        player.vy += gravity;
        player.y += player.vy;
        player.angle += player.vy * 0.018;
        airtime += 1;
        if (player.y >= groundY - player.h) {
          player.y = groundY - player.h;
          player.vy = 0;
          player.jumping = false;
          player.angle *= 0.4;
          player.suspension = Math.min(12, airtime * 0.3);
          hardLandingTimer = airtime > 30 ? 30 : 0;
          airtime = 0;
        }
      } else {
        player.angle += (0 - player.angle) * 0.1;
        airtime = 0;
        if (speed > 4.5 && Math.random() < 0.45) {
          dust.push({
            x: player.x - 6,
            y: groundY - 6,
            vx: -speed * (0.8 + Math.random() * 0.4),
            vy: -Math.random() * 1.2,
            life: 40 + Math.random() * 25
          });
        }
      }

      if (hardLandingTimer > 0) {
        hardLandingTimer--;
        targetSpeed = Math.max(targetSpeed - 0.25, 3);
      }

      obstacles.forEach(o => {
        const intersect = player.x < o.x + o.w && player.x + player.w > o.x &&
                          player.y < o.y + o.h && player.y + player.h > o.y;
        if (o.type === 'ramp') {
          if (!player.jumping && intersect) {
            player.vy = -13;
            player.jumping = true;
            player.angle = -0.25;
          }
        } else if (o.type === 'whoops') {
          if (!player.jumping && intersect) {
            player.vy = -6;
            player.jumping = true;
            player.angle = -0.12;
          }
        } else if (o.type === 'ditch') {
          if (player.x + player.w > o.x && player.x < o.x + o.w && player.y + player.h >= groundY) {
            gameOver = true;
          }
        } else if (intersect) {
          gameOver = true;
        }
      });

      distance += speed;

      dust.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life -= 1;
      });
      while (dust.length > 120) dust.shift();
      for (let i = dust.length - 1; i >= 0; i--) {
        if (dust[i].life <= 0 || dust[i].y > groundY) dust.splice(i, 1);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSky();
      drawScenery();
      drawTrack();
      drawBike();
      obstacles.forEach(o => {
        if (o.type === 'ramp') {
          ctx.fillStyle = '#b4a48a';
          ctx.beginPath();
          ctx.moveTo(o.x, o.y + o.h);
          ctx.lineTo(o.x + o.w, o.y + o.h);
          ctx.lineTo(o.x + o.w, o.y);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = 'rgba(58,46,35,0.8)';
          ctx.lineWidth = 2;
          ctx.stroke();
        } else if (o.type === 'log') {
          ctx.fillStyle = '#4b3621';
          ctx.fillRect(o.x, o.y + o.h - 16, o.w, 16);
          ctx.strokeStyle = '#2a1d11';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x, o.y + o.h - 16, o.w, 16);
          for (let i = 0; i < o.w; i += 18) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.moveTo(o.x + i, o.y + o.h - 16);
            ctx.lineTo(o.x + i + 10, o.y + o.h);
            ctx.stroke();
          }
        } else if (o.type === 'whoops') {
          ctx.fillStyle = '#9b8369';
          const segments = 4;
          const segWidth = o.w / segments;
          for (let i = 0; i < segments; i++) {
            ctx.beginPath();
            ctx.moveTo(o.x + i * segWidth, groundY);
            ctx.quadraticCurveTo(
              o.x + i * segWidth + segWidth / 2,
              groundY - (i % 2 === 0 ? 18 : 12),
              o.x + (i + 1) * segWidth,
              groundY
            );
            ctx.fill();
          }
        } else if (o.type === 'ditch') {
          ctx.fillStyle = '#20170f';
          ctx.fillRect(o.x, groundY, o.w, 40);
          ctx.strokeStyle = '#3b2a1a';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x, groundY - 2, o.w, 44);
        } else {
          ctx.fillStyle = '#3f3f3f';
          ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.strokeStyle = '#0f0f0f';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x, o.y, o.w, o.h);
        }
      });
      drawDust();
      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText(`Speed: ${speed.toFixed(1)}  Dist: ${Math.floor(distance)}m`, 14, 28);
      if (airtime > 0) {
        ctx.font = '16px sans-serif';
        ctx.fillText(`Air: ${(airtime / 60).toFixed(1)}s`, 14, 48);
      }
      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f5f5f5';
        ctx.font = '36px sans-serif';
        ctx.fillText('Bike down!', canvas.width / 2 - 110, canvas.height / 2 - 10);
        ctx.font = '20px sans-serif';
        ctx.fillText(`Distance ridden: ${Math.floor(distance)}m`, canvas.width / 2 - 120, canvas.height / 2 + 20);
        ctx.fillText('Press Enter to tape it back together.', canvas.width / 2 - 160, canvas.height / 2 + 50);
      }
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => {
      if (gamePaused) return;
      keys[e.key] = true;
      if (e.key === ' ' && !player.jumping && !gameOver) {
        player.vy = -11;
        player.jumping = true;
        player.angle = -0.18;
      }
      if (e.key === 'Enter' && gameOver) {
        obstacles.length = 0;
        dust.length = 0;
        initScenery();
        speed = 4;
        targetSpeed = 4;
        distance = 0;
        airtime = 0;
        player.y = groundY - player.h;
        player.vy = 0;
        player.jumping = false;
        player.angle = 0;
        player.suspension = 0;
        gameOver = false;
        document.getElementById('message').textContent = '';
      }
    });

    window.addEventListener('keyup', e => { keys[e.key] = false; });

    const baseWidth = canvas.width;
    const baseHeight = canvas.height;
    function resizeCanvas() {
      const padding = 32;
      const maxWidth = Math.max(320, window.innerWidth - padding * 2);
      const maxHeight = Math.max(240, window.innerHeight - padding * 2);
      const scale = Math.min(maxWidth / baseWidth, maxHeight / baseHeight);
      canvas.style.width = `${Math.floor(baseWidth * scale)}px`;
      canvas.style.height = `${Math.floor(baseHeight * scale)}px`;
    }

    const instructionModal = document.getElementById('instruction-modal');
    const instructionClose = document.getElementById('instruction-close');
    const helpButton = document.getElementById('help-button');
    const instructionKey = 'vibecade-instructions-excitebike';
    const hasSeenInstructions = sessionStorage.getItem(instructionKey) === '1';
    const controlButtons = document.querySelectorAll('.control-button');
    const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;
    if (isTouchDevice) {
      document.body.classList.add('touch-device');
    }

    function startGame() {
      if (gameStarted) return;
      gameStarted = true;
      gamePaused = false;
      resizeCanvas();
      document.getElementById('message').textContent = '';
    }

    function showInstructions() {
      gamePaused = true;
      if (instructionModal) instructionModal.classList.add('is-visible');
    }

    function hideInstructions() {
      if (instructionModal) instructionModal.classList.remove('is-visible');
      if (!gameStarted) {
        startGame();
      } else {
        gamePaused = false;
      }
      sessionStorage.setItem(instructionKey, '1');
    }

    if (instructionClose) {
      instructionClose.addEventListener('click', hideInstructions);
    }
    if (instructionModal) {
      instructionModal.addEventListener('click', (event) => {
        if (event.target === instructionModal) {
          hideInstructions();
        }
      });
    }
    if (helpButton) {
      helpButton.addEventListener('click', showInstructions);
    }

    function dispatchKeyEvent(key, code, type) {
      const event = new KeyboardEvent(type, { key, code, bubbles: true });
      window.dispatchEvent(event);
    }

    if (controlButtons.length && isTouchDevice) {
      controlButtons.forEach((button) => {
        const key = button.dataset.key;
        const code = button.dataset.code || button.dataset.key;
        const press = () => {
          if (gamePaused) return;
          button.classList.add('pressed');
          dispatchKeyEvent(key, code, 'keydown');
        };
        const release = () => {
          button.classList.remove('pressed');
          dispatchKeyEvent(key, code, 'keyup');
        };
        button.addEventListener('touchstart', (event) => {
          event.preventDefault();
          press();
        }, { passive: false });
        button.addEventListener('touchend', (event) => {
          event.preventDefault();
          release();
        }, { passive: false });
        button.addEventListener('touchcancel', release);
        button.addEventListener('mousedown', press);
        button.addEventListener('mouseup', release);
        button.addEventListener('mouseleave', release);
      });
    }

    window.addEventListener('resize', () => {
      window.requestAnimationFrame(resizeCanvas);
    });

    if (hasSeenInstructions) {
      if (instructionModal) instructionModal.classList.remove('is-visible');
      startGame();
    }

    function drawBike() {
      const { x, y, w, h, angle, suspension } = player;
      ctx.save();
      ctx.translate(x + w / 2, y + h / 2 + suspension);
      ctx.rotate(angle);

      // Wheels
      ctx.fillStyle = '#0d0d0d';
      [-(w / 2 - 8), (w / 2 - 8)].forEach(offsetX => {
        ctx.beginPath();
        ctx.arc(offsetX, h / 2, h / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = '#c5c5c5';
        ctx.lineWidth = 2;
        ctx.arc(offsetX, h / 2, h / 2 - 4, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Frame
      ctx.strokeStyle = '#c63f2b';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-w / 2 + 6, h / 2 - 4);
      ctx.lineTo(4, -h / 2 + 2);
      ctx.lineTo(w / 2 - 4, h / 2 - 6);
      ctx.stroke();

      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-w / 2 + 6, h / 2 - 4);
      ctx.lineTo(-w / 2 + 12, -h / 2 + 4);
      ctx.lineTo(w / 2 - 6, -h / 2 + 10);
      ctx.stroke();

      // Engine block
      ctx.fillStyle = '#5f5f5f';
      ctx.fillRect(-6, -h / 2 + 2, 18, 16);
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(-2, -h / 2 + 4, 10, 12);

      // Seat and tank
      ctx.fillStyle = '#2e2e2e';
      ctx.beginPath();
      ctx.moveTo(-w / 2 + 10, -h / 2 + 2);
      ctx.lineTo(2, -h / 2 - 4);
      ctx.lineTo(w / 2 - 12, -h / 2 + 2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#c63f2b';
      ctx.fillRect(-8, -h / 2 - 2, 18, 6);

      // Rider
      ctx.fillStyle = '#202020';
      ctx.fillRect(-6, -h / 2 - 18, 14, 18); // torso
      ctx.fillStyle = '#424242';
      ctx.fillRect(-8, -h / 2 - 4, 18, 6); // lap
      ctx.fillStyle = '#2f2f2f';
      ctx.fillRect(-10, -h / 2 - 28, 18, 12); // shoulders
      ctx.fillStyle = '#d3d3d3';
      ctx.beginPath();
      ctx.arc(0, -h / 2 - 30, 8, 0, Math.PI * 2); // helmet
      ctx.fill();
      ctx.fillStyle = '#1b1b1b';
      ctx.fillRect(-4, -h / 2 - 32, 8, 6); // visor

      // Handlebars
      ctx.strokeStyle = '#d0d0d0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w / 2 - 14, -h / 2 + 4);
      ctx.lineTo(w / 2 + 12, -h / 2 - 6);
      ctx.stroke();
      ctx.fillStyle = '#252525';
      ctx.fillRect(w / 2 + 8, -h / 2 - 8, 6, 12);

      ctx.restore();
    }

    function drawDust() {
      ctx.fillStyle = 'rgba(110, 92, 70, 0.4)';
      dust.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(1, p.life / 20), 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawSky() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#313f55');
      gradient.addColorStop(0.5, '#55637a');
      gradient.addColorStop(1, '#7f6d4d');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawScenery() {
      scenery.forEach(s => {
        s.x -= speed * 0.3 * s.scale;
        if (s.x < -100) s.x = canvas.width + Math.random() * 200;
        ctx.save();
        ctx.translate(s.x, s.baseY + Math.sin((distance + s.x) * 0.002) * 2);
        ctx.scale(s.scale, s.scale);
        if (s.type === 'tree') {
          ctx.fillStyle = '#1d2216';
          ctx.fillRect(-6, 10, 12, 40);
          ctx.fillStyle = '#2f4220';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(26, 40);
          ctx.lineTo(-26, 40);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = '#101010';
          ctx.fillRect(-20, 10, 40, 18);
          ctx.fillStyle = '#2f2f2f';
          ctx.fillRect(-16, 2, 32, 12);
          ctx.fillStyle = '#d9d9d9';
          for (let i = -12; i <= 12; i += 6) {
            ctx.fillRect(i, 0, 3, 8);
          }
        }
        ctx.restore();
      });
    }

    function drawTrack() {
      const gradient = ctx.createLinearGradient(0, groundY - 60, 0, canvas.height);
      gradient.addColorStop(0, '#5c4a34');
      gradient.addColorStop(0.35, '#4a3825');
      gradient.addColorStop(1, '#2b1f14');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, groundY - 20, canvas.width, canvas.height - (groundY - 20));
      ctx.fillStyle = '#2b241a';
      ctx.fillRect(0, groundY + 30, canvas.width, 60);

      ctx.strokeStyle = 'rgba(24,17,12,0.55)';
      ctx.lineWidth = 4;
      for (let x = trackOffset; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, groundY + 6);
        ctx.lineTo(x + 24, groundY + 6);
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(73,56,38,0.6)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(0, groundY + i * 10);
        ctx.lineTo(canvas.width, groundY + i * 10 + Math.sin((distance * 0.01) + i) * 2);
        ctx.stroke();
      }
    }

    initScenery();
    loop();
  </script>
</body>
</html>

