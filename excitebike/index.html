<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Excitebike</title>
  <style>
    body {
      margin: 0;
      display: flex;
      min-height: 100vh;
      background: radial-gradient(circle at top, #2f3a4c 0%, #151515 55%, #0d0d0d 100%);
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      color: #f4f4f4;
    }
    #sidebar {
      width: 220px;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      box-shadow: 2px 0 8px rgba(0,0,0,0.2);
    }
    #sidebar ul { list-style: none; padding: 0; margin: 0; }
    #sidebar li { margin: 15px 0; }
    #sidebar a { color: #fff; text-decoration: none; transition: color 0.3s; }
    #sidebar a:hover { color: #ffea00; }
    #game-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 20px;
    }
    canvas {
      background: #1b1b1b;
      border: 2px solid #f0f0f0;
      margin-top: 20px;
      box-shadow: 0 8px 25px rgba(0,0,0,0.45);
    }
    #message {
      margin-top: 10px;
      font-size: 24px;
      color: #ffeb3b;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
    }
  </style>
  <link rel="stylesheet" href="../sidebar.css" />
</head>
<body>
  <div id="sidebar-placeholder"></div>
  <div id="game-container">
    <h1>Excitebike</h1>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="message">Arrow Up/Down to change speed, Space to jump. Time jumps, absorb landings, and stay on the throttle.</div>
  </div>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const groundY = canvas.height - 60;

    const player = {
      x: 120,
      y: groundY - 28,
      w: 48,
      h: 24,
      vy: 0,
      jumping: false,
      angle: 0,
      suspension: 0
    };
    const keys = {};
    let speed = 4;
    let targetSpeed = 4;
    let distance = 0;
    let gameOver = false;
    const obstacles = [];
    const dust = [];
    const scenery = [];
    let trackOffset = 0;
    let airtime = 0;
    let hardLandingTimer = 0;

    const gravity = 0.6;
    const maxSpeed = 11;

    function initScenery() {
      scenery.length = 0;
      for (let i = 0; i < 12; i++) {
        scenery.push({
          x: i * 160 + Math.random() * 40,
          baseY: groundY - 140 - Math.random() * 40,
          scale: 0.6 + Math.random() * 0.4,
          type: Math.random() < 0.5 ? 'tree' : 'crowd'
        });
      }
    }

    function createObstacle() {
      const roll = Math.random();
      let type = 'block';
      if (roll < 0.4) type = 'ramp';
      else if (roll < 0.7) type = 'log';
      else if (roll < 0.85) type = 'whoops';
      else type = 'ditch';

      const height = 24 + Math.random() * 32;
      let width = 36 + Math.random() * 40;
      if (type === 'whoops') width = 90;
      if (type === 'ditch') width = 60 + Math.random() * 40;

      const obstacle = {
        x: canvas.width + Math.random() * 240,
        y: groundY - height,
        w: width,
        h: height,
        type
      };

      obstacles.push(obstacle);
    }

    function update() {
      if (gameOver) return;

      if (obstacles.length < 6 && Math.random() < 0.03) createObstacle();
      obstacles.forEach(o => { o.x -= speed; });
      if (obstacles.length && obstacles[0].x + obstacles[0].w < 0) obstacles.shift();
      trackOffset = (trackOffset - speed) % 50;

      if (keys['ArrowUp']) targetSpeed = Math.min(targetSpeed + 0.12, maxSpeed);
      if (keys['ArrowDown']) targetSpeed = Math.max(targetSpeed - 0.18, 2.8);

      speed += (targetSpeed - speed) * 0.05;

      if (!player.jumping) {
        player.suspension += (0 - player.suspension) * 0.2;
      }

      if (player.jumping) {
        player.vy += gravity;
        player.y += player.vy;
        player.angle += player.vy * 0.018;
        airtime += 1;
        if (player.y >= groundY - player.h) {
          player.y = groundY - player.h;
          player.vy = 0;
          player.jumping = false;
          player.angle *= 0.4;
          player.suspension = Math.min(12, airtime * 0.3);
          hardLandingTimer = airtime > 30 ? 30 : 0;
          airtime = 0;
        }
      } else {
        player.angle += (0 - player.angle) * 0.1;
        airtime = 0;
        if (speed > 4.5 && Math.random() < 0.45) {
          dust.push({
            x: player.x - 6,
            y: groundY - 6,
            vx: -speed * (0.8 + Math.random() * 0.4),
            vy: -Math.random() * 1.2,
            life: 40 + Math.random() * 25
          });
        }
      }

      if (hardLandingTimer > 0) {
        hardLandingTimer--;
        targetSpeed = Math.max(targetSpeed - 0.25, 3);
      }

      obstacles.forEach(o => {
        const intersect = player.x < o.x + o.w && player.x + player.w > o.x &&
                          player.y < o.y + o.h && player.y + player.h > o.y;
        if (o.type === 'ramp') {
          if (!player.jumping && intersect) {
            player.vy = -13;
            player.jumping = true;
            player.angle = -0.25;
          }
        } else if (o.type === 'whoops') {
          if (!player.jumping && intersect) {
            player.vy = -6;
            player.jumping = true;
            player.angle = -0.12;
          }
        } else if (o.type === 'ditch') {
          if (player.x + player.w > o.x && player.x < o.x + o.w && player.y + player.h >= groundY) {
            gameOver = true;
          }
        } else if (intersect) {
          gameOver = true;
        }
      });

      distance += speed;

      dust.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.05;
        p.life -= 1;
      });
      while (dust.length > 120) dust.shift();
      for (let i = dust.length - 1; i >= 0; i--) {
        if (dust[i].life <= 0 || dust[i].y > groundY) dust.splice(i, 1);
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawSky();
      drawScenery();
      drawTrack();
      drawBike();
      obstacles.forEach(o => {
        if (o.type === 'ramp') {
          ctx.fillStyle = '#b4a48a';
          ctx.beginPath();
          ctx.moveTo(o.x, o.y + o.h);
          ctx.lineTo(o.x + o.w, o.y + o.h);
          ctx.lineTo(o.x + o.w, o.y);
          ctx.closePath();
          ctx.fill();
          ctx.strokeStyle = 'rgba(58,46,35,0.8)';
          ctx.lineWidth = 2;
          ctx.stroke();
        } else if (o.type === 'log') {
          ctx.fillStyle = '#4b3621';
          ctx.fillRect(o.x, o.y + o.h - 16, o.w, 16);
          ctx.strokeStyle = '#2a1d11';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x, o.y + o.h - 16, o.w, 16);
          for (let i = 0; i < o.w; i += 18) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0,0,0,0.35)';
            ctx.moveTo(o.x + i, o.y + o.h - 16);
            ctx.lineTo(o.x + i + 10, o.y + o.h);
            ctx.stroke();
          }
        } else if (o.type === 'whoops') {
          ctx.fillStyle = '#9b8369';
          const segments = 4;
          const segWidth = o.w / segments;
          for (let i = 0; i < segments; i++) {
            ctx.beginPath();
            ctx.moveTo(o.x + i * segWidth, groundY);
            ctx.quadraticCurveTo(
              o.x + i * segWidth + segWidth / 2,
              groundY - (i % 2 === 0 ? 18 : 12),
              o.x + (i + 1) * segWidth,
              groundY
            );
            ctx.fill();
          }
        } else if (o.type === 'ditch') {
          ctx.fillStyle = '#20170f';
          ctx.fillRect(o.x, groundY, o.w, 40);
          ctx.strokeStyle = '#3b2a1a';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x, groundY - 2, o.w, 44);
        } else {
          ctx.fillStyle = '#3f3f3f';
          ctx.fillRect(o.x, o.y, o.w, o.h);
          ctx.strokeStyle = '#0f0f0f';
          ctx.lineWidth = 2;
          ctx.strokeRect(o.x, o.y, o.w, o.h);
        }
      });
      drawDust();
      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText(`Speed: ${speed.toFixed(1)}  Dist: ${Math.floor(distance)}m`, 14, 28);
      if (airtime > 0) {
        ctx.font = '16px sans-serif';
        ctx.fillText(`Air: ${(airtime / 60).toFixed(1)}s`, 14, 48);
      }
      if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.65)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#f5f5f5';
        ctx.font = '36px sans-serif';
        ctx.fillText('Bike down!', canvas.width / 2 - 110, canvas.height / 2 - 10);
        ctx.font = '20px sans-serif';
        ctx.fillText(`Distance ridden: ${Math.floor(distance)}m`, canvas.width / 2 - 120, canvas.height / 2 + 20);
        ctx.fillText('Press Enter to tape it back together.', canvas.width / 2 - 160, canvas.height / 2 + 50);
      }
    }

    function loop() {
      update();
      draw();
      requestAnimationFrame(loop);
    }

    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ' && !player.jumping && !gameOver) {
        player.vy = -11;
        player.jumping = true;
        player.angle = -0.18;
      }
      if (e.key === 'Enter' && gameOver) {
        obstacles.length = 0;
        dust.length = 0;
        initScenery();
        speed = 4;
        targetSpeed = 4;
        distance = 0;
        airtime = 0;
        player.y = groundY - player.h;
        player.vy = 0;
        player.jumping = false;
        player.angle = 0;
        player.suspension = 0;
        gameOver = false;
        document.getElementById('message').textContent = 'Arrow Up/Down to change speed, Space to jump. Time jumps, absorb landings, and stay on the throttle.';
      }
    });

    window.addEventListener('keyup', e => { keys[e.key] = false; });

    function drawBike() {
      const { x, y, w, h, angle, suspension } = player;
      ctx.save();
      ctx.translate(x + w / 2, y + h / 2 + suspension);
      ctx.rotate(angle);

      // Wheels
      ctx.fillStyle = '#0d0d0d';
      [-(w / 2 - 8), (w / 2 - 8)].forEach(offsetX => {
        ctx.beginPath();
        ctx.arc(offsetX, h / 2, h / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = '#c5c5c5';
        ctx.lineWidth = 2;
        ctx.arc(offsetX, h / 2, h / 2 - 4, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Frame
      ctx.strokeStyle = '#c63f2b';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-w / 2 + 6, h / 2 - 4);
      ctx.lineTo(4, -h / 2 + 2);
      ctx.lineTo(w / 2 - 4, h / 2 - 6);
      ctx.stroke();

      ctx.strokeStyle = '#2a2a2a';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(-w / 2 + 6, h / 2 - 4);
      ctx.lineTo(-w / 2 + 12, -h / 2 + 4);
      ctx.lineTo(w / 2 - 6, -h / 2 + 10);
      ctx.stroke();

      // Engine block
      ctx.fillStyle = '#5f5f5f';
      ctx.fillRect(-6, -h / 2 + 2, 18, 16);
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(-2, -h / 2 + 4, 10, 12);

      // Seat and tank
      ctx.fillStyle = '#2e2e2e';
      ctx.beginPath();
      ctx.moveTo(-w / 2 + 10, -h / 2 + 2);
      ctx.lineTo(2, -h / 2 - 4);
      ctx.lineTo(w / 2 - 12, -h / 2 + 2);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#c63f2b';
      ctx.fillRect(-8, -h / 2 - 2, 18, 6);

      // Rider
      ctx.fillStyle = '#202020';
      ctx.fillRect(-6, -h / 2 - 18, 14, 18); // torso
      ctx.fillStyle = '#424242';
      ctx.fillRect(-8, -h / 2 - 4, 18, 6); // lap
      ctx.fillStyle = '#2f2f2f';
      ctx.fillRect(-10, -h / 2 - 28, 18, 12); // shoulders
      ctx.fillStyle = '#d3d3d3';
      ctx.beginPath();
      ctx.arc(0, -h / 2 - 30, 8, 0, Math.PI * 2); // helmet
      ctx.fill();
      ctx.fillStyle = '#1b1b1b';
      ctx.fillRect(-4, -h / 2 - 32, 8, 6); // visor

      // Handlebars
      ctx.strokeStyle = '#d0d0d0';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(w / 2 - 14, -h / 2 + 4);
      ctx.lineTo(w / 2 + 12, -h / 2 - 6);
      ctx.stroke();
      ctx.fillStyle = '#252525';
      ctx.fillRect(w / 2 + 8, -h / 2 - 8, 6, 12);

      ctx.restore();
    }

    function drawDust() {
      ctx.fillStyle = 'rgba(110, 92, 70, 0.4)';
      dust.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, Math.max(1, p.life / 20), 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function drawSky() {
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, '#313f55');
      gradient.addColorStop(0.5, '#55637a');
      gradient.addColorStop(1, '#7f6d4d');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawScenery() {
      scenery.forEach(s => {
        s.x -= speed * 0.3 * s.scale;
        if (s.x < -100) s.x = canvas.width + Math.random() * 200;
        ctx.save();
        ctx.translate(s.x, s.baseY + Math.sin((distance + s.x) * 0.002) * 2);
        ctx.scale(s.scale, s.scale);
        if (s.type === 'tree') {
          ctx.fillStyle = '#1d2216';
          ctx.fillRect(-6, 10, 12, 40);
          ctx.fillStyle = '#2f4220';
          ctx.beginPath();
          ctx.moveTo(0, -10);
          ctx.lineTo(26, 40);
          ctx.lineTo(-26, 40);
          ctx.closePath();
          ctx.fill();
        } else {
          ctx.fillStyle = '#101010';
          ctx.fillRect(-20, 10, 40, 18);
          ctx.fillStyle = '#2f2f2f';
          ctx.fillRect(-16, 2, 32, 12);
          ctx.fillStyle = '#d9d9d9';
          for (let i = -12; i <= 12; i += 6) {
            ctx.fillRect(i, 0, 3, 8);
          }
        }
        ctx.restore();
      });
    }

    function drawTrack() {
      const gradient = ctx.createLinearGradient(0, groundY - 60, 0, canvas.height);
      gradient.addColorStop(0, '#5c4a34');
      gradient.addColorStop(0.35, '#4a3825');
      gradient.addColorStop(1, '#2b1f14');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, groundY - 20, canvas.width, canvas.height - (groundY - 20));
      ctx.fillStyle = '#2b241a';
      ctx.fillRect(0, groundY + 30, canvas.width, 60);

      ctx.strokeStyle = 'rgba(24,17,12,0.55)';
      ctx.lineWidth = 4;
      for (let x = trackOffset; x < canvas.width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, groundY + 6);
        ctx.lineTo(x + 24, groundY + 6);
        ctx.stroke();
      }

      ctx.strokeStyle = 'rgba(73,56,38,0.6)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.moveTo(0, groundY + i * 10);
        ctx.lineTo(canvas.width, groundY + i * 10 + Math.sin((distance * 0.01) + i) * 2);
        ctx.stroke();
      }
    }

    initScenery();
    loop();
  </script>
  <script>
    fetch('../sidebar.html')
      .then(r => r.text())
      .then(html => {
        const placeholder = document.getElementById('sidebar-placeholder');
        if (placeholder) placeholder.outerHTML = html;
      });
  </script>
</body>
</html>

